<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.5.1"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>Self-changing Data Type - CVE-2024-40676 漏洞分析 - 残页的小博客</title><meta name="keywords" content="android,system,安全"><meta name="description" content="今年 10 月份的时候，Android 安全公告用 CVE-2024-40676 的编号公布了一个很奇怪的 patch。AccountManagerService checkKeyIntent() 负责检查 account authenticator 传回的 intent，确保它安全再传回给 caller，防止 ..."><link rel="alternate" href="/atom.xml" title="残页的小博客"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="/data/image/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script><script type="text/javascript" src="/sw-register.js"></script></head><body><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="container"><div class="wrapper"><div class="nav-sub"><p class="title"></p><ul class="switcher nav-list-h"><li><a class="s-comment fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main"><a class="title flat-box" target="_self" href="/">残页的小博客</a><div class="menu navigation"><ul class="nav-list-h"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博客</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i>友链</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="搜索……"></form></div><ul class="switcher nav-list-h"><li><a class="s-search fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a><ul class="menu-phone list-v navigation white-box"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博客</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i>友链</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></li></ul></div></div></div></header><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow blur article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/2024/11/07/self-changing-data-type/">Self-changing Data Type - CVE-2024-40676 漏洞分析</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://blog.canyie.top/" rel="nofollow"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/data/image/avatar_new.jpg"><p>canyie</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i><p>发布于2024年11月7日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard fa-fw" aria-hidden="true"></i><p>字数：5.5k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i><p>时长：23分钟</p></a></div><div class="new-meta-item browse busuanzi"><a class="notlink"><i class="fas fa-eye fa-fw" aria-hidden="true"></i><p><span id="busuanzi_value_page_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>今年 10 月份的时候，Android 安全公告用 CVE-2024-40676 的编号公布了一个很奇怪的 <a href="https://android.googlesource.com/platform/frameworks/base/+/e8a53246607b52b15269f97aef9ba7e928ba2473" target="_blank" rel="noopener">patch</a>。<br>AccountManagerService checkKeyIntent() 负责检查 account authenticator 传回的 intent，确保它安全再传回给 caller，防止 launch anywhere 漏洞。这个补丁看起来很暴力也很奇怪，直接 ban 了所有带有 content URI 的 intent，似乎完全不考虑兼容性。是什么样的漏洞才要上如此暴力的修复方法？<br>注：如下全是我的猜测，由于联系不到漏洞作者本人，无法确认这是否就是原本的问题。</p><a id="more"></a><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.java</span><br><span class="line">index b45bcb4..b59a5ea 100644</span><br><span class="line"><span class="comment">--- a/services/core/java/com/android/server/accounts/AccountManagerService.java</span></span><br><span class="line"><span class="comment">+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java</span></span><br><span class="line"><span class="meta">@@ -4959,6 +4959,9 @@</span></span><br><span class="line">                 if (resolveInfo == null) &#123;</span><br><span class="line">                     return false;</span><br><span class="line">                 &#125;</span><br><span class="line"><span class="addition">+                if ("content".equals(intent.getScheme())) &#123;</span></span><br><span class="line"><span class="addition">+                    return false;</span></span><br><span class="line"><span class="addition">+                &#125;</span></span><br><span class="line">                 ActivityInfo targetActivityInfo = resolveInfo.activityInfo;</span><br><span class="line">                 int targetUid = targetActivityInfo.applicationInfo.uid;</span><br><span class="line">                 PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>前置知识：launch anywhere 漏洞，这里推荐几篇解析：</p><ul><li><a href="http://retme.net/index.php/2014/08/20/launchAnyWhere.html" target="_blank" rel="noopener">retme：launchAnyWhere: Activity组件权限绕过漏洞解析(Google Bug 7699048)</a></li><li><a href="https://xuanxuanblingbling.github.io/ctf/android/2024/04/13/launchanywhere01" target="_blank" rel="noopener">clang 裁缝店：LaunchAnyWhere 漏洞现世：Google Bug 7699048 复现与分析(Android4.3)</a></li></ul><p>读者也可以自己上网搜索。</p><h3 id="猜想：URI-grant？"><a href="#猜想：URI-grant？" class="headerlink" title="猜想：URI grant？"></a>猜想：URI grant？</h3><p>初看这个补丁，虽然提交信息非常谜语人，但很明显它和 content URI 相关，而且很明显这个 intent 最后会被返回给调用者进行 startActivity，很容易能想到的就是 URI grant。<br>然而这个猜想被官方公布的信息否决了，从其他地方拿到了这个漏洞的描述和报告原标题，其中 Summary 是报告标题，Details 是官方给出的漏洞描述：</p><blockquote><p>Summary: In AccountManagerService’s checkKeyIntent method there is a possible way to bypass Intent check and lead to LaunchAnyWhere on All Android version<br>Details: In checkKeyIntent of AccountManagerService.java, there is a possible way to bypass intent security check and install an unknown app due to a confused deputy. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.</p></blockquote><p>虽然仍然是谜语人，但其中出现了 <code>Launch Anywhere</code> 和 <code>install an unknown app</code> 字眼，显然这不可能是单纯的 URI grant 能完成的事。思路自此中断了……吗？</p><h3 id="抽丝剥茧：影响-resolveActivity-流程？"><a href="#抽丝剥茧：影响-resolveActivity-流程？" class="headerlink" title="抽丝剥茧：影响 resolveActivity 流程？"></a>抽丝剥茧：影响 resolveActivity 流程？</h3><p>如果你对 AccountManagerService 及 2014 年 Launch Anywhere 漏洞足够熟悉，你应该会知道补丁 <code>checkKeyIntent()</code> 的详细实现。简单来说，它先检查了 Bundle 中的 intent 在反序列化前后一致，然后调用 <code>resolveActivityAsUser()</code> 检查该 intent 指向的 activity 是否能启动，所有检查通过后才会返回 bundle 让调用者进行 startActivity。<br>基于上述漏洞信息，再结合补丁及上下文细节，我们暂时得出如下结论：</p><ol><li>它能绕过 checkKeyIntent() 里的安全检查从而启动不安全的 activity</li><li>它需要在 intent 中设置一个 content URI 作为 data 才能实现（废话），而且很可能只需要这一步或者这是最关键的一步，否则不至于上这种暴力补丁</li><li>很可能不是 bundle mismatch 类问题，理由：作者表示此漏洞能在所有 Android 版本上触发，而我个人想不到应该怎么绕过 Lazy Bundle 及 <code>checkKeyIntentParcelledCorrectly()</code> 两重缓解措施，而且考虑到这个补丁只会在 <code>intent != null</code> 时触发，如果是 bundle mismatch 的话，直接让它在 AccountManagerService 中拿到 null 即可绕过。从这一点我们还可以推出 AccountManagerService 与 caller 拿到的 intent 应该是相同的。</li></ol><p>基于 3 我们假设这里没有 self-changing Bundle 等技术会影响到 intent 本身，往下推得 AccountManagerService 和 caller 拿到的 intent 相同，那剩下的就只有一点可以怀疑：难道是 AccountManagerService resolveActivity() 到的结果与 caller 实际调用 startActivity 启动的 activity 存在差异？</p><h3 id="Intent-Filter-Data-Mimetype"><a href="#Intent-Filter-Data-Mimetype" class="headerlink" title="Intent Filter Data Mimetype"></a>Intent Filter Data Mimetype</h3><p>如果读者有医学相关的经验，应该会知道医学上有个“一元论”，即对于病人的多种症状或现象，首先尝试用单一的一种疾病去解释所有症状，而不是单独片面去看待每个症状将其认为是多个疾病叠加而成。我们这里尝试根据有限的信息去尝试找出问题所在，和医生诊断疾病很像，也可以尝试用这种思维去思考。<br>翻看 <code>startActivity()</code> 的流程，可以发现它解析目标组件也是用的 <code>resolveActivity()</code>，如果说两边存在差异，先基于一元论假设 PackageManagerService resolveActivity() 本身被正确实现没有 bug，那么一定是两个调用中间有什么东西被改变了，即我们说的 TOCTTOU 问题。<br>但是这样我们还是没什么头绪，因为能够影响 intent 解析结果的因素太多了。如果上述情况发生，那么几乎可以肯定这个 intent 一定是一个隐式 intent（显式 intent 连组件名都设置好了，没什么操作余地）；再考虑到补丁中的 content uri data，可以大胆假设，content uri 会影响隐式 intent 解析流程，导致两次解析到不一样的结果。</p><p>我们知道一个组件只有声明了 intent filter 而且匹配，才有可能被选中为隐式 intent 的目标。翻看 intent filter 的<a href="https://developer.android.com/guide/topics/manifest/data-element" target="_blank" rel="noopener">文档</a>，我们可以发现其实它是支持通过 intent data 来匹配的，只需要声明一个 data 标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:host</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:port</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:path</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:pathPattern</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:pathPrefix</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:pathSuffix</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:pathAdvancedPattern</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">android:mimeType</span>=<span class="string">"string"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这里其实还漏了一些属性，比如 android:ssp 这个属性就没提到。里面的大部分属性，比如 scheme、host 这种基本上都是直接从 URI String 中解析出来的，而根据上述的分析，攻击者应该是没法让 data 这个 uri 本身发生改变的（否则直接改掉 scheme 就直接绕过补丁了），所以应该跟本漏洞没多大关联。看起来能搞些名堂的就只有最后的 mimeType 属性？<br>至于什么是 Mime Type 不了解的读者可以自行百度，这里就不赘述了。这里引入了一个很有趣的问题，我们知道对于 file:///sdcard/abc.txt 我们可以一眼看出来它的 mime type 是 text/plain，而对于 content URI，它的值需要调用其指向的 content provider 才能获得，那么它的 type 是怎么拿到的呢？<br>答案很简单：也是调用 content provider 获取。根据官方<a href="https://developer.android.com/reference/android/content/ContentProvider#getType(android.net.Uri)" target="_blank" rel="noopener">文档</a>， ContentProvider 有一个专门的 getType() 方法用来返回 mime type。因为它是主动调用我们自己才能得到结果，换句话说也就是结果是通过执行我们自己自定义的代码得到的，这里其实操作空间就很大了。<br>还有一个问题，这个 type 会被实际用在解析流程中吗？答案是肯定的。简单追一下 resolveActivity() 的流程，<a href="https://cs.android.com/android/platform/superproject/+/android-15.0.0_r1:frameworks/base/core/java/android/app/ApplicationPackageManager.java;l=1466-1477" target="_blank" rel="noopener">甚至不用追进 system server 里就能看见</a>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResolveInfo <span class="title">resolveActivityAsUser</span><span class="params">(Intent intent, ResolveInfoFlags flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mPM.resolveIntent(</span><br><span class="line">            intent,</span><br><span class="line">            intent.resolveTypeIfNeeded(mContext.getContentResolver()),</span><br><span class="line">            updateFlagsForComponent(flags.getValue(), userId, intent),</span><br><span class="line">            userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the MIME data type of this intent, only if it will be needed for</span></span><br><span class="line"><span class="comment"> * intent resolution.  This is not generally useful for application code;</span></span><br><span class="line"><span class="comment"> * it is used by the frameworks for communicating with back-end system</span></span><br><span class="line"><span class="comment"> * services.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resolver A ContentResolver that can be used to determine the MIME</span></span><br><span class="line"><span class="comment"> *                 type of the intent's data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The MIME type of this intent, or null if it is unknown or not</span></span><br><span class="line"><span class="comment"> *         needed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">String <span class="title">resolveTypeIfNeeded</span><span class="params">(@NonNull ContentResolver resolver)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Match logic in PackageManagerService#applyEnforceIntentFilterMatching(...)</span></span><br><span class="line">    <span class="keyword">if</span> (mComponent != <span class="keyword">null</span> &amp;&amp; (Process.myUid() == Process.ROOT_UID</span><br><span class="line">            || Process.myUid() == Process.SYSTEM_UID</span><br><span class="line">            || mComponent.getPackageName().equals(ActivityThread.currentPackageName()))) &#123;</span><br><span class="line">        <span class="keyword">return</span> mType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resolveType(resolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the MIME data type of this intent.  If the type field is</span></span><br><span class="line"><span class="comment"> * explicitly set, that is simply returned.  Otherwise, if the data is set,</span></span><br><span class="line"><span class="comment"> * the type of that data is returned.  If neither fields are set, a null is</span></span><br><span class="line"><span class="comment"> * returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resolver A ContentResolver that can be used to determine the MIME</span></span><br><span class="line"><span class="comment"> *                 type of the intent's data.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> The MIME type of this intent.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #getType</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #resolveType(Context)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@Nullable</span> <span class="function">String <span class="title">resolveType</span><span class="params">(@NonNull ContentResolver resolver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"content"</span>.equals(mData.getScheme())) &#123;</span><br><span class="line">            <span class="keyword">return</span> resolver.getType(mData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Return the MIME type of the given content URL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> url A Uri identifying content (either a list or specific type),</span></span><br><span class="line"><span class="comment"> * using the content:// scheme.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> A MIME type for the content, or null if the URL is invalid or the type is unknown</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">String <span class="title">getType</span><span class="params">(@NonNull Uri url)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(url, <span class="string">"url"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mWrapped != <span class="keyword">null</span>) <span class="keyword">return</span> mWrapped.getType(url);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IContentProvider provider = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        provider = acquireProvider(url);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// if unable to acquire the provider, then it should try to get the type</span></span><br><span class="line">        <span class="comment">// using getTypeAnonymous via ActivityManagerService</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> StringResultListener resultListener = <span class="keyword">new</span> StringResultListener();</span><br><span class="line">            provider.getTypeAsync(mContext.getAttributionSource(),</span><br><span class="line">                    url, <span class="keyword">new</span> RemoteCallback(resultListener));</span><br><span class="line">            resultListener.waitForResult(CONTENT_PROVIDER_TIMEOUT_MILLIS);</span><br><span class="line">            <span class="keyword">if</span> (resultListener.exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> resultListener.exception;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> resultListener.result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// Arbitrary and not worth documenting, as Activity</span></span><br><span class="line">            <span class="comment">// Manager will kill this process shortly anyway.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Failed to get type for: "</span> + url + <span class="string">" ("</span> + e.getMessage() + <span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                releaseProvider(provider);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (java.lang.NullPointerException e) &#123;</span><br><span class="line">                <span class="comment">// does nothing, Binder connection already null</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果你去看 startActivity 的源码，你会发现这个 resolved type 也会被用到，这里不赘述。也就是说，这个 type 可以影响解析的结果。<br>至此答案就已经呼之欲出了：我们可以在这个 content provider 的 getType() 中动手脚，让其进行安全检查时和实际启动 activity 时得到两个不同的 type，就能绕过检查启动恶意 activity！</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>有了如上的分析积累，接下来复现它就是很简单的事。我们已知 AccountManagerService 只允许启动我们 app 自己的 activity （还有两个系统自己的 activity 但是在这个漏洞中完全没用），那么我们需要自己声明一个 activity 让它匹配一个 mime type，然后在 Content Provider 中进行一个简单的计数来决定返回哪个 mime type。<br>很明显，这个漏洞本身只允许我们启动接收隐式 intent 的 activity，那我们能选择攻击什么组件，又能造成多大的危害呢？</p><h3 id="尝试1：Re-Redirection？"><a href="#尝试1：Re-Redirection？" class="headerlink" title="尝试1：Re-Redirection？"></a>尝试1：Re-Redirection？</h3><p>首先想到的是，如果我们能通过隐式 intent 启动某个受保护 activity，而这个 activity 又能按我们意图启动其他组件，例如从 extras 里拿到一个 intent 然后直接发送出去，那么我们通过这种二次重定向就能调用到没有声明 intent filter 的组件，大大扩展我们的攻击面。<br>那么有没有这样的 activity 呢？有。Settings 中有一个叫做 SearchResultTrampoline 的 activity，可以通过发送 <code>com.android.settings.SEARCH_RESULT_TRAMPOLINE</code> 启动，其本身会在校验调用者为 Settings 本身后从 extras 取出调用者指定的参数，然后启动任意 activity 或 Settings 内的任意 fragment。更美好的是，这里的入参 intent 甚至也是以一个 URI String 的方式给出，所以即使是我们没法往里面放入 Parcelable 对象的情况也可以利用这个 activity 实现 launch anywhere。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".search.SearchResultTrampoline"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:theme</span>=<span class="string">"@android:style/Theme.NoDisplay"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:excludeFromRecents</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:knownActivityEmbeddingCerts</span>=<span class="string">"@array/config_known_host_certs"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"com.android.settings.SEARCH_RESULT_TRAMPOLINE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看起来很美好，是吧？不过这个 intent filter 并没有指定 <code>&lt;data&gt;</code> 标签，这种情况我们能利用吗？一个很自然的思路就是，我们可以通过把 type 设置成 null 的方式来让一个带有 content URI 的隐式 intent 匹配到它吗？<br>很遗憾的是，此路不通。尝试自己声明一个 activity 接收同 action 再加上一个 mimeType 为 <code>application/canyie</code> 的 data 标签，经过实验，type 设置为 <code>application/canyie</code> 时确实可以解析到自己的 activity，但设置为 null 即会触发 ActivityNotFoundException。<br>那还有这样的 activity 吗？还有很多，比如 ChooserActivity 和 ResolverActivity，两者都是 framework 中的自带 activity，会通过 <code>startAsCaller</code> 的方式以调用者的权限发送指定 intent。如果我们能让 system uid 启动这两个 activity，就能再次获得以 system uid 发送任意 intent 的能力。可惜的是，ResolverActivity 并没有声明任何 intent filter，而 ChooserActivity 虽然声明了 android.intent.action.CHOOSER 这个 action，但同样也没有声明 data 标签。其他类似的 activity 也大多是如此情况，我并没有在 AOSP 中找到符合条件的 activity，所以只能放弃这条路。</p><h3 id="尝试2：CALL-PRIVILEGED？"><a href="#尝试2：CALL-PRIVILEGED？" class="headerlink" title="尝试2：CALL_PRIVILEGED？"></a>尝试2：CALL_PRIVILEGED？</h3><p>我们已经知道，利用此漏洞只能启动带有 data 标签 intent filter 的 activity。满足这些条件而且本身又要有危害的 activity 很少，复现 Launch Anywhere 类漏洞时我们常用的 PlatLogoActivity 还有重设锁屏密码的页面都没法用这种方法启动。不过我们还常用 android.intent.action.CALL_PRIVILEGED 这个 action 让手机直接拨打任意电话包括紧急电话来完成复现，来看看哪个 activity 处理这个 action：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Works like CallActivity with CALL_PRIVILEGED instead of CALL intent.</span></span><br><span class="line"><span class="comment">     CALL_PRIVILEGED allows calls to emergency numbers unlike CALL which disallows it.</span></span><br><span class="line"><span class="comment">     Intent-sender must have the CALL_PRIVILEGED permission or the broadcast will not be</span></span><br><span class="line"><span class="comment">     processed. High priority of 1000 is used in all intent filters to prevent anything but</span></span><br><span class="line"><span class="comment">     the system from processing this intent (b/8871505). --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">activity-alias</span> <span class="attr">android:name</span>=<span class="string">"PrivilegedCallActivity"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:targetActivity</span>=<span class="string">".components.UserCallActivity"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:permission</span>=<span class="string">"android.permission.CALL_PRIVILEGED"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:process</span>=<span class="string">":ui"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.CALL_PRIVILEGED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"tel"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"1000"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">android:icon</span>=<span class="string">"@drawable/ic_launcher_sip_call"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.CALL_PRIVILEGED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"sip"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.CALL_PRIVILEGED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"voicemail"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"1000"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.CALL_PRIVILEGED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"vnd.android.cursor.item/phone"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"vnd.android.cursor.item/phone_v2"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"vnd.android.cursor.item/person"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity-alias</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 <code>PrivilegedCallActivity</code> 定义在 telecomm 里，其本身被 <code>android.permission.CALL_PRIVILEGED</code> 权限保护所以第三方应用无法调用，而且所有 intent filter 都有 data 标签！这不就是我们梦寐以求的受害组件吗？<br>等等，先别半场开香槟！回过头仔细看看它定义的所有 intent filter，前三个强制规定了 scheme 所以我们带有 content URI 的 intent 是无法匹配的；最后一个只规定了 mimeType 没有规定 scheme，看起来完全可以利用，可以再把香槟打开了……吗？<br>事实上，隐式 intent 是无法匹配到最后一个 intent filter 的。这是因为它没声明 android.intent.category.DEFAULT 这个 category。至于原因嘛，上面 UserCallActivity 的注释里写了，就是故意的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Omit default category below so that all Intents sent to this filter must be</span></span><br><span class="line"><span class="comment">                     explicit. --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.CALL"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"vnd.android.cursor.item/phone"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"vnd.android.cursor.item/phone_v2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"vnd.android.cursor.item/person"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br></pre></td></tr></table></figure><p>摆明了就是歧视隐式 intent。得，你写的代码，你说了算。再次此路不通。</p><h3 id="尝试3：安装未知应用……什么是“未知应用”？"><a href="#尝试3：安装未知应用……什么是“未知应用”？" class="headerlink" title="尝试3：安装未知应用……什么是“未知应用”？"></a>尝试3：安装未知应用……什么是“未知应用”？</h3><p>回头看漏洞描述，里面提到了“bypass intent security check and install an unknown app”，正好启动 PackageInstaller 的私有 Activity 静默安装应用也是 launch anywhere 型漏洞常用的利用方法，那就再点开 PackageInstaller 看一眼。<br>我们一般攻击 InstallInstalling 这个 activity 进行静默安装应用，对于静默卸载则使用 UninstallUninstalling，而很遗憾这两个 activity 都没有声明任何 intent filter。观察 PackageInstaller 的 AndroidManifest.xml，用漏洞唯一能进来的就是这个 InstallStart：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".InstallStart"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:exported</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:excludeFromRecents</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.INSTALL_PACKAGE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"content"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/vnd.android.package-archive"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.INSTALL_PACKAGE"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"package"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">"content"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.content.pm.action.CONFIRM_INSTALL"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span> <span class="attr">android:priority</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.content.pm.action.CONFIRM_PRE_APPROVAL"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个 activity 完全没被保护，我们平常写代码请求安装应用或者在文件管理器里点 apk 安装的时候进来的就是这个 activity。而观察里面的代码，也没有诸如“调用者是可信系统应用就直接安装不进行确认”这种逻辑。<br>那么漏洞作者有没有可能是攻击了应用市场的私有 activity？的确有这个可能，但是我简单扫了一眼 play store，也没找到能用的。这部分我没有完全反编译确认，只是简单看了一眼。欢迎勘误。<br>突然间，我灵光一闪……漏洞描述为什么说“unknown app”而不是“arbitrary app without user interaction”？说明很可能根本就不是静默安装 app？<br>这里简单介绍一下“未知来源”的概念：一个第三方不可信应用尝试安装其他 app 的时候需要用户手动先授权它安装未知 app，然后才能进入正常的安装确认页面。这个功能是在 PackageInstaller 中检测调用者然后判断它权限实现的。如果有办法让其他有权限的 app 帮忙启动 PackageInstaller，就能绕过这个限制。所以，漏洞作者很可能只是绕过了这个“未知来源”，而不是实现了静默安装！<br>说实话，我分析到这里的时候自己都被无语住了，跟我玩文字游戏呢……<br>后续我没有再去复现，从代码来看理论上是可行的，但是我个人觉得这种绕过的危害实在是低到可以忽略不计。感兴趣的读者可以自己试试。</p><h3 id="尝试4：静默安装证书"><a href="#尝试4：静默安装证书" class="headerlink" title="尝试4：静默安装证书"></a>尝试4：静默安装证书</h3><p>我们常用的利用方法都不行，这里我提出一种新的方法：调用 CertInstaller 静默安装证书。其实很久之前就有人提出过这种利用思路，但是一直没什么热度，考虑到 Android 7.0 开始不再默认信任用户安装的证书，具体能造成什么危害也有些许疑问。不管怎么样，反正它能静默安装（<br>先介绍一下 CertInstaller，我们的漏洞唯一能打到的就是这个叫 CertInstallerMain 的页面：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".CertInstallerMain"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:theme</span>=<span class="string">"@style/Transparent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:configChanges</span>=<span class="string">"orientation|keyboardHidden|screenSize"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:exported</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.credentials.INSTALL"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/x-x509-ca-cert"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/x-x509-user-cert"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/x-x509-server-cert"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/x-pkcs12"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/x-pem-file"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/pkix-cert"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:mimeType</span>=<span class="string">"application/x-wifi-config"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure><p>很明显我们可以通过发送带有 action=android.intent.action.VIEW type=底下那一堆的 intent 触发它，而虽然这个 activity 没被保护，但是它里面兜兜转转其实最后会判断调用者，如果是 Settings 就直接无确认安装，否则显示个对话框要求你进 Settings 里手动安装。<br>所以我们大概的思路就是，声明一个 activity 处理 VIEW 的 action + 一个随机 mime type，自己继承一下 FileProvider 然后重写 getType 在里面写个计数决定返回哪个 type，然后让系统帮我们启动 intent 即可。<br>两个需要注意的点：1. intent 要带上一个 certificate_install_usage 的 extra 否则 CertInstaller 认不出证书类型；2. system uid 不允许发出不在白名单的 URI grant，所以在 intent 里添加 grant flags 并不能给 CertInstaller 授权读写自己的 provider。解决方法可以是直接把它声明成 exported（但是这样要改 FileProvider源码），我偷懒就直接硬编码调用 <code>grantUriPermission()</code> 给 CertInstaller 授权了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我个人觉得虽然这个洞能调起被保护的 activity，Google 也给出了高危评级，但条件实在太过苛刻（我自己是想不到会有多少 activity 又有 mimeType 又被保护），在 AOSP 中的影响不是很大，但是这个利用本身还是非常精巧的，需要对 Android 有很深的了解才能写出来。<br>我一开始参考 Parcel Mismatch 把这种漏洞叫做“Intent Data Type Mismatch”，后面考虑“mismatch”这个英文单词可能更加强调的是“配对错了”的意思，而不是两次解析过程中因为其他因素造成的不一致，改成参考 Self-changing Bundle 这个名字命名为“Self-changing Data Type”。当然我不是漏洞发现者，没有命名权，这个命名看看就好。（所以你的 double reflection 无人问 别人一朝命名成 meta reflection 天下知怎么算……）<br>AccountManager API 是 Android 2.0 也即 2009 年添加的，Launch Anywhere 漏洞已经是 2014 年爆出来的，完全没想到除了 bundle mismatch 十年之后还能爆出来这样一种优雅的利用方法，实在佩服。这个漏洞的原理还是比较简单的，就是一个类似 TOCTTOU race condition 的问题。除了直接拒绝 content uri 以外，还有一种修复思路是做完安全检查之后直接给 intent 设置上 component name 让它成为一个显式 intent，后续 startActivity() 时就不会再进入隐式 intent 的解析流程，两种方法都能阻止它指向的组件发生变化也就修复了漏洞。<br>由于联系不到漏洞作者本人，所以以上文字纯属我的推理，没法和漏洞作者确认是否正确，也欢迎各位读者勘误。<br>推理的过程本身其实也很过瘾，有点烧脑，有一种刑侦探案的感觉，在现场通过嫌疑人遗留的证据一点一点的抽丝剥茧还原案件真相。33iq 什么的跟这个比起来都弱爆了，建议把这个漏洞改编成剧本杀（不是</p><p>2025 年 1 月 10 日更新：<br>官方给出了这个漏洞的 <a href="https://cs.android.com/android/platform/superproject/main/+/main:cts/hostsidetests/securitybulletin/test-apps/CVE-2024-40676/src/android/security/cts/CVE_2024_40676/PocFileProvider.java;l=35" target="_blank" rel="noopener">test</a> 代码，算是侧面印证了我的分析。</p><br><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://blog.canyie.top/2024/11/07/self-changing-data-type/">https://blog.canyie.top/2024/11/07/self-changing-data-type/</a></p></blockquote></div></section></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2025-04-24T18:33:02+08:00"><a class="notlink"><i class="fas fa-edit fa-fw" aria-hidden="true"></i><p>更新于2025年4月24日</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/android/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>android</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/system/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>system</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E5%AE%89%E5%85%A8/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>安全</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.canyie.top/2024/11/07/self-changing-data-type/&title=Self-changing Data Type - CVE-2024-40676 漏洞分析 - 残页的小博客&summary=今年 10 月份的时候，Android 安全公告用 CVE-2024-40676 的编号公布了一个很奇怪的 patch。AccountManagerService checkKeyIntent() 负责检查 account authenticator 传回的 intent，确保它安全再传回给 caller，防止 launch anywhere 漏洞。这个补丁看起来很暴力也很奇怪，直接 ban 了所有带有 content URI 的 intent，似乎完全不考虑兼容性。是什么样的漏洞才要上如此暴力的修复方法？注：如下全是我的猜测，由于联系不到漏洞作者本人，无法确认这是否就是原本的问题。" target="_blank"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://blog.canyie.top/2024/11/07/self-changing-data-type/&title=Self-changing Data Type - CVE-2024-40676 漏洞分析 - 残页的小博客&summary=今年 10 月份的时候，Android 安全公告用 CVE-2024-40676 的编号公布了一个很奇怪的 patch。AccountManagerService checkKeyIntent() 负责检查 account authenticator 传回的 intent，确保它安全再传回给 caller，防止 launch anywhere 漏洞。这个补丁看起来很暴力也很奇怪，直接 ban 了所有带有 content URI 的 intent，似乎完全不考虑兼容性。是什么样的漏洞才要上如此暴力的修复方法？注：如下全是我的猜测，由于联系不到漏洞作者本人，无法确认这是否就是原本的问题。" target="_blank"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://blog.canyie.top/2024/11/07/self-changing-data-type/&title=Self-changing Data Type - CVE-2024-40676 漏洞分析 - 残页的小博客&summary=今年 10 月份的时候，Android 安全公告用 CVE-2024-40676 的编号公布了一个很奇怪的 patch。AccountManagerService checkKeyIntent() 负责检查 account authenticator 传回的 intent，确保它安全再传回给 caller，防止 launch anywhere 漏洞。这个补丁看起来很暴力也很奇怪，直接 ban 了所有带有 content URI 的 intent，似乎完全不考虑兼容性。是什么样的漏洞才要上如此暴力的修复方法？注：如下全是我的猜测，由于联系不到漏洞作者本人，无法确认这是否就是原本的问题。" target="_blank"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a></div></div></div></section><div class="prev-next"><a class="prev" href="/2025/01/29/android-security-bulletin-index-2025/"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>Android 2025 年每月安全补丁分析索引</p><p class="content">2024 年度补丁分析：点我给大家分享一个好消息，经过一年的研究，我现在在 Google BugHunters 平台上总排名 24，2024 年度第 6 名，Android Program 第 ...</p></a><a class="next" href="/2024/11/05/android-platform-common-vulnerabilities/"><p class="title">Android 平台常见安全漏洞类型<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">本文适用于已对 Android 开发有基础了解，希望了解 Android 系统层常见安全漏洞的人。祝大家写代码无 bug，挖洞天天挖到 Critical RCE 漏洞链。本文开始创作时间：202...</p></a></div></section></article><script>window.subData={title:"Self-changing Data Type - CVE-2024-40676 漏洞分析",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow blur desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#分析"><span class="toc-text">分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#猜想：URI-grant？"><span class="toc-text">猜想：URI grant？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽丝剥茧：影响-resolveActivity-流程？"><span class="toc-text">抽丝剥茧：影响 resolveActivity 流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intent-Filter-Data-Mimetype"><span class="toc-text">Intent Filter Data Mimetype</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复现"><span class="toc-text">复现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#尝试1：Re-Redirection？"><span class="toc-text">尝试1：Re-Redirection？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尝试2：CALL-PRIVILEGED？"><span class="toc-text">尝试2：CALL_PRIVILEGED？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尝试3：安装未知应用……什么是“未知应用”？"><span class="toc-text">尝试3：安装未知应用……什么是“未知应用”？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尝试4：静默安装证书"><span class="toc-text">尝试4：静默安装证书</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></div></section><section class="widget tagcloud shadow blur desktop mobile"><header><a href="/tags/"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class="name">热门标签</span></a></header><div class="content"><a href="/tags/AOP/" style="font-size:15.67px;color:#8e8e8e">AOP</a> <a href="/tags/android/" style="font-size:24px;color:#555">android</a> <a href="/tags/art/" style="font-size:19px;color:#777">art</a> <a href="/tags/dex/" style="font-size:14px;color:#999">dex</a> <a href="/tags/hidden-api/" style="font-size:14px;color:#999">hidden-api</a> <a href="/tags/hook/" style="font-size:15.67px;color:#8e8e8e">hook</a> <a href="/tags/kernel/" style="font-size:15.67px;color:#8e8e8e">kernel</a> <a href="/tags/magisk/" style="font-size:17.33px;color:#828282">magisk</a> <a href="/tags/parcel/" style="font-size:14px;color:#999">parcel</a> <a href="/tags/property/" style="font-size:14px;color:#999">property</a> <a href="/tags/resources/" style="font-size:14px;color:#999">resources</a> <a href="/tags/system/" style="font-size:22.33px;color:#606060">system</a> <a href="/tags/xposed/" style="font-size:17.33px;color:#828282">xposed</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size:20.67px;color:#6c6c6c">安全</a> <a href="/tags/%E5%AE%89%E5%85%A8%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90%E6%A0%8F%E7%9B%AE/" style="font-size:15.67px;color:#8e8e8e">安全补丁分析栏目</a> <a href="/tags/%E5%B9%B4%E9%89%B4/" style="font-size:15.67px;color:#8e8e8e">年鉴</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size:14px;color:#999">数据结构与算法</a> <a href="/tags/%E6%B3%A8%E5%85%A5/" style="font-size:15.67px;color:#8e8e8e">注入</a> <a href="/tags/%E8%88%AA%E7%A9%BA/" style="font-size:14px;color:#999">航空</a> <a href="/tags/%E9%97%B2%E8%81%8A/" style="font-size:17.33px;color:#828282">闲聊</a></div></section></aside><footer class="clearfix"><br><br><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:a1364259@163.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/canyie" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p></div>本站使用 <a href="https://volantis.js.org/" target="_blank" class="codename">Volantis</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次<div class="copyright"><p>如对本站有任何疑问或建议，欢迎到 <a href="https://github.com/canyie/canyie.github.io/issues/" target="_blank" rel="noopener">issues 区</a> 反馈~</p></div></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var a=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/BBC19066-E176-47C2-9D22-48C81EE5DF6B.jpeg"];!function(a){for(var t=a.length;t--;){var r=Math.floor(Math.random()*t),n=a[r];a[r]=a[t],a[t]=n}}(a),$.backstretch(a,{duration:"20000",fade:"1500"})})</script><script src="/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>