<!DOCTYPE html><html><head hexo-theme="https://volantis.js.org/#2.5.1"><meta charset="utf-8"><meta name="renderer" content="webkit"><meta name="force-rendering" content="webkit"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>在故事开始之前的故事：Android 启动过程与 magiskinit 分析 - 残页的小博客</title><meta name="keywords" content="android,magisk,system,kernel"><meta name="description" content="终于开了一直想写的这篇文章，再不写点东西就真的是年更博客了……本文可以认为是 Android Booting Shenanigans 的中文补充说明，同时添加了 magiskinit 的一些处理细节。即使你对 magiskinit 没兴趣也可以看看，说不定就有一些你平时从来没注意到的细节呢 :)"><link rel="alternate" href="/atom.xml" title="残页的小博客"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="shortcut icon" type="image/x-icon" href="/data/image/favicon.ico"><link rel="stylesheet" href="/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script><script type="text/javascript" src="/sw-register.js"></script></head><body><div id="loading-bar-wrapper"><div id="loading-bar"></div></div><header class="l_header shadow blur"><div class="container"><div class="wrapper"><div class="nav-sub"><p class="title"></p><ul class="switcher nav-list-h"><li><a class="s-comment fas fa-comments fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-toc fas fa-list fa-fw" target="_self" href="javascript:void(0)"></a></li></ul></div><div class="nav-main"><a class="title flat-box" target="_self" href="/">残页的小博客</a><div class="menu navigation"><ul class="nav-list-h"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博客</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i>友链</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><i class="icon fas fa-search fa-fw"></i> <input type="text" class="input u-search-input" placeholder="搜索……"></form></div><ul class="switcher nav-list-h"><li><a class="s-search fas fa-search fa-fw" target="_self" href="javascript:void(0)"></a></li><li><a class="s-menu fas fa-bars fa-fw" target="_self" href="javascript:void(0)"></a><ul class="menu-phone list-v navigation white-box"><li><a class="flat-box" href="/" id="home"><i class="fas fa-rss fa-fw"></i>博客</a></li><li><a class="flat-box" href="/tags/" id="tags"><i class="fas fa-tags fa-fw"></i>标签</a></li><li><a class="flat-box" href="/archives/" id="archives"><i class="fas fa-archive fa-fw"></i>归档</a></li><li><a class="flat-box" href="/friends/" id="friends"><i class="fas fa-link fa-fw"></i>友链</a></li><li><a class="flat-box" href="/about/" id="about"><i class="fas fa-info-circle fa-fw"></i>关于</a></li></ul></li></ul></div></div></div></header><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box shadow blur article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href="/2023/11/12/android-booting-shenanigans-and-magiskinit-analysing/">在故事开始之前的故事：Android 启动过程与 magiskinit 分析</a></h1><div class="new-meta-box"><div class="new-meta-item author"><a href="https://blog.canyie.top/" rel="nofollow"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="/data/image/avatar_new.jpg"><p>canyie</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i><p>发布于2023年11月12日</p></a></div><div class="new-meta-item wordcount"><a class="notlink"><i class="fas fa-keyboard fa-fw" aria-hidden="true"></i><p>字数：7.4k字</p></a></div><div class="new-meta-item readtime"><a class="notlink"><i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i><p>时长：32分钟</p></a></div><div class="new-meta-item browse busuanzi"><a class="notlink"><i class="fas fa-eye fa-fw" aria-hidden="true"></i><p><span id="busuanzi_value_page_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><p>终于开了一直想写的这篇文章，再不写点东西就真的是年更博客了……</p><p>本文可以认为是 <a href="https://topjohnwu.github.io/Magisk/boot.html" target="_blank" rel="noopener">Android Booting Shenanigans</a> 的中文补充说明，同时添加了 magiskinit 的一些处理细节。即使你对 magiskinit 没兴趣也可以看看，说不定就有一些你平时从来没注意到的细节呢 :)</p><a id="more"></a><h2 id="Android-Init"><a href="#Android-Init" class="headerlink" title="Android Init"></a>Android Init</h2><p>在介绍 init 执行过程前，我们先来介绍一下 init 是什么。</p><p>init 由 Linux 内核直接启动，是 Android 启动时用户空间的第一个进程，它的 pid 为 1。它承担了挂载关键系统分区、加载 SELinux policy、启动 property service、加载并执行启动脚本（init.rc）等重要工作。我们所熟知的 zygote、service manager 等进程就是被写在了 init.rc 内由 init 负责启动的。由于 init 进程的重要性，<a href="https://source.android.com/docs/security/overview/updates-resources#context_types" target="_blank" rel="noopener">在安全层面它被视为内核的等效组件之一</a>。</p><p>抛开细节不谈，init 所做的重要的事情大概有这些：</p><ol><li>挂载 <code>/dev</code> <code>/proc</code> <code>/sys</code> 等重要文件系统，创建 <code>/dev/urandom</code> 等设备</li><li>加载 SELinux policy 进 kernel</li><li>启动 property service 处理 setprop 等事件</li><li>执行 <code>init.rc</code>，完成系统剩余的启动流程，如解密 userdata、启动 zygote 等</li></ol><h3 id="旧-rootfs-时代纯粹的-init"><a href="#旧-rootfs-时代纯粹的-init" class="headerlink" title="旧 rootfs 时代纯粹的 init"></a>旧 rootfs 时代纯粹的 init</h3><p><a href="http://aospxref.com/android-5.0.2_r3/xref/system/core/init/init.c#1001" target="_blank" rel="noopener">Android 5.0.2 init.c</a>，点进去搜索 main 查看源码，整个逻辑非常清晰，大概就是上面的列表做的事情，没什么好讲的。</p><p>在这个时候，启动流程大概如下所示：</p><ol><li>Bootloader 加载 boot.img</li><li>解压运行里面的 kernel</li><li>kernel 初始化后，调用 <code>populate_rootfs()</code> 将 boot.img 内的 ramdisk 释放到 <code>/</code></li><li>运行 <code>/init</code>，此时因为 <code>/</code> 这个根文件系统的文件是从 boot.img 的 ramdisk 中来的，所以会运行 boot ramdisk 里的 init</li><li>init 完成用户空间的初始化工作，继续开机</li></ol><p>到了 <a href="http://aospxref.com/android-6.0.1_r9/xref/system/core/init/init.cpp#989" target="_blank" rel="noopener">Android 6.0 init.cpp</a>，事情发生了一些变化：init 分了阶段。kernel 直接启动时，init 处在“一阶段”，此时 init 需要做一些用户空间的初始化工作，加载 SELinux policy，而此时因为 init 由 kernel 直接启动，它的 SELinux context 会是 <code>u:r:kernel:s0</code>，所以它会 exec 它本身来 transition 到它专属的 SELinux domain（<code>u:r:init:s0</code>）。也就是说，上面的第 5 步被拆分为下面几小步：</p><ul><li>进行挂载 <code>/dev</code> 等必要的初始化</li><li>加载 SELinux policy</li><li>重新执行 init 本身，让进程的 SELinux domain 由 kernel 转换到 init</li><li>完成剩下的初始化，继续开机</li></ul><p>这就是以前 Android 设备启动的方式。如果你在这些设备开机完成后查看 mounts 你会看见这样的东西：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rootfs &#x2F; rootfs ro,relatime 0 0</span><br></pre></td></tr></table></figure><p>这代表 <code>/</code> 的文件系统类型是 rootfs，而 rootfs 是由 kernel 挂载 boot.img 内的 ramdisk 上去的。</p><h3 id="Project-Treble-带来的旧式-system-as-root-分区布局"><a href="#Project-Treble-带来的旧式-system-as-root-分区布局" class="headerlink" title="Project Treble 带来的旧式 system-as-root 分区布局"></a>Project Treble 带来的旧式 system-as-root 分区布局</h3><p>到了 Android 8.0 时代（其实从 7.1 就开始准备了），Google 推出了 <a href="https://source.android.com/devices/architecture#hidl" target="_blank" rel="noopener">Project Treble</a>。为了实现 Project Treble 及相关的 Generic System Image，<code>/</code> 需要和系统相绑定。Google 选择了推出名为 system-as-root （以下简称为 SAR）的新分区布局。简单来说，<code>/</code> 这个根文件系统中的内容不再来自 boot.img 内的 ramdisk，而是来自 system.img。为了实现这一行为，设备的 bootloader 在启动内核时会传递启动参数 <code>skip_initramfs</code>，设备的内核会看见这一参数，从而跳过 boot.img 内的 ramdisk 而是直接挂载 system.img 到 <code>/</code>。如果你在这些设备上查看 mounts，你会发现 <code>/</code> 的文件系统类型变成了 <code>ext4</code>（或 <code>erofs</code>？）而不是 rootfs。</p><p>同时，还出现了一个新的东西，<a href="https://source.android.com/devices/tech/ota/ab" target="_blank" rel="noopener">A/B (Seamless) System Update （即所谓的 A/B 分区）</a>。设备的 boot/system/vendor 等关键分区现在其实有两个，一个会被使用，而另一个用作后备。当系统更新的时候，更新包其实会被写入后备分区。这样的好处时，当更新导致无法开机的时候，因为有另一个分区存储着可以开机的系统，设备可以自动回退到上一个可以开机的版本。副作用也很明显：这些分区本来只需要一个的，现在每个都需要两个，直接 double 了，需要更大的存储空间（之后 Google 还引入了 Virtual A/B，不过这都是后话了，对我们不重要）。</p><p>怎么减少要用的存储空间呢？在之前，Android 设备需要一个 recovery 分区，里面存储着一个小型的 Linux 系统，用于在设备无法开机时可以进入 recovery 模式，从而恢复系统。虽然引入了 A/B 分区，但是 recovery 模式仍然需要保留，而 recovery 分区则不一定。对于 A/B 设备来说，由于 <code>boot</code> 现在有两个，即使其中一个分区因为不完整的系统更新被破坏，另一个也存储着完整的、未受破坏的 boot.img，所以 boot 至少有一个是可用的；而正常开机的时候，内核会直接挂载 <code>system.img</code> 到 <code>/</code>，boot 内的 ramdisk 未被使用，所以可以用来放 recovery 的 ramdisk。此时，设备的开机流程如下所示：</p><ul><li>bootloader 判断设备是正常启动，还是要启动到 recovery</li><li>如果是正常启动，传递参数 <code>skip_initramfs</code></li><li>内核如果看见了 bootloader 传递过来的 <code>skip_initramfs</code>，就代表设备要正常启动，直接挂载 system.img 到 <code>/</code>；否则就是要启动到 recovery，因为 recovery 的 ramdisk 现在同样放在 boot，释放 boot.img 里的 ramdisk 到 <code>/</code></li><li>执行 init，继续启动流程。对于正常开机，这里 init 直接来自 system.img。</li></ul><p>而对于非 A/B 的设备，因为 boot 只有一个，可能会在 OTA 中被破坏，为了保证设备始终有可用的 recovery，它们仍然保留了 recovery 分区。boot 内的 ramdisk 根本不会被使用到，所以 boot.img 内根本没有 ramdisk，同时设备的 bootloader 可能会直接把 boot ramdisk 给排除掉（看 OEM 怎么实现的，像三星等大部分厂商就会排除，但是小米等小部分厂商就不会）。</p><p>虽然 Google 在推出它时将其直接称为 system-as-root，但为了与下文的 2-Stage-Init System-as-root 区分开来，我们把它称为 Legacy SAR。Legacy SAR 对于出厂版本在 Android 9.0 以下的设备是可选的，但对于出厂 Android 9.0 的设备是强制的。</p><h3 id="Android-10-：有三步的两步启动！"><a href="#Android-10-：有三步的两步启动！" class="headerlink" title="Android 10+：有三步的两步启动！"></a>Android 10+：有三步的两步启动！</h3><p>随着时间继续推移，到 Android 10 时，Google 推出了<a href="https://source.android.com/devices/tech/ota/dynamic_partitions/implement" target="_blank" rel="noopener">动态分区</a>。对于上文提到的 Legacy SAR 来说，这是不可能的，因为 Linux 内核无法直接理解这种新的分区格式，无法将 <code>system</code> 挂载到 <code>/</code>。</p><p>Google 的解决办法是：继续重写，发明新的启动方式！新的启动方式分为以下几步：</p><ul><li>像旧式 rootfs 一样，boot.img 内的 ramdisk 会被释放到 <code>/</code></li><li>执行 <code>/init</code>，所以 boot.img 内的 <code>/init</code> 会被执行</li><li><code>init</code> 进入“第一阶段”，初始化用户空间，挂载 <code>/system</code></li><li>执行一个 switch root 操作，将 rootdir 切换到 <code>/system</code>。现在的 <code>/</code> 其实是 switch root 之前的 <code>/system</code>。</li><li>此时，设备的分区布局由旧式的 rootfs 变为 system-as-root。接下来是加载 SELinux policy，而这一步应该和 system 绑定，所以 init 选择执行 system 内的 init 来完成这一步。</li><li>system 内的 init 收到前辈传来的 <code>selinux_setup</code> 参数，进入“第二阶段”，加载 SELinux policy。然后，为了把 SELinux domain 从 <code>kernel</code> 切到 <code>init</code>，init 再次执行自己。</li><li>init 再次被 exec，进入“第三阶段”，完成剩下的初始化工作，继续开机。</li></ul><p>（可以查看 <a href="http://aospxref.com/android-10.0.0_r47/xref/system/core/init/main.cpp" target="_blank" rel="noopener">Android 10.0 init main.cpp</a>，里面的代码很详细）。</p><p>我们把这种新的启动方式称为 2-Stage-Init （简称为 2SI）。由于开机完成后，设备的 rootdir 和 Legacy SAR 一样是 system，所以我们仍然把这种分区布局看作是 system-as-root（虽然以 Google 的标准，只有 Legacy SAR 才被看作 SAR）。</p><p>……慢着！明明 init 会被执行三次了，为什么把它称为“两步启动”？</p><p>这是因为，这种启动方式会在用户空间改变 rootdir，从 rootfs 改变为 system-as-root，而上面提到的其他两种都不会改变 rootdir。我们把 switch root 之前称为“第一步”，把 switch root 之后称为“第二步”，就得到和其他两种启动方式所区分开的名字：2SI。</p><p>对于出厂 Android 10+ 的设备来说，这种启动方式是<a href="https://source.android.com/docs/core/architecture/partitions/system-as-root" target="_blank" rel="noopener">强制的</a>；从使用 rootfs 的旧系统更新到 Android 10+ 时，也需要使用这种新的启动方式；但对于使用 Legacy SAR 的设备，它们可以继续使用 Legacy SAR。典型的例子是 Google Pixel 3 &amp; 3a 系列，出厂时它们使用 Legacy SAR，但 Google 对其进行了改进，使得升级到 Android 10 后它们转为使用 2SI 方式启动。</p><p>由于 Legacy SAR 和 2SI 最后都会使用 system-as-root 分区布局，所以搭载 Android 10+ 的设备其实都会使用 SAR。<a href="https://source.android.com/docs/core/architecture/partitions/system-as-root#about-system-only-otas" target="_blank" rel="noopener">文档</a> 中也提到 <code>All devices running Android 10 must use a system-as-root partition layout to enable system-only OTAs.</code>。</p><p>注：在 Android 10+ 上使用 Legacy SAR 时，由于 Android 10 的 init 写死了会执行三次，所以也会有 first stage、setup selinux、second stage 这三步；虽然 rootdir 没有发生改变，为了与 Android 9.0 Legacy SAR 区别，我们把这种情况称为 <code>2SI legacy SAR</code> 或 <code>Legacy SAR with 2SI</code>，而本节中提到的会改变 rootdir 的启动方式称为 <code>modern 2SI</code>、<code>2SI ramdisk SAR</code> 或 <code>2SI from initramfs</code>。当我们使用简称 <code>2SI</code> 时，我们默认指的是 <code>Modern 2SI</code>。</p><p>关于更多细节，可以查阅官方的 <a href="https://android.googlesource.com/platform/system/core/+/master/init/README.md#early-init-boot-sequence" target="_blank" rel="noopener">Android Init - Early Init Boot Sequence</a></p><h3 id="魅族：2SI，但是从-rootfs-到-rootfs"><a href="#魅族：2SI，但是从-rootfs-到-rootfs" class="headerlink" title="魅族：2SI，但是从 rootfs 到 rootfs"></a>魅族：2SI，但是从 rootfs 到 rootfs</h3><p>（注：此种特殊行为在原版 Magisk - Android Booting Shenanigans 文档中并未列出）</p><p>上文提到，“搭载 Android 10+ 的设备其实都会使用 SAR”，但对于魅族 16 系列来说并非如此。搭载 Android 10 的魅族 16 系列设备启动时会经过上面 2SI 的所有步骤，除了 switch root 这一步。由于并没有 switch root，所以设备会一直使用 rootfs。</p><h2 id="MagiskInit"><a href="#MagiskInit" class="headerlink" title="MagiskInit"></a>MagiskInit</h2><p>先来介绍一下 magiskinit 是什么：magiskinit 是 magisk 的重要组件之一，magisk 正是通过替换 init 为自己的 magiskinit 实现劫持设备启动过程的。</p><p>可以通过查看<a href="https://topjohnwu.github.io/Magisk/details.html#pre-init" target="_blank" rel="noopener">文档</a>来大概了解 magiskinit 做了什么。接下来我们结合上面的知识以及 magiskinit 源码来具体分析。</p><p>注：截至发稿，本文分析的源码为 Magisk master 分支上的最新代码。最新 commit 为 <a href="https://github.com/topjohnwu/Magisk/tree/cfb20b0f86414d851b51e10cd633328d405ca4f7" target="_blank" rel="noopener">cfb20b0</a>，点进去可以浏览对应的文件。</p><p><strong>！！！硬核警告，非战斗人员请迅速逃离现场！！！</strong></p><p>由于 magiskinit 替换了 init，所以当内核执行 init 时，magiskinit 的 main() 会被执行。main() 的代码位于 init.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> name = basename(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="string">"magisk"</span>sv)</span><br><span class="line">        <span class="keyword">return</span> magisk_proxy_main(argc, argv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getpid() != <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    BaseInit *init;</span><br><span class="line">    BootConfig config&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span> &amp;&amp; argv[<span class="number">1</span>] == <span class="string">"selinux_setup"</span>sv) &#123;</span><br><span class="line">        rust::setup_klog();</span><br><span class="line">        init = <span class="keyword">new</span> SecondStageInit(argv);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This will also mount /sys and /proc</span></span><br><span class="line">        load_kernel_info(&amp;config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config.skip_initramfs)</span><br><span class="line">            init = <span class="keyword">new</span> LegacySARInit(argv, &amp;config);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (config.force_normal_boot)</span><br><span class="line">            init = <span class="keyword">new</span> FirstStageInit(argv, &amp;config);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (access(<span class="string">"/sbin/recovery"</span>, F_OK) == <span class="number">0</span> || access(<span class="string">"/system/bin/recovery"</span>, F_OK) == <span class="number">0</span>)</span><br><span class="line">            init = <span class="keyword">new</span> RecoveryInit(argv, &amp;config);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (check_two_stage())</span><br><span class="line">            init = <span class="keyword">new</span> FirstStageInit(argv, &amp;config);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            init = <span class="keyword">new</span> RootFSInit(argv, &amp;config);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run the main routine</span></span><br><span class="line">    init-&gt;start();</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点关注几个 if 分支。</p><h3 id="RootFSInit"><a href="#RootFSInit" class="headerlink" title="RootFSInit"></a>RootFSInit</h3><p>看名字就可以看出来，这就是用来处理上面提到的第一种分区布局 RootFS 的分支。类的定义在 init.hpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/************</span></span><br><span class="line"><span class="comment"> * Initramfs</span></span><br><span class="line"><span class="comment"> ************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootFSInit</span> :</span> <span class="keyword">public</span> MagiskInit &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RootFSInit(<span class="keyword">char</span> *argv[], BootConfig *config) : MagiskInit(argv, config) &#123;</span><br><span class="line">        LOGD(<span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        prepare();</span><br><span class="line">        patch_rw_root();</span><br><span class="line">        exec_init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RootFSInit::prepare() &#123;</span><br><span class="line">    prepare_data();</span><br><span class="line">    LOGD(<span class="string">"Restoring /init\n"</span>);</span><br><span class="line">    <span class="comment">/** 把备份的原来的 init 重命名为 /init ，这样接下来我们执行 /init 的时候就会执行原本的 init **/</span></span><br><span class="line">    rename(backup_init(), <span class="string">"/init"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRE_TMPSRC <span class="meta-string">"/magisk"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRE_TMPDIR PRE_TMPSRC <span class="meta-string">"/tmp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MagiskInit::patch_rw_root() &#123;</span><br><span class="line">    mount_list.emplace_back(<span class="string">"/data"</span>);</span><br><span class="line">    parse_config_file();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create hardlink mirror of /sbin to /root</span></span><br><span class="line">    mkdir(<span class="string">"/root"</span>, <span class="number">0777</span>);</span><br><span class="line">    clone_attr(<span class="string">"/sbin"</span>, <span class="string">"/root"</span>);</span><br><span class="line">    link_path(<span class="string">"/sbin"</span>, <span class="string">"/root"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle overlays</span></span><br><span class="line">    load_overlay_rc(<span class="string">"/overlay.d"</span>);</span><br><span class="line">    mv_path(<span class="string">"/overlay.d"</span>, <span class="string">"/"</span>);</span><br><span class="line">    rm_rf(<span class="string">"/data/overlay.d"</span>);</span><br><span class="line">    rm_rf(<span class="string">"/.backup"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Patch init.rc</span></span><br><span class="line">    <span class="comment">/** 修补 init.rc，植入我们的代码，让 init 启动我们的服务 **/</span></span><br><span class="line">    patch_rc_scripts(<span class="string">"/"</span>, <span class="string">"/sbin"</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> treble;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> init = mmap_data(<span class="string">"/init"</span>);</span><br><span class="line">        treble = init.contains(SPLIT_PLAT_CIL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 因为 rootfs 是可写的，创建 /magisk，然后把 /magisk/tmp 当成 magisk 内部的 tmpfs，初始化 magisk 内部文件**/</span></span><br><span class="line">    xmkdir(PRE_TMPSRC, <span class="number">0</span>);</span><br><span class="line">    xmount(<span class="string">"tmpfs"</span>, PRE_TMPSRC, <span class="string">"tmpfs"</span>, <span class="number">0</span>, <span class="string">"mode=755"</span>);</span><br><span class="line">    xmkdir(PRE_TMPDIR, <span class="number">0</span>);</span><br><span class="line">    setup_tmp(PRE_TMPDIR);</span><br><span class="line">    chdir(PRE_TMPDIR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract magisk</span></span><br><span class="line">    <span class="comment">/** 释放 magisk32 magisk64 等文件 **/</span></span><br><span class="line">    extract_files(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 修补 SELinux policy，注入我们的规则 **/</span></span><br><span class="line">    <span class="keyword">if</span> ((!treble &amp;&amp; access(<span class="string">"/sepolicy"</span>, F_OK) == <span class="number">0</span>) || !hijack_sepolicy()) &#123;</span><br><span class="line">        patch_sepolicy(<span class="string">"/sepolicy"</span>, <span class="string">"/sepolicy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dump magiskinit as magisk</span></span><br><span class="line">    <span class="comment">/** 把 magiskinit 当成 magisk 复制到 /sbin/magisk。init 第一次启动我们的服务的时候，会进入 magisk_proxy_main **/</span></span><br><span class="line">    cp_afc(REDIR_PATH, <span class="string">"/sbin/magisk"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">magisk_proxy_main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    rust::setup_klog();</span><br><span class="line">    LOGD(<span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Mount rootfs as rw to do post-init rootfs patches</span></span><br><span class="line">    xmount(<span class="literal">nullptr</span>, <span class="string">"/"</span>, <span class="literal">nullptr</span>, MS_REMOUNT, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    unlink(<span class="string">"/sbin/magisk"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Move tmpfs to /sbin</span></span><br><span class="line">    <span class="comment">// make parent private before MS_MOVE</span></span><br><span class="line">    <span class="comment">/** 选择 /sbin 作为新的 magisk internal tmpfs（因为 /sbin 在 PATH 里，把 su 等可执行文件放在里面，运行 su 的时候直接就能找到这个文件并执行） **/</span></span><br><span class="line">    xmount(<span class="literal">nullptr</span>, PRE_TMPSRC, <span class="literal">nullptr</span>, MS_PRIVATE, <span class="literal">nullptr</span>);</span><br><span class="line">    xmount(PRE_TMPDIR, <span class="string">"/sbin"</span>, <span class="literal">nullptr</span>, MS_MOVE, <span class="literal">nullptr</span>);</span><br><span class="line">    xumount2(PRE_TMPSRC, MNT_DETACH);</span><br><span class="line">    rmdir(PRE_TMPDIR);</span><br><span class="line">    rmdir(PRE_TMPSRC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create symlinks pointing back to /root</span></span><br><span class="line">    <span class="comment">/** 恢复 sbin 里原本就有的文件 **/</span></span><br><span class="line">    recreate_sbin(<span class="string">"/root"</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell magiskd to remount rootfs</span></span><br><span class="line">    setenv(<span class="string">"REMOUNT_ROOT"</span>, <span class="string">"1"</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/** 带上参数运行真正的 magisk32/magisk64 **/</span></span><br><span class="line">    execv(<span class="string">"/sbin/magisk"</span>, argv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>patch_rc_scripts()</code> 里最重要的就是把这段 rc 脚本注入进了 init.rc，使得 init 会在系统开机过程中自动执行 magisk：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">on post-fs-data</span><br><span class="line">    start logd</span><br><span class="line">    exec %2$s 0 0 -- %1$s&#x2F;magisk --post-fs-data</span><br><span class="line"></span><br><span class="line">on property:vold.decrypt&#x3D;trigger_restart_framework</span><br><span class="line">    exec %2$s 0 0 -- %1$s&#x2F;magisk --service</span><br><span class="line"></span><br><span class="line">on nonencrypted</span><br><span class="line">    exec %2$s 0 0 -- %1$s&#x2F;magisk --service</span><br><span class="line"></span><br><span class="line">on property:sys.boot_completed&#x3D;1</span><br><span class="line">    exec %2$s 0 0 -- %1$s&#x2F;magisk --boot-complete</span><br><span class="line"></span><br><span class="line">on property:init.svc.zygote&#x3D;stopped</span><br><span class="line">    exec %2$s 0 0 -- %1$s&#x2F;magisk --zygote-restart</span><br></pre></td></tr></table></figure><p>对 init.rc 语法规则不熟的同学，可以参考 <a href="https://android.googlesource.com/platform/system/core/+/master/init/README.md" target="_blank" rel="noopener">Android Init Language</a></p><p>整个逻辑还是比较清晰的，忽略一些过于内部的细节，大概如下所示：</p><ol><li>kernel 执行 init，magiskinit 被运行，检测系统环境，进入 RootFSInit</li><li>修补 init.rc，注入我们的代码</li><li>初始化 magisk 内部要用到的 tmpfs</li><li>修补 sepolicy，注入我们的规则（细节后面再谈）</li><li>把 magiskinit 复制到 /sbin/magisk，这样 init 第一次执行 magisk 时会进入 <code>magisk_proxy_main()</code> 做剩余工作</li><li>执行系统原来的 init，继续开机流程</li><li>init 会解析并执行 init.rc，运行 magisk，这个时候运行的其实是 magiskinit，进入 <code>magisk_proxy_main()</code></li><li>把 /sbin 用作 magisk internal tmpfs，然后因为我们 mount 了 tmpfs 在 sbin 上，要把里面本来就有的文件恢复出来要不然就没了</li><li>运行真正的 magisk32/magisk64</li></ol><h3 id="Modern-2SI"><a href="#Modern-2SI" class="headerlink" title="Modern 2SI"></a>Modern 2SI</h3><p>由于劫持 Legacy SAR 的启动过程过于复杂且存在太多种情况，我们先讲 Modern 2SI。</p><p>劫持 Modern 2SI 启动过程的难点在于：由于一阶段 init 来自 boot.img 内 ramdisk，所以 magiskinit 会被执行；但是，一旦运行原来的 init，她就会挂载 /system、switch root 到 /system，我们对原来 rootfs 所做的修改 全 部 木 大。而 init 一阶段运行时，/system 还未被挂载，直接对 /system 做修改也行不通。所以我们必须找到一种方法，在 init 挂载 /system 之后做修改，且 /system 往往是 read-only 的，由于 system.img 可能是 <a href="https://twitter.com/topjohnwu/status/1170404631865778177?s=19" target="_blank" rel="noopener">de-duplicate 过的 ext4</a> 或者干脆就是 EROFS，也不可能将其 remount 为 read-write，任何方式直接修改都行不通，只能用 bind-mount 这种方法变相修改。</p><p>我们注意到，init 在 switch root 之前，会把现在的 mounts （除了 / 和 /system 本身）给 move 到新的 root 下面，然后再 switch root（具体代码可见<a href="http://aospxref.com/android-10.0.0_r47/xref/system/core/init/switch_root.cpp#80" target="_blank" rel="noopener">这里</a>）。通过利用这个特性，我们似乎可以让我们的某些东西在 switch root 之后仍然保留下来，但是怎么利用呢？</p><p>我们还是来看看 magiskinit 的代码吧。magiskinit 的基本思想是，first stage 做一些 hack，执行原本的 init 让它为我们挂载 /system 并 switch root，然后通过前面做的 hack 想办法让 init 再次触发自己。也就是说，类似 2SI，它也是分两步走的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***************</span></span><br><span class="line"><span class="comment"> * 2 Stage Init</span></span><br><span class="line"><span class="comment"> ***************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FirstStageInit</span> :</span> <span class="keyword">public</span> BaseInit &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FirstStageInit(<span class="keyword">char</span> *argv[], BootConfig *config) : BaseInit(argv, config) &#123;</span><br><span class="line">        LOGD(<span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        prepare();</span><br><span class="line">        exec_init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SecondStageInit</span> :</span> <span class="keyword">public</span> MagiskInit &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">prepare</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SecondStageInit(<span class="keyword">char</span> *argv[]) : MagiskInit(argv) &#123;</span><br><span class="line">        LOGD(<span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> is_rootfs = prepare();</span><br><span class="line">        <span class="keyword">if</span> (is_rootfs)</span><br><span class="line">            patch_rw_root();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            patch_ro_root();</span><br><span class="line">        exec_init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>FirstStageInit 的 prepare 非常简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#define INIT_PATH  &quot;&#x2F;system&#x2F;bin&#x2F;init&quot;</span><br><span class="line">#define REDIR_PATH &quot;&#x2F;data&#x2F;magiskinit&quot;</span><br><span class="line"></span><br><span class="line">void FirstStageInit::prepare() &#123;</span><br><span class="line">    prepare_data();</span><br><span class="line">    restore_ramdisk_init();</span><br><span class="line">    auto init &#x3D; mmap_data(&quot;&#x2F;init&quot;, true);</span><br><span class="line">    &#x2F;&#x2F; Redirect original init to magiskinit</span><br><span class="line">    for (size_t off : init.patch(INIT_PATH, REDIR_PATH)) &#123;</span><br><span class="line">        LOGD(&quot;Patch @ %08zX [&quot; INIT_PATH &quot;] -&gt; [&quot; REDIR_PATH &quot;]\n&quot;, off);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数做了什么呢？首先，<code>prepare_data()</code> 给 /data 挂上了 tmpfs，释放文件到 /data，把 magiskinit 复制到 /data/magiskinit；接着将原本 init 里的 <code>/system/bin/init</code> patch 成了 <code>/data/magiskinit</code>。</p><p>为什么可以这样做呢？还是得看回上面的特性。我们知道，switch root 前的 mount 会保留到 switch root 之后，所以可以用这种方法保留某些东西；但是，mount 要求目标文件（夹）必须存在，而 /system 并不可写，所以自己 mkdir 一个文件夹，mount tmpfs 然后指望 init 帮我们 move mount 的做法行不通。为了保留某些东西，我们必须选一个 init first stage 到 selinux_setup 期间都不会被使用到的文件夹来帮我们放东西，而 magisk 选择的是 /data。这让 patch init 使得 init 执行 /system/bin/init 进行 selinux_setup 时转为执行 magiskinit。</p><p>第二阶段的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> SecondStageInit::prepare() &#123;</span><br><span class="line">    <span class="comment">/** 这一行 unmount 是给 Legacy SAR with 2SI 使用的 **/</span></span><br><span class="line">    umount2(<span class="string">"/init"</span>, MNT_DETACH);</span><br><span class="line">    unlink(<span class="string">"/data/init"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure init dmesg logs won't get messed up</span></span><br><span class="line">    argv[<span class="number">0</span>] = (<span class="keyword">char</span> *) INIT_PATH;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some weird devices like meizu, uses 2SI but still have legacy rootfs</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">statfs</span> <span class="title">sfs</span>&#123;</span>&#125;;</span><br><span class="line">    statfs(<span class="string">"/"</span>, &amp;sfs);</span><br><span class="line">    <span class="comment">/** 魅族设备的 2SI 不会 switch root，所以依然在 rootfs，需要判断这种特殊情况 **/</span></span><br><span class="line">    <span class="keyword">if</span> (sfs.f_type == RAMFS_MAGIC || sfs.f_type == TMPFS_MAGIC) &#123;</span><br><span class="line">        <span class="comment">// We are still on rootfs, so make sure we will execute the init of the 2nd stage</span></span><br><span class="line">        unlink(<span class="string">"/init"</span>);</span><br><span class="line">        xsymlink(INIT_PATH, <span class="string">"/init"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ROOTMIR         MIRRDIR <span class="meta-string">"/system_root"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEW_INITRC_DIR  <span class="meta-string">"/system/etc/init/hw"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MagiskInit::patch_ro_root() &#123;</span><br><span class="line">    mount_list.emplace_back(<span class="string">"/data"</span>);</span><br><span class="line">    parse_config_file();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Android 11+ sbin 可能不存在，使用 /debug_ramdisk 代替 **/</span></span><br><span class="line">    <span class="built_in">string</span> tmp_dir;</span><br><span class="line">    <span class="keyword">if</span> (access(<span class="string">"/sbin"</span>, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        tmp_dir = <span class="string">"/sbin"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tmp_dir = <span class="string">"/debug_ramdisk"</span>;</span><br><span class="line">        xmkdir(<span class="string">"/data/debug_ramdisk"</span>, <span class="number">0</span>);</span><br><span class="line">        xmount(<span class="string">"/debug_ramdisk"</span>, <span class="string">"/data/debug_ramdisk"</span>, <span class="literal">nullptr</span>, MS_MOVE, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 初始化 magisk internal tmpfs **/</span></span><br><span class="line">    setup_tmp(tmp_dir.data());</span><br><span class="line">    chdir(tmp_dir.data());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tmp_dir == <span class="string">"/sbin"</span>) &#123;</span><br><span class="line">        <span class="comment">// Recreate original sbin structure</span></span><br><span class="line">        xmkdir(ROOTMIR, <span class="number">0755</span>);</span><br><span class="line">        xmount(<span class="string">"/"</span>, ROOTMIR, <span class="literal">nullptr</span>, MS_BIND, <span class="literal">nullptr</span>);</span><br><span class="line">        recreate_sbin(ROOTMIR <span class="string">"/sbin"</span>, <span class="literal">true</span>);</span><br><span class="line">        xumount2(ROOTMIR, MNT_DETACH);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Restore debug_ramdisk</span></span><br><span class="line">        xmount(<span class="string">"/data/debug_ramdisk"</span>, <span class="string">"/debug_ramdisk"</span>, <span class="literal">nullptr</span>, MS_MOVE, <span class="literal">nullptr</span>);</span><br><span class="line">        rmdir(<span class="string">"/data/debug_ramdisk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xrename(<span class="string">"overlay.d"</span>, ROOTOVL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">bool</span> avd_hack;</span><br><span class="line">    <span class="comment">// Handle avd hack</span></span><br><span class="line">    <span class="keyword">if</span> (avd_hack) &#123;</span><br><span class="line">        <span class="comment">// Android API 28 AVD 模拟器相关，跳过</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    load_overlay_rc(ROOTOVL);</span><br><span class="line">    <span class="keyword">if</span> (access(ROOTOVL <span class="string">"/sbin"</span>, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Move files in overlay.d/sbin into tmp_dir</span></span><br><span class="line">        mv_path(ROOTOVL <span class="string">"/sbin"</span>, <span class="string">"."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 修补 init.rc，注入 magisk 自己的服务 **/</span></span><br><span class="line">    <span class="comment">// Patch init.rc</span></span><br><span class="line">    <span class="keyword">if</span> (access(NEW_INITRC_DIR, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Android 11's new init.rc</span></span><br><span class="line">        patch_rc_scripts(NEW_INITRC_DIR, tmp_dir.data(), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        patch_rc_scripts(<span class="string">"/"</span>, tmp_dir.data(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Extract magisk</span></span><br><span class="line">    extract_files(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 修补 sepolicy，注入我们的规则 **/</span></span><br><span class="line">    <span class="comment">// Oculus Go will use a special sepolicy if unlocked</span></span><br><span class="line">    <span class="keyword">if</span> (access(<span class="string">"/sepolicy.unlocked"</span>, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        patch_sepolicy(<span class="string">"/sepolicy.unlocked"</span>, ROOTOVL <span class="string">"/sepolicy.unlocked"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((access(SPLIT_PLAT_CIL, F_OK) != <span class="number">0</span> &amp;&amp; access(<span class="string">"/sepolicy"</span>, F_OK) == <span class="number">0</span>) ||</span><br><span class="line">               !hijack_sepolicy()) &#123;</span><br><span class="line">        patch_sepolicy(<span class="string">"/sepolicy"</span>, ROOTOVL <span class="string">"/sepolicy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 用 bind mount 将需要修改的文件给一个个 mount 上去，这样就实现了不修改真实分区而修改文件 **/</span></span><br><span class="line">    <span class="comment">// Mount rootdir</span></span><br><span class="line">    magic_mount(ROOTOVL);</span><br><span class="line">    <span class="keyword">int</span> dest = xopen(ROOTMNT, O_WRONLY | O_CREAT, <span class="number">0</span>);</span><br><span class="line">    write(dest, magic_mount_list.data(), magic_mount_list.length());</span><br><span class="line">    close(dest);</span><br><span class="line"></span><br><span class="line">    chdir(<span class="string">"/"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致逻辑还是差不多的，只不过多了一些不同系统的处理（比如魅族设备需要特殊处理，这里因为 rootfs 仍然可写所以直接走 rootfs 逻辑就好了），还有由于 switch root 后 <code>/</code> 并不可写，所以所有对文件的修改都是先把修改过的文件放在 magisk internal tmpfs 内，然后 bind mount 到它原始的路径。<br>大致流程为：</p><ol><li>kernel 执行 init，magiskinit 被运行，检测系统环境，判断为 2SI 设备第一阶段，进入 FirstStageInit</li><li>挂载 /data 为 tmpfs，释放 /data/magiskinit</li><li>修补原始 init，重定向 /system/bin/init 到 /data/magiskinit，然后执行原始 init</li><li>原始 init 会挂载 /system 然后 switch root 进去，接下来它执行 <del>/system/bin/init</del>（被我们 patch 了所以会执行 /data/magiskinit）进行 selinux_setup</li><li>magiskinit 被再次执行，看见 selinux_setup 知道这是二阶段，switch root 已经完成，开始 <code>patch_ro_root()</code></li><li>修补 init.rc，注入我们的代码</li><li>修补 sepolicy，注入我们的规则（细节后面再谈）</li><li>利用 bind mount 替换 所有需要修改的文件</li><li>执行系统原来的 init，继续开机流程</li><li>init 会解析并执行 init.rc，运行 magisk</li></ol><h3 id="Legacy-SAR"><a href="#Legacy-SAR" class="headerlink" title="Legacy SAR"></a>Legacy SAR</h3><p>终于讲到 Legacy SAR 这个坑人的玩意了。。。<br>这玩意坑人的地方在于：</p><ol><li>boot.img 内 ramdisk 正常情况不会用到，magiskinit 根本没机会执行。对于 A/B 设备，boot 里放着的是 recovery ramdisk，bootloader 通过向内核传递 <code>skip_initramfs</code> 来让内核知道该不该挂载 initramfs。Magisk 的解决办法是，安装的时候 patch 一下内核，把 <code>skip_initramfs</code> patch 成别的东西这样内核就认不出来 bootloader 传的是什么了，然后就会乖乖的挂载 initramfs。但对于 A-only 设备，boot.img 里根本没有 ramdisk，就算手动加一个 ramdisk，bootloader 也很有可能并不识别它，根本没办法插一脚。Magisk 表示臣妾无能为力，patch recovery.img 然后每次都重启到 recovery 用吧，要不然我也插不进去啊~</li><li>即使我们成功把 init 偷梁换柱成了 magiskinit，<code>/</code> 也是 system.img，写不了，很难干活。</li></ol><p>来看看 magiskinit 的代码吧：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*************</span></span><br><span class="line"><span class="comment"> * Legacy SAR</span></span><br><span class="line"><span class="comment"> *************/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LegacySARInit</span> :</span> <span class="keyword">public</span> MagiskInit &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">mount_system_root</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">first_stage_prep</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LegacySARInit(<span class="keyword">char</span> *argv[], BootConfig *config) : MagiskInit(argv, config) &#123;</span><br><span class="line">        LOGD(<span class="string">"%s\n"</span>, __FUNCTION__);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> override </span>&#123;</span><br><span class="line">        prepare_data();</span><br><span class="line">        <span class="keyword">bool</span> is_two_stage = mount_system_root();</span><br><span class="line">        <span class="keyword">if</span> (is_two_stage)</span><br><span class="line">            first_stage_prep();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            patch_ro_root();</span><br><span class="line">        exec_init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> LegacySARInit::mount_system_root() &#123;</span><br><span class="line">    LOGD(<span class="string">"Mounting system_root\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// there's no /dev in stub cpio</span></span><br><span class="line">    xmkdir(<span class="string">"/dev"</span>, <span class="number">0777</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">strcpy</span>(blk_info.block_dev, <span class="string">"/dev/root"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// Try legacy SAR dm-verity</span></span><br><span class="line">        <span class="built_in">strcpy</span>(blk_info.partname, <span class="string">"vroot"</span>);</span><br><span class="line">        <span class="keyword">auto</span> dev = setup_block();</span><br><span class="line">        <span class="keyword">if</span> (dev &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> mount_root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Try NVIDIA naming scheme</span></span><br><span class="line">        <span class="built_in">strcpy</span>(blk_info.partname, <span class="string">"APP"</span>);</span><br><span class="line">        dev = setup_block();</span><br><span class="line">        <span class="keyword">if</span> (dev &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> mount_root;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sprintf</span>(blk_info.partname, <span class="string">"system%s"</span>, config-&gt;slot);</span><br><span class="line">        dev = setup_block();</span><br><span class="line">        <span class="keyword">if</span> (dev &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> mount_root;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Poll forever if rootwait was given in cmdline</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (config-&gt;rootwait);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't really know what to do at this point...</span></span><br><span class="line">    LOGE(<span class="string">"Cannot find root partition, abort\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">mount_root:</span><br><span class="line">    xmkdir(<span class="string">"/system_root"</span>, <span class="number">0755</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (xmount(<span class="string">"/dev/root"</span>, <span class="string">"/system_root"</span>, <span class="string">"ext4"</span>, MS_RDONLY, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xmount(<span class="string">"/dev/root"</span>, <span class="string">"/system_root"</span>, <span class="string">"erofs"</span>, MS_RDONLY, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">            <span class="comment">// We don't really know what to do at this point...</span></span><br><span class="line">            LOGE(<span class="string">"Cannot mount root partition, abort\n"</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    switch_root(<span class="string">"/system_root"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make dev writable</span></span><br><span class="line">    xmount(<span class="string">"tmpfs"</span>, <span class="string">"/dev"</span>, <span class="string">"tmpfs"</span>, <span class="number">0</span>, <span class="string">"mode=755"</span>);</span><br><span class="line">    mount_list.emplace_back(<span class="string">"/dev"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the apex folder to determine whether 2SI (Android 10+)</span></span><br><span class="line">    <span class="keyword">bool</span> is_two_stage = access(<span class="string">"/apex"</span>, F_OK) == <span class="number">0</span>;</span><br><span class="line">    LOGD(<span class="string">"is_two_stage: [%d]\n"</span>, is_two_stage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For API 28 AVD, it uses legacy SAR setup that requires</span></span><br><span class="line">    <span class="comment">// special hacks in magiskinit to work properly.</span></span><br><span class="line">    <span class="keyword">if</span> (!is_two_stage &amp;&amp; config-&gt;emulator) &#123;</span><br><span class="line">        <span class="comment">// AVD，不重要</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> is_two_stage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> LegacySARInit::first_stage_prep() &#123;</span><br><span class="line">    <span class="comment">// Patch init binary</span></span><br><span class="line">    <span class="keyword">int</span> src = xopen(<span class="string">"/init"</span>, O_RDONLY);</span><br><span class="line">    <span class="keyword">int</span> dest = xopen(<span class="string">"/data/init"</span>, O_CREAT | O_WRONLY, <span class="number">0</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">mmap_data <span class="title">init</span><span class="params">(<span class="string">"/init"</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> off : init.patch(INIT_PATH, REDIR_PATH)) &#123;</span><br><span class="line">            LOGD(<span class="string">"Patch @ %08zX ["</span> INIT_PATH <span class="string">"] -&gt; ["</span> REDIR_PATH <span class="string">"]\n"</span>, off);</span><br><span class="line">        &#125;</span><br><span class="line">        write(dest, init.buf(), init.sz());</span><br><span class="line">        fclone_attr(src, dest);</span><br><span class="line">        close(dest);</span><br><span class="line">        close(src);</span><br><span class="line">    &#125;</span><br><span class="line">    xmount(<span class="string">"/data/init"</span>, <span class="string">"/init"</span>, <span class="literal">nullptr</span>, MS_BIND, <span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结如下：</p><ol><li>magiskinit 被运行，检测系统环境，判断为 Legacy SAR，进入 LegacySARInit</li><li>因为 kernel 被我们 patch 了，原本 switch root 应该由 kernel 来做的，现在没有了，需要手动 mount /system 然后 switch root 进去</li><li>检测有没有 /apex，有的话代表 Android 10+，init 有 selinux_setup 阶段，可以劫持，走 <code>first_stage_prep()</code>；没有的话直接 <code>patch_ro_boot()</code> 然后执行原来的 init</li><li><code>first_stage_prep()</code> 里会像 Modern 2SI 那样修补 init，将 /system/bin/init 重定向到 /data/magiskinit，然后把它挂载到 /init 以供后面执行；执行原来的 init。</li><li>原来的 init 执行 selinux_setup（若有），转到 magiskinit，magiskinit 识别到二阶段，自动 <code>patch_ro_boot()</code></li><li><code>patch_ro_boot()</code> 完成之后，执行 init 交还控制权，继续开机</li></ol><h3 id="修补-SEPolicy"><a href="#修补-SEPolicy" class="headerlink" title="修补 SEPolicy"></a>修补 SEPolicy</h3><p>由于这一块过于复杂，所以单独放一节讲。</p><p>如果你仔细看了上面的代码，你会发现修补 SEPolicy 有 <code>patch_sepolicy()</code> 以及 <code>hijack_sepolicy()</code> 两个函数，那么它们有什么不同呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> MagiskInit::patch_sepolicy(<span class="keyword">const</span> <span class="keyword">char</span> *in, <span class="keyword">const</span> <span class="keyword">char</span> *out) &#123;</span><br><span class="line">    LOGD(<span class="string">"Patching monolithic policy\n"</span>);</span><br><span class="line">    <span class="keyword">auto</span> sepol = <span class="built_in">unique_ptr</span>&lt;sepolicy&gt;(sepolicy::from_file(in));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 修补 sepolicy **/</span></span><br><span class="line">    sepol-&gt;magisk_rules();</span><br><span class="line"></span><br><span class="line">    LOGD(<span class="string">"Dumping sepolicy to: [%s]\n"</span>, out);</span><br><span class="line">    sepol-&gt;to_file(out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove OnePlus stupid debug sepolicy and use our own</span></span><br><span class="line">    <span class="keyword">if</span> (access(<span class="string">"/sepolicy_debug"</span>, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        unlink(<span class="string">"/sepolicy_debug"</span>);</span><br><span class="line">        link(<span class="string">"/sepolicy"</span>, <span class="string">"/sepolicy_debug"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOCK_COMPAT    SELINUXMOCK <span class="meta-string">"/compatible"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOCK_LOAD      SELINUXMOCK <span class="meta-string">"/load"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOCK_ENFORCE   SELINUXMOCK <span class="meta-string">"/enforce"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> MagiskInit::hijack_sepolicy() &#123;</span><br><span class="line">    xmkdir(SELINUXMOCK, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (access(<span class="string">"/system/bin/init"</span>, F_OK) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// On 2SI devices, the 2nd stage init file is always a dynamic executable.</span></span><br><span class="line">        <span class="comment">// This meant that instead of going through convoluted methods trying to alter</span></span><br><span class="line">        <span class="comment">// and block init's control flow, we can just LD_PRELOAD and replace the</span></span><br><span class="line">        <span class="comment">// security_load_policy function with our own implementation.</span></span><br><span class="line">        dump_preload();</span><br><span class="line">        setenv(<span class="string">"LD_PRELOAD"</span>, <span class="string">"/dev/preload.so"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hijack the "load" and "enforce" node in selinuxfs to manipulate</span></span><br><span class="line">    <span class="comment">// the actual sepolicy being loaded into the kernel</span></span><br><span class="line">    <span class="keyword">auto</span> hijack = [&amp;] &#123;</span><br><span class="line">        LOGD(<span class="string">"Hijack ["</span> SELINUX_LOAD <span class="string">"]\n"</span>);</span><br><span class="line">        close(xopen(MOCK_LOAD, O_CREAT | O_RDONLY, <span class="number">0600</span>));</span><br><span class="line">        xmount(MOCK_LOAD, SELINUX_LOAD, <span class="literal">nullptr</span>, MS_BIND, <span class="literal">nullptr</span>);</span><br><span class="line">        LOGD(<span class="string">"Hijack ["</span> SELINUX_ENFORCE <span class="string">"]\n"</span>);</span><br><span class="line">        mkfifo(MOCK_ENFORCE, <span class="number">0644</span>);</span><br><span class="line">        xmount(MOCK_ENFORCE, SELINUX_ENFORCE, <span class="literal">nullptr</span>, MS_BIND, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> dt_compat;</span><br><span class="line">    <span class="keyword">if</span> (access(SELINUX_ENFORCE, F_OK) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// selinuxfs not mounted yet. Hijack the dt fstab nodes first</span></span><br><span class="line">        <span class="comment">// and let the original init mount selinuxfs for us.</span></span><br><span class="line">        <span class="comment">// This only happens on Android 8.0 - 9.0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">        ssprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%s/fstab/compatible"</span>, config-&gt;dt_dir);</span><br><span class="line">        dt_compat = full_read(buf);</span><br><span class="line">        <span class="keyword">if</span> (dt_compat.empty()) &#123;</span><br><span class="line">            <span class="comment">// Device does not do early mount and uses monolithic policy</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remount procfs with proper options</span></span><br><span class="line">        xmount(<span class="literal">nullptr</span>, <span class="string">"/proc"</span>, <span class="literal">nullptr</span>, MS_REMOUNT, <span class="string">"hidepid=2,gid=3009"</span>);</span><br><span class="line"></span><br><span class="line">        LOGD(<span class="string">"Hijack [%s]\n"</span>, buf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Preserve sysfs and procfs for hijacking</span></span><br><span class="line">        mount_list.erase(<span class="built_in">std</span>::remove_if(</span><br><span class="line">                mount_list.begin(), mount_list.end(),</span><br><span class="line">                [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) &#123; <span class="keyword">return</span> s == <span class="string">"/proc"</span> || s == <span class="string">"/sys"</span>; &#125;), mount_list.end());</span><br><span class="line"></span><br><span class="line">        mkfifo(MOCK_COMPAT, <span class="number">0444</span>);</span><br><span class="line">        xmount(MOCK_COMPAT, buf, <span class="literal">nullptr</span>, MS_BIND, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        hijack();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a new process waiting for init operations</span></span><br><span class="line">    <span class="keyword">if</span> (xfork()) &#123;</span><br><span class="line">        <span class="comment">// In parent, return and continue boot process</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dt_compat.empty()) &#123;</span><br><span class="line">        <span class="comment">// This open will block until init calls DoFirstStageMount</span></span><br><span class="line">        <span class="comment">// The only purpose here is actually to wait for init to mount selinuxfs for us</span></span><br><span class="line">        <span class="keyword">int</span> fd = xopen(MOCK_COMPAT, O_WRONLY);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">4096</span>];</span><br><span class="line">        ssprintf(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%s/fstab/compatible"</span>, config-&gt;dt_dir);</span><br><span class="line">        xumount2(buf, MNT_DETACH);</span><br><span class="line"></span><br><span class="line">        hijack();</span><br><span class="line"></span><br><span class="line">        xwrite(fd, dt_compat.data(), dt_compat.size());</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This open will block until init calls security_getenforce</span></span><br><span class="line">    <span class="keyword">int</span> fd = xopen(MOCK_ENFORCE, O_WRONLY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cleanup the hijacks</span></span><br><span class="line">    umount2(<span class="string">"/init"</span>, MNT_DETACH);</span><br><span class="line">    xumount2(SELINUX_LOAD, MNT_DETACH);</span><br><span class="line">    xumount2(SELINUX_ENFORCE, MNT_DETACH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load and patch policy</span></span><br><span class="line">    <span class="keyword">auto</span> sepol = <span class="built_in">unique_ptr</span>&lt;sepolicy&gt;(sepolicy::from_file(MOCK_LOAD));</span><br><span class="line">    sepol-&gt;magisk_rules();</span><br><span class="line">    sepol-&gt;load_rules(rules);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Load patched policy into kernel</span></span><br><span class="line">    sepol-&gt;to_file(SELINUX_LOAD);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write to the enforce node ONLY after sepolicy is loaded. We need to make sure</span></span><br><span class="line">    <span class="comment">// the actual init process is blocked until sepolicy is loaded, or else</span></span><br><span class="line">    <span class="comment">// restorecon will fail and re-exec won't change context, causing boot failure.</span></span><br><span class="line">    <span class="comment">// We (ab)use the fact that init reads the enforce node, and because</span></span><br><span class="line">    <span class="comment">// it has been replaced with our FIFO file, init will block until we</span></span><br><span class="line">    <span class="comment">// write something into the pipe, effectively hijacking its control flow.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> enforce = full_read(SELINUX_ENFORCE);</span><br><span class="line">    xwrite(fd, enforce.data(), enforce.length());</span><br><span class="line">    close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point, the init process will be unblocked</span></span><br><span class="line">    <span class="comment">// and continue on with restorecon + re-exec.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Terminate process</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最直观的感觉就是，两个函数代码量不一样……</p><p>Android 上，sepolicy 可以以单个的 sepolicy 文件的形式存储，也可以存储多个拆分的 cil 文件；前者被称为 monolithic policy，后者被称为 split sepolicy。Linux 内核只接受 monolithic policy，所以加载 split sepolicy 时，由 init 进程负责将 cil 文件编译为 monolithic policy 并加载进内核。</p><p>对于 monolithic policy，magiskinit patch 起来非常轻松惬意：直接加载 /sepolicy，修改，放回去，然后 init 加载的时候就会加载我们修改过的 sepolicy。</p><p>而对于 split policy 可就麻烦了，init 运行之前可能根本没有 /sepolicy 给你 patch，怎么办呢？因为 init 会把 cil 全部编译成 monolithic policy 然后再传进内核里（具体是往 <code>/sys/fs/selinux/load</code> 写入），要是有方法拦截这个写入过程就好了！</p><p>有吗？还真有。</p><p>先快速介绍一下 FIFO 的概念：FIFO 看起来就像一个普通的文件，但是它用起来类似 pipe，就是一根管子，当一个进程往里写内容的时候，另一个进程能读取到。反过来，一个进程读它的时候，默认会阻塞，直到有另外的进程打开了这个 FIFO 并且写入内容。说白了就是一个专门用来进程间通信的管子，只不过长得是个文件而已。</p><p>Magisk 的 <code>hijack_policy()</code> 正是利用了 FIFO 的特性，才能拦截到 init 加载 sepolicy 的过程。<br>具体来说，大致分为以下几步：</p><ol><li>判断 selinuxfs 有没有被挂载，如果没有需要先等 init 挂载 selinuxfs。这里我们同样利用 FIFO，选择了一个 init 挂载完 selinuxfs 之后会读取的文件，来卡住时机。里面的注释 <code>This only happens on Android 8.0 - 9.0</code> 其实是因为更旧的版本没有 split policy，直接 patch monolithic policy 就好了，不用走 hijack；而 Android 10+ init 始终分为三步，我们永远在 selinux_setup 时进行 hijack，此时 first stage 已经走完了，selinuxfs 肯定已经被 init mount 上了；只有 Android 8.0-9.0，有可能有 split policy 又没有单独的 selinux_setup 这一步可以拦截，所以只能手动进行特殊处理。</li><li>用 bind mount 把 <code>/sys/fs/selinux/load</code> 覆盖成一个普通的文件，这样 init 往里写入 sepolicy 时其实是写进了我们的文件，而不是内核里</li><li>调用 <code>mkfifo()</code> 创建一个 FIFO，然后 bind mount 到 <code>/sys/fs/selinux/enforce</code> 上面</li><li>fork 一个子进程，父进程继续执行剩余步骤，然后执行原始 init；子进程会以 write-only 的方式打开这个 FIFO，此时因为 FIFO 的特性，这个进程会阻塞，直到有另一个进程以 read 方式打开同样的 FIFO。在我们的例子当中，子进程会阻塞，直到 init 调用 <code>security_getenforce()</code> 读取了 <code>/sys/fs/selinux/enforce</code>，此时 init 阻塞，等待我们的子进程往 FIFO 内写入内容，而此时 init 已经把要加载的 sepolicy 写入到了 <code>/sys/fs/selinux/load</code></li><li>读取 init 原本要加载的 sepolicy，进行 patch 注入自己的规则，然后手动加载进内核里（因为之前 init 尝试加载的时候被我们给拦了）</li><li>往 FIFO 写入内容，唤醒对端的 init 进程，做一些 cleanup 然后可以退出子进程。</li></ol><p>虽然整个 hijack 还使用了 <code>LD_PRELOAD</code> 等技术来保证 sepolicy hijack 能够正常工作，但大致流程就是如上所示。整个机制非常精妙，非常依赖 init 的实际行为，需要结合 android init 及 libselinux 的源码反复琢磨才能搞清其中逻辑。</p><br><section class="widget copyright desktop mobile"><div class="content"><blockquote><p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p><p>本文永久链接是：<a href="https://blog.canyie.top/2023/11/12/android-booting-shenanigans-and-magiskinit-analysing/">https://blog.canyie.top/2023/11/12/android-booting-shenanigans-and-magiskinit-analysing/</a></p></blockquote></div></section></div><section class="meta" id="footer-meta"><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2025-04-24T18:33:02+08:00"><a class="notlink"><i class="fas fa-edit fa-fw" aria-hidden="true"></i><p>更新于2025年4月24日</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/android/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>android</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/magisk/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>magisk</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/system/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>system</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="/tags/kernel/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>kernel</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" rel="external nofollow noopener noreferrer noopener" href="http://connect.qq.com/widget/shareqq/index.html?url=https://blog.canyie.top/2023/11/12/android-booting-shenanigans-and-magiskinit-analysing/&title=在故事开始之前的故事：Android 启动过程与 magiskinit 分析 - 残页的小博客&summary=终于开了一直想写的这篇文章，再不写点东西就真的是年更博客了……本文可以认为是 Android Booting Shenanigans 的中文补充说明，同时添加了 magiskinit 的一些处理细节。即使你对 magiskinit 没兴趣也可以看看，说不定就有一些你平时从来没注意到的细节呢 :)" target="_blank"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png"> </a><a class="-mob-share-qzone" rel="external nofollow noopener noreferrer noopener" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://blog.canyie.top/2023/11/12/android-booting-shenanigans-and-magiskinit-analysing/&title=在故事开始之前的故事：Android 启动过程与 magiskinit 分析 - 残页的小博客&summary=终于开了一直想写的这篇文章，再不写点东西就真的是年更博客了……本文可以认为是 Android Booting Shenanigans 的中文补充说明，同时添加了 magiskinit 的一些处理细节。即使你对 magiskinit 没兴趣也可以看看，说不定就有一些你平时从来没注意到的细节呢 :)" target="_blank"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png"> </a><a class="-mob-share-weibo" rel="external nofollow noopener noreferrer noopener" href="http://service.weibo.com/share/share.php?url=https://blog.canyie.top/2023/11/12/android-booting-shenanigans-and-magiskinit-analysing/&title=在故事开始之前的故事：Android 启动过程与 magiskinit 分析 - 残页的小博客&summary=终于开了一直想写的这篇文章，再不写点东西就真的是年更博客了……本文可以认为是 Android Booting Shenanigans 的中文补充说明，同时添加了 magiskinit 的一些处理细节。即使你对 magiskinit 没兴趣也可以看看，说不定就有一些你平时从来没注意到的细节呢 :)" target="_blank"><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASwAAAEsCAMAAABOo35HAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAC9UExURVlZWdPT07KysmRkZIWFhfT09JmZmWZmZm9vb39/fxkZGUxMTDMzM3p6epCQkKamppubm729venp6cjIyN7e3tbW1s/Pz8LCwnx8fLS0tFZWVoiIiI+Pj6GhoeTk5Glpabu7u93d3evr66CgoJSUlKqqqsnJyeDg4Hd3d8PDw+Xl5bi4uNHR0dvb26Ojo6urq+fn51hYWDg4OCgoKHBwcK2traenp0FBQe7u7vHx8U5OTre3t8zMzHV1df///7GrnpQAAAA/dFJOU///////////////////////////////////////////////////////////////////////////////////AI4mfBcAAAUGSURBVHja7NoJb6M4GMZxY0NCD64kve/pMZ2d3Z297+X7f6zFNmBAMUXa6URl/q9UJSWPUPzrizFWRUlNLgEBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYYIEFAVhggQUWWGBBABZYYIEFFlgQgAUWWGCBBRYEYIEFFlhggQUBWGCBBRZYYEEAFlhggQUWWBCABRZYYIEFFgRggQUWWGCBBQFYYIEFFlhgQQAWWGCBBRZYEIAFFlhggQUWBGCBBRZYn6cCIcRXgvX/h9qcIVBqDdbEM8RCxGCB9QqXYRwHYDHBgwXWl8eKZKiESHI3Ba1kWs3fKixcaJUl1YyeBm7Ocq+yLItUiVBGnXxenSHJolIKEcwHq6ikbOX1YGVzQCTN8LPmSLreghUl9sN4Uw7yajMrLC0TZ1ImzqY6FEop0+pIaEN5HaoOxVuwEqFyc4I46uSlzOLqgxlh6UaR9l3VYWl9Fdoxb1Q90KJtu41pwwFW/WHhTtW8i7TafLCqRsk6bsGw63L9qurXRmuIlbT9lDQnlXU+nBFW1Q2qnZbDprWa2tjR90LZFqx1/+Td/HpGWLlrLDvIwTcx6dQ1Vrntbig68cDms3JwbA5Y1azs1ger6sNV/bbIw1jU81MvNAGrl58RVn8ozW+btF08iGFoAlYvP3csfVur1gJBEIA1uBmue5dhZDOyO2epbmgCVi8/I6x0MMHH9pjsTfBhNzQBq5uPZoQlB0uH3DZG4EZqQ26fL3sZq5uf09Ih6qw3i/pm6BZO0qZX7rrUS68Xsbr5ZE4rePMk08pk9aUZugfqppvs6AM1Acvlo/StP+6EbW06z8hJqxbYp2BZPQUnFsLsKuhQdaHqn5ewbF7KXIn0jWO5MqOQ7RaNLPtbNMmmhimj0GUmYLl8Gs0Lq4wyPbTu1l2QKqHSouzs3OlDIslW5SQsnY/NXmFplyNvEuuLV/Tau9BzwiraDUSwXmysztYWWNtL1psXeumgIrDGaqXvBfUuvtqUYI3V2t1wk1e2msFluJJm6zDJXv/fIfjPP7DAAgsssCiwwAILLLDAosACCyywwAKLAgsssMACC6zt9fDz/v75tyOB+98PD2+ORgKffjw4OP1uJPDxl+Xy8v1I4MPF3t7VNyOB4/vF4uzdzrG+39f1kz/w66Guv/yBvw90KX/gZKkr8Qf+2dOV+gNHC12/7RxrabD2/a31bLAO/a11YbAO/K21MFhLf2s9Gqw9f2vdGqzFu11jnVusE2/gxmI9eQOnFuvYG7i0WH7uK4t15w2cWazrXWP9a7H8f/bQYvm/6IPF+sF/pVssf19Ii/WH/0K2WH/uGuvEWC39gSdj9Twy+Rqri5EZx1gt/IE7Y/XoD1wbq9vd3w1PlufnD2OBp+ebm/uxwPHF6emnscDR4vLy41jg7vHq6sNY4Pr27OyYdRaLUrDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssMCiwAILLLDAAosCCyywwAILLAossMACCyywKLDAAgsssL6u+k+AAQCR9eHtLKvLfwAAAABJRU5ErkJggg==" data-original="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png"></a></div></div></div></section><div class="prev-next"><a class="prev" href="/2024/04/18/android-security-bulletin-index/"><p class="title"><i class="fas fa-chevron-left" aria-hidden="true"></i>Android 2024 每月安全补丁分析索引</p><p class="content">之前一直在看的每月补丁分析的博客 https://wrlus.com/ 看起来是不再更新了，想了想反正自己每个月也要去追着看，干脆写一下分析得了，方便自己后面找。本人很菜，分析的大部分都是 Ja...</p></a><a class="next" href="/2023/11/06/first-19-years-of-my-life/"><p class="title">若人生是场大梦啊——记我人生的前19年<i class="fas fa-chevron-right" aria-hidden="true"></i></p><p class="content">上次发年终总结还是 2022 年发 2021 年的，2022 年的年终总结缺失了。今年发生了好多好多的事情，一直想写今年的年终总结但是却总没到年终，干脆写成前 19 年纪念吧。从中职，到大学20...</p></a></div></section></article><script>window.subData={title:"在故事开始之前的故事：Android 启动过程与 magiskinit 分析",tools:!0}</script></div><aside class="l_side"><section class="widget toc-wrapper shadow blur desktop mobile"><header><i class="fas fa-list fa-fw" aria-hidden="true"></i><span class="name">本文目录</span></header><div class="content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android-Init"><span class="toc-text">Android Init</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#旧-rootfs-时代纯粹的-init"><span class="toc-text">旧 rootfs 时代纯粹的 init</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Project-Treble-带来的旧式-system-as-root-分区布局"><span class="toc-text">Project Treble 带来的旧式 system-as-root 分区布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Android-10-：有三步的两步启动！"><span class="toc-text">Android 10+：有三步的两步启动！</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#魅族：2SI，但是从-rootfs-到-rootfs"><span class="toc-text">魅族：2SI，但是从 rootfs 到 rootfs</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MagiskInit"><span class="toc-text">MagiskInit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RootFSInit"><span class="toc-text">RootFSInit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Modern-2SI"><span class="toc-text">Modern 2SI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Legacy-SAR"><span class="toc-text">Legacy SAR</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#修补-SEPolicy"><span class="toc-text">修补 SEPolicy</span></a></li></ol></li></ol></div></section><section class="widget tagcloud shadow blur desktop mobile"><header><a href="/tags/"><i class="fas fa-tags fa-fw" aria-hidden="true"></i><span class="name">热门标签</span></a></header><div class="content"><a href="/tags/AOP/" style="font-size:15.67px;color:#8e8e8e">AOP</a> <a href="/tags/android/" style="font-size:24px;color:#555">android</a> <a href="/tags/art/" style="font-size:19px;color:#777">art</a> <a href="/tags/dex/" style="font-size:14px;color:#999">dex</a> <a href="/tags/hidden-api/" style="font-size:14px;color:#999">hidden-api</a> <a href="/tags/hook/" style="font-size:15.67px;color:#8e8e8e">hook</a> <a href="/tags/kernel/" style="font-size:15.67px;color:#8e8e8e">kernel</a> <a href="/tags/magisk/" style="font-size:17.33px;color:#828282">magisk</a> <a href="/tags/parcel/" style="font-size:14px;color:#999">parcel</a> <a href="/tags/property/" style="font-size:14px;color:#999">property</a> <a href="/tags/system/" style="font-size:22.33px;color:#606060">system</a> <a href="/tags/xposed/" style="font-size:17.33px;color:#828282">xposed</a> <a href="/tags/%E5%AE%89%E5%85%A8/" style="font-size:20.67px;color:#6c6c6c">安全</a> <a href="/tags/%E5%AE%89%E5%85%A8%E8%A1%A5%E4%B8%81%E5%88%86%E6%9E%90%E6%A0%8F%E7%9B%AE/" style="font-size:15.67px;color:#8e8e8e">安全补丁分析栏目</a> <a href="/tags/%E5%B9%B4%E9%89%B4/" style="font-size:15.67px;color:#8e8e8e">年鉴</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size:14px;color:#999">数据结构与算法</a> <a href="/tags/%E6%B3%A8%E5%85%A5/" style="font-size:15.67px;color:#8e8e8e">注入</a> <a href="/tags/%E8%88%AA%E7%A9%BA/" style="font-size:14px;color:#999">航空</a> <a href="/tags/%E9%97%B2%E8%81%8A/" style="font-size:17.33px;color:#828282">闲聊</a></div></section></aside><footer class="clearfix"><br><br><br><div class="social-wrapper"><a href="/atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:a1364259@163.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/canyie" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank" rel="noopener">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p></div>本站使用 <a href="https://volantis.js.org/" target="_blank" class="codename">Volantis</a> 作为主题，总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次<div class="copyright"><p>如对本站有任何疑问或建议，欢迎到 <a href="https://github.com/canyie/canyie.github.io/issues/" target="_blank" rel="noopener">issues 区</a> 反馈~</p></div></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script><script>var SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){var a=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/BBC19066-E176-47C2-9D22-48C81EE5DF6B.jpeg"];!function(a){for(var t=a.length;t--;){var r=Math.floor(Math.random()*t),n=a[r];a[r]=a[t],a[t]=n}}(a),$.backstretch(a,{duration:"20000",fade:"1500"})})</script><script src="/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4/js/search.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "[object Object]";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script><script>
            window.imageLazyLoadSetting = {
                isSPA: false,
                processImages: null,
            };
        </script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})});</script><script>!function(n){n.imageLazyLoadSetting.processImages=o;var i=n.imageLazyLoadSetting.isSPA,r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]"));function o(){i&&(r=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")));for(var t,e,a=0;a<r.length;a++)t=r[a],e=void 0,0<=(e=t.getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(n.innerHeight||document.documentElement.clientHeight)&&function(){var t,e,n,i,o=r[a];t=o,e=function(){r=r.filter(function(t){return o!==t})},n=new Image,i=t.getAttribute("data-original"),n.onload=function(){t.src=i,e&&e()},n.src=i}()}o(),n.addEventListener("scroll",function(){var t,e;t=o,e=n,clearTimeout(t.tId),t.tId=setTimeout(function(){t.call(e)},500)})}(this);</script></body></html>